{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"","text":"<p><code>NeoPDF</code> is a fast, reliable, and scalable interpolation library for both Collinear Parton Distribution Functions (PDFs) and Transverse Momentum Dependent Distributions (TMDs) with modern features, designed for both present and future hadron collider experiments. It aims to be a modern, high-performance alternative to both LHAPDF and TMDlib, focusing on:</p> \ud83d\ude80 Performance <p>Written in Rust \ud83e\udd80 for speed and safety, with zero-cost abstractions and efficient memory management.</p> \ud83e\udde9 Flexibility <p>Easy support for different interpolation strategies, enabling seamless/efficient implementation of new methods.</p> \ud83c\udf10 Multi-Language Support <p>Native Rust \ud83e\udd80 API, with bindings for various programming languages such as Python, Fortran, C, C++, Mathematica.</p> \ud83d\udcca (Physics) Features &amp; Extensibility <p>Very extensible: makes it easy to introduce new (Physics) features without introducing technical debts.</p>"},{"location":"#motivation","title":"Motivation","text":"<p>The need for a fast and reliable PDF interpolation is critical in high-energy physics, especially for precision calculations at hadron colliders. Existing solutions like LHAPDF or TMDlib, while widely used, have limitations in terms of extensibility and features. <code>NeoPDF</code> addresses these by:</p> <ul> <li>Providing a modern, modular codebase.</li> <li>Enabling easy integration into new and existing workflows.</li> <li>Supporting advanced features such as multi-dimensional interpolations.</li> </ul>"},{"location":"#high-level-architecture","title":"High-Level Architecture","text":"<ul> <li>Core Library (Rust): Implements all the interpolation logics, grid management, and PDF     metadata handling.</li> <li>FFI Bindings: Exposes the core functionalities to Python, Fortran, C, and C++, enabling     easier interoperability with other codes that can link to these programming languages.</li> <li>CLI Tools: Command-line utilities that allow users to inspect the contents of a gird,     convert LHAPDF/TMDlib format into <code>NeoPDF</code>, and perform interpolations.</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<ul> <li>Installation Guide: Complete installation instructions for all platforms and APIs</li> <li>Development with Pixi: Comprehensive guide for using Pixi environment manager</li> <li>CLI Tutorials: Showcase how to use the command-line interface</li> <li>Examples: Code examples for Python, C++, C, and Fortran APIs</li> </ul>"},{"location":"#additional-resources","title":"Additional Resources","text":"<ul> <li>Pixi Documentation</li> <li>Rust Book</li> <li>PyO3 Documentation</li> <li>Cargo-c Documentation</li> <li>Maturin Documentation</li> </ul> <p>For more information about <code>NeoPDF</code> development, see the Design and Features documentation.</p>"},{"location":"cli-tutorials/","title":"CLI Tutorials","text":"<p>The <code>neopdf</code> CLI tool provides a command-line interface to the <code>NeoPDF</code> library, enabling users to perform PDF interpolation, alpha_s evaluation, file format conversion, and metadata inspection directly from the terminal. Below are detailed usage instructions and examples for each major feature.</p> <p>How to use the new NeoPDF format?</p> <ul> <li>To use the <code>NeoPDF</code> grid format, if available, simply append <code>.neopdf.lz4</code> to the name of the PDF set; LHAPDF   sets can be converted into the NeoPDF format using the CLI (see below)</li> <li>The CLI supports both eager and lazy loading of grids, and can operate on both standard and compressed formats</li> <li>For more advanced usage, see the help output:</li> </ul> <pre><code>neopdf --help\n</code></pre>"},{"location":"cli-tutorials/#reading-pdf-metadata-and-grid-information","title":"Reading PDF Metadata and Grid Information","text":""},{"location":"cli-tutorials/#read-metadata-for-a-pdf-set","title":"Read Metadata for a PDF Set","text":"<p>To read the metadata for a given PDF set:</p> <pre><code>neopdf read metadata NNPDF40_nnlo_as_01180\n</code></pre> <ul> <li><code>--pdf-name</code>: Name of the PDF set (can be a <code>NeoPDF</code> or <code>LHAPDF</code> set).</li> </ul> <p>The above command will print out the following output:</p> <pre><code>Set Description: NNPDF4.0 NNLO global fit, alphas(MZ)=0.1180. mem=0 =&gt; average on replicas; mem=1-100 =&gt; PDF replicas\nSet Index: 331100\nNumber of Members: 101\nXMin: 0.000000001\nXMax: 1\nQMin: 1.65\nQMax: 100000\nFlavors: [-5, -4, -3, -2, -1, 21, 1, 2, 3, 4, 5]\nFormat: lhagrid1\n...\nPolarized: false\nSet Type: SpaceLike\nInterpolator Type: LogBicubic\n...\n</code></pre>"},{"location":"cli-tutorials/#get-the-number-of-subgrids","title":"Get the Number of Subgrids","text":"<p>To get the number of subgrids a PDF contains:</p> <pre><code>neopdf read num_subgrids NNPDF40_nnlo_as_01180\n</code></pre> <ul> <li><code>--pdf-name</code>: Name of the PDF set.</li> </ul>"},{"location":"cli-tutorials/#get-knot-values-for-a-subgrid","title":"Get Knot Values for a Subgrid","text":"<p>To get the knot values for a given subgrid:</p> <pre><code>neopdf read subgrid-info NNPDF40_nnlo_as_01180 --member=0 --subgrid-index=1\n</code></pre> <ul> <li><code>--pdf-name</code>: Name of the PDF set.</li> <li><code>--member</code>: The member index (0-based).</li> <li><code>--subgrid-index</code>: The index of the subgrid to inspect.</li> </ul> <p>The above command will print out the following output:</p> <pre><code>Nucleon Numbers A: [0.0], shape=[1], strides=[1], layout=CFcf (0xf), const ndim=1\nAlphas values: [0.0], shape=[1], strides=[1], layout=CFcf (0xf), const ndim=1\nkT values: [0.0], shape=[1], strides=[1], layout=CFcf (0xf), const ndim=1\nx values: [1e-9, 1.2970848e-9, ...], shape=[196], strides=[1], layout=CFcf (0xf), const ndim=1\nQ2 values: [2.7224999999999997, ...], shape=[12], strides=[1], layout=CFcf (0xf), const ndim=1\n</code></pre> <p>Note</p> <p>Note that the values of <code>A</code> and <code>alphas</code> are set to zero by default as there is no proper way to extract their values from LHAPDF.</p>"},{"location":"cli-tutorials/#updating-grid-metadata","title":"Updating Grid Metadata","text":"<p>The metadata of a given <code>NeoPDF</code> grid can be updated by running the following command:</p> <pre><code>neopdf write metadata --path NNPDF40_nnlo_as_01180.neopdf.lz4 --key SetType --value TimeLike\n</code></pre> <ul> <li><code>--path</code>: Path to the <code>NeoPDF</code> set.</li> <li><code>--key</code>: The key value of the metadata to be updated, see the <code>rename</code> field of the   MetaData   struct for the available keys.</li> <li><code>--value</code>: The updated value of the metadata.</li> </ul>"},{"location":"cli-tutorials/#computing-interpolated-values","title":"Computing Interpolated Values","text":""},{"location":"cli-tutorials/#compute-interpolated-pdf-values-xfx-q2","title":"Compute interpolated PDF values \\(xf(x, Q^2)\\)","text":"<p>To compute the interpolated function \\(xf(x, Q^2)\\) for a given PDF set, member, and flavor:</p> <pre><code>neopdf compute xfx_q2 NNPDF40_nnlo_as_01180 --member=0 --pid=21 1e-3 10.0\n</code></pre> <ul> <li><code>--pdf-name</code>: Name of the PDF set (can be a <code>NeoPDF</code> or <code>LHAPDF</code> set).</li> <li><code>--member</code>: The member index (0-based).</li> <li><code>--pid</code>: The PDG ID of the parton flavor (e.g., 21 for gluon).</li> <li>If the PDF set doesn't have the \\(\\alpha_s\\) and \\(A\\) dependence, then the last two arguments   are simply the \\(x\\) and \\(Q^2\\) values at which to evaluate the PDF.</li> </ul> <p>More about the last argument</p> <p>In the case where the PDF set contains an \\(\\alpha_s\\) and/or \\(A\\) dependence, the the argument should be either \\((A, x, Q^2)\\), \\((\\alpha_s, x, Q^2)\\), \\((k_T, x, Q^2)\\), \\((A, \\alpha_s, x, Q^2)\\), \\((A, k_T, x, Q^2)\\), \\((\\alpha_s, k_T, x, Q^2)\\), or \\((A, \\alpha_s, k_T, x, Q^2)\\) depending on what the grid contains. See the section below for an example where the grid contains an \\(A\\)-dependence.</p>"},{"location":"cli-tutorials/#compute-strong-coupling-alpha_s-at-a-given-q2","title":"Compute strong coupling \\(\\alpha_s\\) at a given \\(Q^2\\)","text":"<p>To compute the strong coupling constant \\(\\alpha_s(Q^2)\\) for a given PDF set and member:</p> <pre><code>neopdf compute alphas_q2 NNPDF40_nnlo_as_01180 --member=0 --q2=10\n</code></pre> <ul> <li><code>--q2</code>: The \\(Q^2\\) value at which to evaluate \\(\\alpha_s\\).</li> </ul>"},{"location":"cli-tutorials/#converting-lhapdf-sets-into-neopdf-format","title":"Converting LHAPDF Sets into NeoPDF Format","text":""},{"location":"cli-tutorials/#convert-standard-lhapdf-to-neopdf-format","title":"Convert standard LHAPDF to NeoPDF format","text":"<p>To convert a standard LHAPDF set into the new, compressed <code>NeoPDF</code> format:</p> <pre><code>neopdf write convert NNPDF40_nnlo_as_01180 --output NNPDF40_nnlo_as_01180.neopdf.lz4\n</code></pre> <ul> <li><code>--output</code>: The output file name for the <code>NeoPDF</code> grid (should end with <code>.neopdf.lz4</code>).</li> </ul>"},{"location":"cli-tutorials/#combine-multiple-lhapdf-nuclear-pdfs","title":"Combine multiple LHAPDF Nuclear PDFs","text":"<p>To combine several LHAPDF nuclear PDF sets into a single <code>NeoPDF</code> grid:</p> <pre><code>neopdf write combine-npdfs --pdf-names nNNPDF30_nlo_as_0118_p nNNPDF30_nlo_as_0118_A12 nNNPDF30_nlo_as_0118_A40 --output nNNPDF30_nlo_as_0118.neopdf.lz4\n</code></pre> <ul> <li><code>--pdf-names</code>: List of PDF set names to combine.</li> <li><code>--output</code>: Output file for the combined grid.</li> </ul> <p>Alternatively, one can pass the names of the PDFs via an input file where each line contains a PDF name. Taking the example of nuclear PDFs above but using all the \\(A\\) sets available,</p> nuclearpdfs.txt<pre><code>nNNPDF30_nlo_as_0118_p\nnNNPDF30_nlo_as_0118_A2_Z1\nnNNPDF30_nlo_as_0118_A4_Z2\nnNNPDF30_nlo_as_0118_A6_Z3\nnNNPDF30_nlo_as_0118_A9_Z4\nnNNPDF30_nlo_as_0118_A12_Z6\nnNNPDF30_nlo_as_0118_A14_Z7\nnNNPDF30_nlo_as_0118_A16_Z8\nnNNPDF30_nlo_as_0118_A27_Z13\nnNNPDF30_nlo_as_0118_A31_Z15\nnNNPDF30_nlo_as_0118_A40_Z20\nnNNPDF30_nlo_as_0118_A56_Z26\nnNNPDF30_nlo_as_0118_A64_Z29\nnNNPDF30_nlo_as_0118_A108_Z54\nnNNPDF30_nlo_as_0118_A119_Z59\nnNNPDF30_nlo_as_0118_A131_Z54\nnNNPDF30_nlo_as_0118_A184_Z74\nnNNPDF30_nlo_as_0118_A197_Z79\nnNNPDF30_nlo_as_0118_A208_Z82\n</code></pre> <p>the command now becomes:</p> <pre><code>neopdf write combine-npdfs --names-file nuclearpdfs.txt --output nNNPDF30_nlo_as_0118.neopdf.lz4\n</code></pre> <p>This will generate a <code>nNNPDF30_nlo_as_0118.neopdf.lz4</code> PDF grid that also contains the \\(A\\) dependence. One can now check the value of \\(xf(A, x, Q^2)\\) for the Iron \\(^{56}_{26}\\mathrm{Fe}\\):</p> <pre><code>neopdf compute xfx_q2 nNNPDF30_nlo_as_0118.neopdf.lz4 --member=0 --pid=21 56 1e-3 10.0\n</code></pre>"},{"location":"cli-tutorials/#combine-multiple-alpha_s-lhapdf-sets","title":"Combine multiple  \\(\\alpha_s\\) LHAPDF sets","text":"<p>To combine multiple \\(\\alpha_s\\) LHAPDF sets into a single NeoPDF grid with an explicit dependence on \\(\\alpha_s\\), the procedure is the same as when combining multiple nuclear PDFs with the option <code>combine-npdfs</code> replaced with <code>combine-alphas</code>. That is, given an input file with the names of the PDF sets:</p> alphaspdfs.txt<pre><code>NNPDF40_nnlo_as_01160\nNNPDF40_nnlo_as_01170\nNNPDF40_nnlo_as_01175\nNNPDF40_nnlo_as_01185\nNNPDF40_nnlo_as_01190\n</code></pre> <p>The command to run is:</p> <pre><code>neopdf write combine-alphas --names-file alphaspdfs.txt --output NNPDF40_nnlo.neopdf.lz4\n</code></pre> <p>Note that the names of the PDF sets can be passed via the command line using the option <code>--pdf--name</code>. We can then interpolate the \\(\\alpha_s = 0.1180\\) value:</p> <pre><code>neopdf compute xfx_q2 NNPDF40_nnlo.neopdf.lz4 --member=0 --pid=21 0.1180 1e-3 10.0\n</code></pre> <p>Warning</p> <p>Given that LHAPDF doesn't provide specific attributes to extract the values of \\(A\\) and \\(\\alpha_s\\), their values are inferred from the set name. The extraction of these values are therefore set dependent and we try to support as many sets as possible while keeping the implementation modular. The current extraction of these values rely on the following regex:</p> <pre><code>// Regexes to extract A from the PDF set name\nlet re_nnpdf = Regex::new(r\"_A(\\d+)\").unwrap();\nlet re_ncteq = Regex::new(r\"_(\\d+)_(\\d+)$\").unwrap();\nlet re_epps = Regex::new(r\"[a-zA-Z]+(\\d+)$\").unwrap();\n\n// Regexes to extract alpha_s from the PDF set name\nlet re_nnpdf_ct = Regex::new(r\"_as_(\\d+)_?\").unwrap();\nlet re_msht = Regex::new(r\"_as(\\d+)\").unwrap();\n</code></pre> <p>This approach is not fullproof and some PDF sets might not be supported at all.</p>"},{"location":"cli-tutorials/#inspecting-subgrid-contents","title":"Inspecting subgrid contents","text":"<p>The contents of the subgrids can be printed into human-readable format. Given that a set might contain multiple subgrids (as we have seen before using the <code>subgrid-info</code> command), it is instructive to check first how many subgrids a given set member contains.</p> <pre><code>&gt; neopdf read num_subgrids NNPDF40_nnlo_as_01180.neopdf.lz4\n\n2\n</code></pre> <p>We can look at the contents of the first subgrid for the gluon PDF:</p> <pre><code>&gt; neopdf read subgrid NNPDF40_nnlo_as_01180.neopdf.lz4 --member=0 --subgrid-index=0 --pid=21\n\n  [x | Q2]   2.72250e0   3.19494e0   3.77488e0   4.49175e0   5.38430e0   6.50400e0   7.91974e0\n1.00000e-9  1.48441e-1  -1.47266e0  -3.42816e0  -5.57841e0  -7.73893e0  -9.65268e0  -1.10375e1\n1.29708e-9  1.53954e-1  -1.36579e0  -3.16487e0  -5.10066e0  -6.98714e0  -8.57386e0  -9.57904e0\n1.68243e-9  1.59670e-1  -1.26122e0  -2.90961e0  -4.64076e0  -6.26809e0  -7.54804e0  -8.20073e0\n2.18225e-9  1.65601e-1  -1.15891e0  -2.66220e0  -4.19823e0  -5.58080e0  -6.57342e0  -6.89951e0\n2.83057e-9  1.71754e-1  -1.05882e0  -2.42248e0  -3.77263e0  -4.92430e0  -5.64825e0  -5.67242e0\n3.67149e-9  1.78142e-1 -9.60911e-1  -2.19028e0  -3.36352e0  -4.29764e0  -4.77083e0  -4.51658e0\n...\n  [x | Q2]   9.72449e0   1.20449e1   1.50550e1   1.89961e1   2.42064e1\n1.00000e-9  -1.15252e1  -1.06011e1  -7.88260e0  -2.66303e0   5.44604e0\n1.29708e-9  -9.64489e0  -8.29955e0  -5.12278e0  5.21491e-1   8.89615e0\n1.68243e-9  -7.87939e0  -6.15103e0  -2.56742e0   3.44402e0   1.20386e1\n2.18225e-9  -6.22381e0  -4.14868e0 -2.06304e-1   6.11881e0   1.48905e1\n2.83057e-9  -4.67345e0  -2.28589e0   1.97036e0   8.55949e0   1.74680e1\n...\n</code></pre>"},{"location":"custom-interpolation/","title":"Custom Interpolation Strategies","text":"<p><code>neopdf</code> is built on a modular architecture that allows users to define and use their own custom interpolation strategies. This is an advanced feature for users who need to implement specialized interpolation algorithms beyond the ones provided by default. Currently, the following interpolation strategies are implemented:</p> <ul> <li><code>Bilinear</code>: a Bilinear interpolation strategy for 2D data.</li> <li><code>LogBilinear</code>: a Bilinear interpolation strategy for 2D data with logarithmic scaling of the   coordinates.</li> <li><code>LogBicubic</code>: a Bicubic Hermite Spline interpolation strategy for 2D data with logarithmic   scaling of the coordinates.</li> <li><code>LogTriicubic</code>: a Tricubic Hermite Spline interpolation strategy for 3D data with logarithmic   scaling of the coordinates.</li> <li><code>LogChebyshev</code>: a Chebyshev interpolation strategy for 1D, 2D, and 3D data with logarithmic   scaling of the coordinates.</li> <li><code>InterpNDLinear</code>: a Linear interpolation strategy for an arbitrary N-dimensional data.</li> </ul> <p>This guide will walk you through the process of creating and using a custom 1D interpolation strategy. The same principles apply to 2D and 3D strategies.</p>"},{"location":"custom-interpolation/#core-concept-the-strategy-traits","title":"Core Concept: The <code>Strategy</code> Traits","text":"<p>The interpolation logic in <code>neopdf</code> is powered by the <code>ninterp</code> crate. To create a custom interpolator, you must define a struct that implements one of the core <code>Strategy</code> traits from <code>ninterp</code>:</p> <ul> <li><code>Strategy1D</code>: For 1-dimensional interpolation.</li> <li><code>Strategy2D</code>: For 2-dimensional interpolation.</li> <li><code>Strategy3D</code>: For 3-dimensional interpolation.</li> </ul> <p>These traits require you to implement a few methods, the most important of which is <code>interpolate</code>.</p>"},{"location":"custom-interpolation/#required-methods","title":"Required Methods","text":"<p>For any <code>Strategy</code> trait, one must implement the following methods:</p> <ul> <li><code>interpolate(&amp;self, data, point)</code>: This is where the core interpolation logic goes. It takes   the grid data and a point to evaluate and should return the interpolated value.</li> <li><code>allow_extrapolate(&amp;self) -&gt; bool</code>: This method should return <code>true</code> if the strategy supports   extrapolation outside the grid boundaries, and <code>false</code> otherwise.</li> </ul> <p>One can also optionally implement an <code>init</code> method:</p> <ul> <li><code>init(&amp;mut self, data)</code>: This method is called once when the interpolator is created. It's   useful for performing validation on the grid data or pre-computing values (like coefficients)   to speed up the <code>interpolate</code> calls.</li> </ul>"},{"location":"custom-interpolation/#step-by-step-guide-to-a-custom-1d-strategy","title":"Step-by-Step Guide to a Custom 1D Strategy","text":"<p>Let's create a simple <code>NearestNeighbor</code> interpolation strategy as an example. This strategy will find the grid point closest to the requested point and return its value.</p>"},{"location":"custom-interpolation/#step-1-define-the-strategy-struct","title":"Step 1: Define the Strategy Struct","text":"<p>First, let's define an empty struct for the interpolation strategy. It can contain fields for configuration if needed.</p> <pre><code>use ninterp::data::InterpData1D;\nuse ninterp::error::{InterpolateError, ValidateError};\nuse ninterp::strategy::traits::Strategy1D;\nuse ndarray::Data;\n\n/// A custom strategy that returns the value of the nearest grid point.\n#[derive(Debug, Clone)]\npub struct NearestNeighbor;\n</code></pre>"},{"location":"custom-interpolation/#step-2-implement-the-strategy1d-trait","title":"Step 2: Implement the <code>Strategy1D</code> Trait","text":"<p>Now, let's implement the <code>Strategy1D</code> trait for the <code>NearestNeighbor</code> struct.</p> <pre><code>impl&lt;D&gt; Strategy1D&lt;D&gt; for NearestNeighbor\nwhere\n    D: Data&lt;Elem = f64&gt;,\n{\n    /// Finds the closest grid point and returns its value.\n    fn interpolate(\n        &amp;self,\n        data: &amp;InterpData1D&lt;D&gt;,\n        point: &amp;[f64; 1],\n    ) -&gt; Result&lt;f64, InterpolateError&gt; {\n        let x = point[0];\n        let x_coords = data.grid[0].as_slice().unwrap();\n        let values = data.values.as_slice().unwrap();\n\n        let mut closest_idx = 0;\n        let mut min_dist = f64::MAX;\n\n        for (i, &amp;grid_x) in x_coords.iter().enumerate() {\n            let dist = (x - grid_x).abs();\n            if dist &lt; min_dist {\n                min_dist = dist;\n                closest_idx = i;\n            }\n        }\n\n        Ok(values[closest_idx])\n    }\n\n    /// This simple strategy does not support extrapolation.\n    fn allow_extrapolate(&amp;self) -&gt; bool {\n        false\n    }\n}\n</code></pre>"},{"location":"custom-interpolation/#step-3-use-the-custom-strategy","title":"Step 3: Use the Custom Strategy","text":"<p>Once the strategy is defined, we can use it with the <code>ninterp</code> <code>Interpolator</code> to create a functioning interpolator object. <code>neopdf</code> is built on top of this, so the integration is seamless.</p> <pre><code>use ninterp::interpolator::Interpolator;\nuse ninterp::data::InterpData1D;\nuse ndarray::Array1;\n\nfn main() {\n    // 1. Create your custom strategy instance.\n    let strategy = NearestNeighbor;\n\n    // 2. Create your grid data.\n    let x_coords = Array1::from(vec![1.0, 2.0, 3.0, 4.0]);\n    let y_values = Array1::from(vec![10.0, 20.0, 30.0, 40.0]);\n    let data = InterpData1D::new(x_coords, y_values).unwrap();\n\n    // 3. Build the interpolator with your custom strategy.\n    let interpolator = Interpolator::new(data, strategy);\n\n    // 4. Interpolate a point.\n    let point = [2.6];\n    let result = interpolator.interpolate(&amp;point).unwrap();\n\n    println!(\"Interpolated value at {} is: {}\", point[0], result);\n    assert_eq!(result, 30.0);\n\n    let point = [2.4];\n    let result = interpolator.interpolate(&amp;point).unwrap();\n    println!(\"Interpolated value at {} is: {}\", point[0], result);\n    assert_eq!(result, 20.0);\n}\n</code></pre> <p>This example demonstrates how the modular design allows users to inject any compatible strategy into the interpolation framework. While this example uses <code>ninterp</code> directly, the same <code>Strategy</code> objects can be integrated into the higher-level <code>neopdf</code> structures. See the <code>neopdf::gripdf.rs</code> module for more details.</p>"},{"location":"design-and-features/","title":"Features","text":"<p><code>NeoPDF</code> is designed to be a modern, extensible, and high-performance library for PDF/TMD interpolation. This page details the physics and technical features, design rationale, and future plans.</p>"},{"location":"design-and-features/#summary-of-the-current-supported-features","title":"Summary of the Current Supported Features","text":"Feature Status Notes APIs &amp; FFIs Rust API \u2705 Fully supported Python API \u2705 Fully supported C/C++ API \u2705 Fully supported Fortran API \u2705 Fully supported Features Multi-flavor grids \u274c Planned Nuclear PDFs interpolation \u2705 Fully supported Strong Coupling interpolation \u2705 Fully supported Momentum kT interpolation \u2705 Fully supported Different Hadronic states \u2705 Fully supported Custom interpolation \u2705 Supported (user-defined strategies) Analytical DGLAP interpolation \u274c Planned"},{"location":"design-and-features/#physics-features","title":"Physics Features","text":""},{"location":"design-and-features/#hadron-types-and-pdf-classification","title":"Hadron Types and PDF Classification","text":"<p>Multiple types of Convolutions</p> <p>PDF interpolations are mainly used to convolve with partonic cross-sections in order to get theoretical predictions. For various technical reasons, these theory predictions are stored in some fast interpolating grids. Mondern interpolating libraries such as PineAPPL supports grids with arbitrarily many convolutions. For instance, it support processes such as:</p> <pre><code>Proton + Proton -&gt; \u03c0 + \u03c0 + X\n</code></pre> <p>An interpolation grid of this kind needs two different convolution functions: a (polarised) PDF for the protons and a fragmentation function for the pions. When users convolve this grid with the two functions, they must either pass the functions in the right order to avoid calculating wrong predictions (see this issue for more details). <code>NeoPDF</code> circumvents this issue by adding the following keys to the metadata:</p> <pre><code>Particle: 2212/212/... # Hadron PID\nPolarized: true/false\nSetType: SpaceLike/TimeLike\n</code></pre> <p><code>NeoPDF</code> provides comprehensive support for different types of hadronic structure functions and most importantly distinguish between them, which is essential for precision QCD calculations.</p> <ul> <li> <p>Collinear vs. Transverse Momentum Dependent Distributions:</p> <ul> <li>Collinear Parton Distribution Functions (PDFs) describe the probability of finding a parton   (quark or gluon) carrying a fraction \\(x\\) of the longitudinal momentum of the parent hadron at a   given scale \\(Q^2\\). These are functions of \\((x, Q^2)\\) and are the standard objects used in collinear   factorization for high-energy processes.</li> <li>Transverse Momentum Dependent Distributions (TMDs), or TMD PDFs, generalize the concept of PDFs by   including the dependence on the parton's intrinsic transverse momentum \\(k_T\\). TMDs are functions of   \\((x, k_T, Q^2)\\) and are essential for describing processes sensitive to the transverse structure of   hadrons, such as low-\\(p_T\\) Drell-Yan, semi-inclusive deep inelastic scattering (SIDIS), and certain   jet observables.</li> <li><code>NeoPDF</code> natively supports both collinear PDFs and TMDs, allowing users to interpolate and evaluate   distributions with or without \\(k_T\\) dependence. The library automatically distinguishes between these   types based on the grid metadata, ensuring correct usage in phenomenological applications.</li> </ul> </li> <li> <p>Parton vs Nuclear PDFs (Or TMDs, respectively):</p> <ul> <li>Parton PDFs describe the momentum distribution of quarks and gluons within protons and   neutrons, fundamental for understanding the internal structure of hadrons. These are crucial   for Standard Model predictions at hadron colliders like the LHC.</li> <li>Nuclear PDFs extend this framework to describe parton distributions within nuclei, accounting   for nuclear binding effects, shadowing, and anti-shadowing. These are essential for heavy-ion   collisions and understanding nuclear structure effects in high-energy physics experiments.</li> </ul> </li> <li> <p>Polarized vs Unpolarized PDFs (Or TMDs, respectively):</p> <ul> <li>Unpolarized PDFs represent the standard momentum distributions and are used in most collider   physics calculations.</li> <li>Polarized PDFs describe the spin-dependent parton distributions, crucial for understanding the   proton's spin structure and for experiments with polarized beams. These are essential for the RHIC   spin program and future electron-ion colliders (EIC).</li> </ul> <p>The difference between polarized and unpolarized PDFs provides direct insight into the proton's spin decomposition and tests of QCD in the spin sector.</p> </li> <li> <p>Timelike vs Spacelike PDFs (Or TMDs, respectively):</p> <ul> <li>Spacelike PDFs (the standard case) describe parton distributions in deep-inelastic scattering   and hadron-hadron collisions.</li> <li>Timelike PDFs (Fragmentation Functions) describe the hadronization of partons into hadrons,   essential for understanding jet structure and hadron production in \\(e^+e^-\\) collisions and hadron-hadron   collisions.</li> </ul> <p>This distinction is crucial for precision phenomenology, as the evolution equations and factorization theorems differ between the two cases.</p> </li> </ul>"},{"location":"design-and-features/#multi-parameter-interpolations","title":"Multi-Parameter Interpolations","text":"<p><code>NeoPDF</code> supports interpolation across multiple physical parameters:</p> <ul> <li> <p>\\(\\alpha_s(M_Z)\\) Dependence:   The strong coupling constant \\(\\alpha_s(M_Z)\\) is a fundamental parameter of QCD that affects PDF   evolution and cross-section predictions. Different PDF sets use different values (typically   ranging from 0.116 to 0.120), and interpolating between them allows for:</p> <ul> <li>Uncertainty quantification in \\(\\alpha_s\\) determination</li> <li>Consistent treatment of \\(\\alpha_s\\) variations in global fits</li> <li>Testing the sensitivity of observables to the strong coupling constant</li> </ul> </li> <li> <p>Nuclear Dependence \\((A, Z)\\):   Nuclear PDFs depend on the atomic mass number \\(A\\) and atomic number \\(Z\\) of the target nucleus.   Interpolating in \\((A, Z)\\) space enables:</p> <ul> <li>Predictions for nuclei not included in existing sets</li> <li>Systematic studies of nuclear effects across the periodic table</li> <li>Applications to heavy-ion physics and neutrino-nucleus scattering</li> </ul> </li> <li> <p>Transverse Momentum Dependence \\(k_T\\):   <code>NeoPDF</code> provides full support for interpolation in the transverse momentum \\(k_T\\) variable, enabling   access to TMD PDFs and related distributions. Users can:</p> <ul> <li>Interpolate TMD grids as functions of \\((x, k_T, Q^2)\\), supporting both regular and logarithmic   \\(k_T\\) binning.</li> <li>Seamlessly switch between collinear and TMD modes depending on the grid type, with automatic   handling of \\(k_T\\) integration or projection as needed.</li> <li>Study \\(k_T\\)-dependent observables and perform phenomenological analyses that require access to   the full transverse momentum structure of the parton distributions.</li> </ul> </li> </ul> <p>This feature is crucial for modern QCD analyses, including TMD factorization, resummation, and the   study of nonperturbative effects in hadron structure.</p>"},{"location":"design-and-features/#multi-flavor-grids-planned","title":"Multi-Flavor Grids (Planned)","text":"<p><code>NeoPDF</code> will support grids with varying numbers of active flavors \\(n_f\\), providing a consistent treatment of heavy quark effects across all scales. Advanced schemes like FONLL and ACOT require careful handling of flavor thresholds and mass effects. <code>NeoPDF</code>'s multi-flavor support will enable:</p> <ul> <li>Precision predictions for heavy flavor production</li> <li>Proper matching across flavor thresholds</li> <li>Consistent treatment of charm and bottom quark effects</li> </ul>"},{"location":"design-and-features/#analytical-interpolation-planned","title":"Analytical Interpolation (Planned)","text":"<p>Future versions will support DGLAP-based analytical interpolation. Such an analytical-based interpolation will provide:</p> <ul> <li>Consistent treatment of scale evolution</li> <li>Reduced interpolation artifacts</li> <li>More accurate extrapolation beyond the grid boundaries</li> </ul>"},{"location":"design-and-features/#technical-features","title":"Technical Features","text":""},{"location":"design-and-features/#language-interoperability","title":"Language Interoperability","text":"<p><code>NeoPDF</code> provides native APIs across multiple programming languages, enabling seamless integration into diverse computational workflows:</p> <ul> <li> <p>Native Rust API:   The core library is written in Rust, providing zero-cost abstractions, memory safety, and high   performance. Rust's ownership system ensures thread safety and prevents common programming errors   that could lead to incorrect physics results.</p> </li> <li> <p>Python Bindings:   Comprehensive Python interface using PyO3, enabling integration with the rich ecosystem of   scientific Python libraries (NumPy, SciPy, Matplotlib, etc.). This is crucial for data analysis,   visualization, and integration with existing physics analysis frameworks.</p> </li> <li> <p>C/C++ Bindings:   Direct C and C++ interfaces for integration with legacy codes and high-performance computing   applications. The C API provides a stable ABI for long-term compatibility, while the C++ API   offers object-oriented convenience.</p> </li> </ul>"},{"location":"design-and-features/#no-code-migration","title":"No-Code Migration","text":"<p><code>NeoPDF</code> maintains API compatibility with LHAPDF, enabling seamless migration:</p> <ul> <li> <p>Drop-in Replacement:   Existing LHAPDF code can often be migrated by simply changing import statements, with no   modifications to the core physics logic required.</p> </li> <li> <p>Preserved Function Signatures:   Key functions like <code>xfxQ2()</code>, <code>alphasQ2()</code>, and <code>mkPDF()</code> maintain the same signatures as   LHAPDF, ensuring compatibility with existing analysis codes.</p> </li> </ul> <p>This compatibility is crucial for the physics community, as it allows for immediate adoption without requiring extensive code rewrites or validation efforts.</p>"},{"location":"design-and-features/#extensible-interpolation","title":"Extensible Interpolation","text":"<p><code>NeoPDF</code>'s modular architecture enables easy extension and customization:</p> <ul> <li> <p>Pluggable Interpolation Strategies:   The library supports multiple interpolation algorithms (bilinear, bicubic, tricubic, N-dimensional)   and can be extended with custom interpolation schemes.</p> </li> <li> <p>Custom Grid Types:   The framework can accommodate new grid formats and data structures, enabling support for emerging   PDF sets and specialized applications.</p> </li> <li> <p>Performance Tuning:   Different interpolation strategies can be selected based on the specific requirements of accuracy   vs. speed, allowing optimization for different use cases.</p> </li> </ul>"},{"location":"design-and-features/#performance-optimization","title":"Performance Optimization","text":"<p><code>NeoPDF</code> is designed for high-performance computing environments:</p> <ul> <li> <p>Zero-Cost Abstractions:   Rust's compilation model ensures that high-level abstractions don't incur runtime overhead, providing   both safety and performance.</p> </li> <li> <p>Cache-Friendly Design:   Data structures are optimized for modern CPU cache hierarchies, reducing memory access latency and   improving performance for large-scale calculations.</p> </li> <li> <p>SIMD Optimization:   The library can leverage CPU vector instructions for parallel evaluation of multiple points, crucial   for Monte Carlo event generation and large-scale simulations.</p> </li> <li> <p>Benchmarking:   Comprehensive benchmarking against LHAPDF ensures that performance improvements don't come at the   cost of accuracy, maintaining the precision required for physics calculations.</p> </li> </ul>"},{"location":"design-and-features/#thread-and-memory-safety","title":"Thread and Memory Safety","text":"<p><code>NeoPDF</code> leverages Rust's safety guarantees for robust multi-threaded applications:</p> <ul> <li> <p>Memory Safety:   Rust's ownership system prevents common memory errors (use-after-free, double-free, data races)   that could lead to incorrect physics results or program crashes.</p> </li> <li> <p>Thread Safety:   Built-in support for safe concurrent access to PDF objects, essential for parallel event   generation and Monte Carlo simulations.</p> </li> <li> <p>FFI Safety:   Careful design of the foreign function interface ensures that safety guarantees extend to Python,   C, and C++ code, preventing crashes and undefined behavior.</p> </li> </ul>"},{"location":"design-and-features/#architecture-overview","title":"Architecture Overview","text":"<pre><code>graph TD;\n    A[User (Rust/Python/C/C++)] --&gt; B[API Layer];\n    B --&gt; C[Core Engine (Rust)];\n    C --&gt; D[Grid Data &amp; Metadata];\n    C --&gt; E[Interpolation Strategies];\n    D --&gt; F[PDF Set Files];\n</code></pre> <ul> <li>API Layer: Exposes a consistent interface in different programming languages.</li> <li>Core Engine: Handles all logics, grid management, and interpolation.</li> <li>Grid Data: Efficiently loads and manages PDF grid data and metadata.</li> <li>Interpolation Strategies: Pluggable, with default (log)-bicubic, bilinear, and (log)-tricubic.   Relies on ninterp for the N-dimensional interpolation.</li> </ul>"},{"location":"design-and-features/#benchmark-against-lhapdf","title":"Benchmark Against LHAPDF","text":"<p><code>NeoPDF</code> implements (log)-bicubic interpolation by default, with optional \\(N\\)-dimensional strategies. Lower-dimensional (bilinear, (log)-tricubic) are also available for performance tuning.</p> <p>Benchmark against LHAPDF</p> <p>The difference between NeoPDF and LHAPDF, using the default interpolation, is below machine precision for floating-point numbers.</p> <p> </p>"},{"location":"design/","title":"Design","text":""},{"location":"design/#pdf-object-construction-multi-dimensional-grid-representation","title":"PDF Object Construction: Multi-dimensional Grid Representation","text":"<p>The core of <code>NeoPDF</code>'s data model is the representation of Parton Distribution Functions (PDFs) and Transverse Momentum Distributions (TMDs) as multi-dimensional arrays. This is implemented via the <code>GridArray</code> and <code>SubGrid</code> structures in the <code>neopdf::gridpdf</code> and <code>neopdf::subgrid</code> modules respectively.</p> <ul> <li>GridArray: Stores the full set of subgrids and flavor IDs. Each subgrid represents a region   of phase space with a consistent grid of variables (\\(A\\), \\(\\alpha_s\\), \\(k_T\\), \\(x\\), \\(Q^2\\)).</li> <li>SubGrid: In the most general case, contains a 6-dimensional array: <code>[nucleons, alphas, pids, kT, x, Q\u00b2]</code>.   For the standard case of proton PDF, for example, <code>SubGrid</code> is a 3-dimensional array of <code>[pids, x, Q\u00b2]</code>   that requires a 2D interpolation. This allows for efficient storage and interpolation across all   relevant physical parameters.</li> <li>Interpolation: The library supports up to 5D interpolation strategies, automatically   selecting the appropriate method based on the grid structure and metadata. Interpolators are   built for each subgrid and flavor, supporting log-space and linear strategies for high accuracy.</li> </ul> <p>Therefore, using the notations from [2112.09703], the full <code>GridArray</code> (for 1D grid), which is a conjunction of \\(k\\) subgrids, can be represented as:</p> \\[ \\left[ z_0, z_1, \\cdots, z_{\\mathrm{max}} \\right]_{\\left( n_1, n_2, \\cdots, n_k \\right)} \\qquad \\text{with} \\qquad z=A, \\alpha_s, k_T, x, Q^2 \\] <p>where the \\(z_i\\) are the subinterval boundaries and \\(n_i = N_i + 1\\) is the number of points for subgrid \\(i\\). Note that adjacent subgrids share their end points so that the total number of grid points is \\(n_{\\mathrm{pts}} = \\sum_i n_i - (k - i)\\).</p> <p>The diagram below schematically summarizes the <code>NeoPDF</code> data structure:</p> <p></p> <p>where the <code>GridArray</code> object represents an instance of a set member. The subgrid \\(S_k\\) is a hyperrectangle given by the Cartesian product of the dependent variables.</p> <p>This design enables:</p> <ul> <li>Efficient access to PDF/TMD values at arbitrary kinematic points for a given member.</li> <li>Support for advanced use cases, such as nuclear PDFs and strong coupling \\(\\alpha_s(M_Z)\\).</li> <li>Modular extension to new interpolation strategies or additional dimensions.</li> </ul>"},{"location":"design/#neopdf-file-format-compression-metadata-and-lazy-loading","title":"NeoPDF File Format: Compression, Metadata, and Lazy Loading","text":"<p>The <code>NeoPDF</code> file format is designed for efficient storage and fast, random access to large collections of grids. For technical reasons (see below), the format is not human-readable. However, <code>NeoPDF</code> provides a CLI tool that allows the user to easily and quickly inspect the contents of a given PDF/TMD set. The implementation of the logics is found in <code>neopdf::writer</code>.</p> <ul> <li>Serialization &amp; Compression: All grid data (<code>GridArray</code>), along with shared metadata, are   serialized using <code>bincode</code> and compressed with LZ4. This results in compact files that are quick   to read and write.</li> <li>Metadata: Metadata is stored at the beginning of the file, allowing extraction without   decompressing the entire file.</li> <li>Offset Table: An offset table is written after the metadata, enabling random access to any   grid member without reading the whole file.</li> <li>Grid Data: Each grid is stored with its size and data, allowing for efficient deserialization.</li> </ul> <p>Such a choice of format allows <code>NeoPDF</code> grids to be efficiently stored on disk, reducing at least by half the size of a given LHAPDF PDF set:</p> PDF Set Nb. Members LHAPDF/TMDlib NeoPDF PDF4LHC21 40 31 MB 16 MB NNPDF4.0 NNLO 100 158 MB 85 MB NNPDF4.0 NNLO 1000 1.55 GB 830 MB Combined nNNPDF3.0 200 - 1.43 GB MAP22 FF @N3LL 250 2.50 GB 950 MB <p>Note</p> <p>The size of the <code>NeoPDF</code> sets could be reduced further (at least by half) by using the Chebyshev grid spacing and interpolation.</p>"},{"location":"design/#access-patterns","title":"Access Patterns","text":"<ul> <li>Eager Loading: The entire collection of grids can be decompressed and loaded into memory for   batch operations.</li> <li>Random Access: The <code>GridArrayReader</code> provides random access to individual grids using the offset   table, without loading all data.</li> <li>Lazy Iteration: The <code>LazyGridArrayIterator</code> enables sequential, memory-efficient iteration over   grid members, suitable for processing very large sets.</li> </ul>"},{"location":"design/#advantages","title":"Advantages","text":"<ul> <li>Performance: LZ4 compression and binary serialization provide fast read/write speeds and small   file sizes.</li> <li>Scalability: Lazy and random access patterns allow working with very large PDF sets without   high memory usage.</li> <li>Extensibility: The format is designed to accommodate future extensions, such as new metadata   fields or additional grid dimensions.</li> </ul>"},{"location":"development-with-pixi/","title":"Development with Pixi","text":"<p>This guide provides comprehensive instructions for developing <code>NeoPDF</code> using Pixi, a modern package management tool that ensures reproducible development environments across different platforms.</p> <p>Why Pixi?</p> <p><code>Pixi</code> provides isolated, reproducible environments with built-in lockfiles, making it perfect for managing complex multi-language projects like <code>NeoPDF</code> that involve Rust, Python, C/C++, and Fortran components.</p>"},{"location":"development-with-pixi/#prerequisites","title":"Prerequisites","text":""},{"location":"development-with-pixi/#installing-pixi","title":"Installing Pixi","text":"<p>First, you need to install <code>Pixi</code>. Depending on your platform, run one of the following commands:</p> <p>Linux &amp; macOS: <pre><code>curl -fsSL https://pixi.sh/install.sh | sh\n</code></pre></p> <p>Windows: <pre><code>powershell -ExecutionPolicy ByPass -c \"irm -useb https://pixi.sh/install.ps1 | iex\"\n</code></pre></p> <p>After the installation, restart your terminal or source your shell configuration.</p>"},{"location":"development-with-pixi/#project-setup","title":"Project Setup","text":""},{"location":"development-with-pixi/#initializing-the-development-environment","title":"Initializing the Development Environment","text":"<ol> <li> <p>Clone the repository and navigate to the project: <pre><code>git clone https://github.com/Radonirinaunimi/neopdf\ncd neopdf\n</code></pre>    This directory contains the <code>pixi.toml</code> configuration file which contains the list of    dependencies and tasks. For more details on how to configure the <code>pixi.toml</code> file, head    over to the documentation.</p> </li> <li> <p>Verify the environment: <pre><code># Check Rust version\npixi run rustc --version\n\n# Check Python version\npixi run python --version\n\n# Check C compiler\npixi run gcc --version\n</code></pre></p> </li> </ol> <p>Omitting <code>pixi run</code></p> <p>One can omit the <code>pixi run</code> prefix by invoking the <code>pixi</code> shell:</p> <pre><code>pixi shell\n</code></pre> <p>This activates the development environment with all dependencies installed.</p>"},{"location":"development-with-pixi/#core-components","title":"Core Components","text":""},{"location":"development-with-pixi/#rust-library-neopdf","title":"Rust Library (<code>neopdf/</code>)","text":"<p>The core Rust library provides the main interpolation functionality.</p> <p>Building the library: <pre><code># Build in debug mode\npixi run cargo build --manifest-path neopdf/Cargo.toml\n\n# Build in release mode\npixi run cargo build --release --manifest-path neopdf/Cargo.toml\n</code></pre></p> <p>Running tests: <pre><code># Run all Rust tests\npixi run test-rust\n\n# Run specific test file\npixi run cargo test --no-fail-fast --manifest-path neopdf/Cargo.toml --test pdf\n\n# Run with verbose output\npixi run cargo test --no-fail-fast --manifest-path neopdf/Cargo.toml -- --nocapture\n</code></pre></p> <p>Running benchmarks: <pre><code>pixi run cargo bench --manifest-path neopdf/Cargo.toml\n</code></pre></p>"},{"location":"development-with-pixi/#python-api-neopdf_pyapi","title":"Python API (<code>neopdf_pyapi/</code>)","text":"<p>The Python API provides high-level bindings to the Rust library using PyO3. For more examples on using the Python API, see the tutorials.</p> <p>Installing the Python API: <pre><code># Install in development mode\npixi run install-pyapi\n\n# Install with test dependencies\npixi run maturin develop --manifest-path neopdf_pyapi/Cargo.toml --extras test\n</code></pre></p> <p>Running Python tests: <pre><code># Run all Python tests\npixi run test-pyapi\n\n# Run with coverage\npixi run pytest neopdf_pyapi/tests --cov=neopdf_hep\n\n# Run specific test file\npixi run pytest neopdf_pyapi/tests/test_pdfs.py -v\n</code></pre></p>"},{"location":"development-with-pixi/#cc-api-neopdf_capi","title":"C/C++ API (<code>neopdf_capi/</code>)","text":"<p>The C-API provides low-level bindings for C and C++ applications. For more examples on using the C/C++ API, see the corresponding tutorials.</p> <p>Installing the C-API: <pre><code># Install C-API\npixi run install-capi\n\n# Install with custom prefix\npixi run cargo cinstall --manifest-path neopdf_capi/Cargo.toml --prefix=/usr/local\n</code></pre></p> <p>Running C-API tests: <pre><code># Run C-API tests\npixi run test-capi\n\n# Run specific test\npixi run make -C neopdf_capi/tests check-capi\n</code></pre></p>"},{"location":"development-with-pixi/#command-line-interface-neopdf_cli","title":"Command Line Interface (<code>neopdf_cli/</code>)","text":"<p>The CLI provides command-line tools for working with <code>NeoPDF</code> files. For more illustrations on how to use the CLI, head over to the tutorials</p> <p>Installing the CLI: <pre><code># Install CLI\npixi run install-cli\n\n# Install in debug mode\npixi run cargo install --path neopdf_cli --debug\n</code></pre></p> <p>Using the CLI: <pre><code># Show help\npixi run neopdf --help\n\n# List available PDF sets\npixi run neopdf list\n\n# Convert LHAPDF to NeoPDF format\npixi run neopdf write convert NNPDF40_nnlo_as_01180 --output NNPDF40_nnlo_as_01180.neopdf.lz4\n\n# Perform xfxQ2 interpolation\nneopdf compute xfx_q2 --pdf-name NNPDF40_nnlo_as_01180.neopdf.lz4 --member 0 --pid 21 1e-3 10.0\n</code></pre></p>"},{"location":"development-with-pixi/#fortran-api-neopdf_fapi","title":"Fortran API (<code>neopdf_fapi/</code>)","text":"<p>The Fortran API provides bindings for Fortran applications. Fore some examples on how to use the Fortran API, see the tutorials.</p> <p>Building the Fortran module: <pre><code># Compile Fortran module\npixi run gfortran -c neopdf_fapi/neopdf.f90\n\n# Test Fortran API\npixi run make -C neopdf_fapi check-fapi\n</code></pre></p>"},{"location":"development-with-pixi/#development-workflow","title":"Development Workflow","text":""},{"location":"development-with-pixi/#environment-management","title":"Environment Management","text":"<p>Activating the environment: <pre><code># Activate the full development environment\npixi shell\n\n# Activate with specific features\npixi shell --feature pyapi\npixi shell --feature capi\n</code></pre></p> <p>Adding new dependencies: <pre><code># Add Python dependency\npixi add numpy\n\n# Add Rust dependency\npixi add cargo-edit\n\n# Add system dependency\npixi add cmake\n</code></pre></p>"},{"location":"development-with-pixi/#building-and-testing","title":"Building and Testing","text":"<p>Complete build and test workflow: <pre><code># 1. Activate environment\npixi shell\n\n# 2. Build all components\npixi run install-pyapi\npixi run install-capi\npixi run install-cli\n\n# 3. Run all tests\npixi run test-rust\npixi run test-pyapi\npixi run test-capi\n\n# 4. Run benchmarks\npixi run cargo bench --manifest-path neopdf/Cargo.toml\n</code></pre></p> <p>Continuous Integration tasks: <pre><code># Run all tests in CI mode\npixi run cargo test --no-fail-fast --release\n\n# Run with specific target\npixi run cargo test --target x86_64-unknown-linux-gnu\n</code></pre></p>"},{"location":"development-with-pixi/#documentation","title":"Documentation","text":"<p>Building documentation: <pre><code># Serve documentation locally\npixi run docs\n\n# Build static documentation\npixi run mkdocs build\n</code></pre></p> <p>Generating API documentation: <pre><code># Generate Rust documentation\npixi run cargo doc --manifest-path neopdf/Cargo.toml --open\n\n# Generate Python documentation\npixi run maturin build --manifest-path neopdf_pyapi/Cargo.toml --documentation\n</code></pre></p>"},{"location":"development-with-pixi/#advanced-development","title":"Advanced Development","text":""},{"location":"development-with-pixi/#custom-tasks","title":"Custom Tasks","text":"<p>Adding custom tasks to <code>pixi.toml</code>: <pre><code>[tasks]\n# Custom development task\ndev-setup = \"cargo build &amp;&amp; maturin develop &amp;&amp; cargo cinstall\"\n\n# Custom testing task\ntest-all = \"cargo test &amp;&amp; pytest &amp;&amp; make -C neopdf_capi/tests\"\n</code></pre></p> <p>Running custom tasks: <pre><code>pixi run dev-setup\npixi run test-all\n</code></pre></p>"},{"location":"development-with-pixi/#platform-specific-development","title":"Platform-Specific Development","text":"<p>Linux development: <pre><code># Linux-specific tasks\npixi run test-rust  # Uses Linux-specific configuration\n</code></pre></p> <p>Cross-platform development: <pre><code># Build for multiple platforms\npixi run cargo build --target x86_64-unknown-linux-gnu\npixi run cargo build --target x86_64-apple-darwin\n</code></pre></p>"},{"location":"development-with-pixi/#performance-profiling","title":"Performance Profiling","text":"<p>Profiling Rust code: <pre><code># Install profiling tools\npixi add cargo-instruments  # macOS\npixi add cargo-flamegraph   # Linux\n\n# Run with profiling\npixi run cargo flamegraph --manifest-path neopdf/Cargo.toml\n</code></pre></p> <p>Profiling Python code: <pre><code># Install Python profiling tools\npixi add pytest-profiling\n\n# Run with profiling\npixi run pytest neopdf_pyapi/tests --profile\n</code></pre></p>"},{"location":"development-with-pixi/#troubleshooting","title":"Troubleshooting","text":""},{"location":"development-with-pixi/#common-issues","title":"Common Issues","text":"<p>Environment activation problems: <pre><code># Reset environment\npixi clean\n\n# Reinstall dependencies\npixi install\n</code></pre></p> <p>Build failures: <pre><code># Clean all builds\npixi run cargo clean --manifest-path neopdf/Cargo.toml\npixi run cargo clean --manifest-path neopdf_pyapi/Cargo.toml\npixi run cargo clean --manifest-path neopdf_capi/Cargo.toml\n\n# Rebuild from scratch\npixi run install-pyapi\npixi run install-capi\n</code></pre></p> <p>Test failures: <pre><code># Run tests with verbose output\npixi run cargo test --manifest-path neopdf/Cargo.toml -- --nocapture\n\n# Run specific failing test\npixi run cargo test --manifest-path neopdf/Cargo.toml test_name -- --nocapture\n</code></pre></p>"},{"location":"development-with-pixi/#debugging","title":"Debugging","text":"<p>Rust debugging: <pre><code># Run with debug symbols\npixi run cargo build --manifest-path neopdf/Cargo.toml --debug\n\n# Run with logging\npixi run RUST_LOG=debug cargo test --manifest-path neopdf/Cargo.toml\n</code></pre></p> <p>Python debugging: <pre><code># Run with Python debugger\npixi run python -m pdb -m pytest neopdf_pyapi/tests/test_pdfs.py\n\n# Run with verbose output\npixi run pytest neopdf_pyapi/tests -v -s\n</code></pre></p>"},{"location":"development-with-pixi/#deployment","title":"Deployment","text":""},{"location":"development-with-pixi/#building-release-artifacts","title":"Building Release Artifacts","text":"<p>Rust crates: <pre><code># Build for crates.io\npixi run cargo build --release --manifest-path neopdf/Cargo.toml\npixi run cargo package --manifest-path neopdf/Cargo.toml\n</code></pre></p> <p>Python wheels: <pre><code># Build Python wheels\npixi run maturin build --manifest-path neopdf_pyapi/Cargo.toml --release\n\n# Build for specific platforms\npixi run maturin build --manifest-path neopdf_pyapi/Cargo.toml --release --target x86_64-unknown-linux-gnu\n</code></pre></p> <p>C-API libraries: <pre><code># Build C-API for distribution\npixi run cargo cinstall --manifest-path neopdf_capi/Cargo.toml --release --prefix=/usr/local\n</code></pre></p>"},{"location":"development-with-pixi/#publishing","title":"Publishing","text":"<p>Publishing to crates.io: <pre><code># Publish Rust crates\npixi run cargo publish --manifest-path neopdf/Cargo.toml\n</code></pre></p> <p>Publishing to PyPI: <pre><code># Publish Python package\npixi run maturin upload --manifest-path neopdf_pyapi/Cargo.toml target/wheels/*\n</code></pre></p>"},{"location":"installation/","title":"Installation","text":"<p>This guide provides detailed instructions for installing <code>NeoPDF</code> and its APIs for Rust, Python, Fortran, and C/C++, as well as the command line interface (CLI).</p> <p>Development with Pixi</p> <p>For developers who want to contribute to NeoPDF or work with the source code and want a proper environment manager, a <code>pixi.toml</code> configuration is provided to work with the Pixi environment and package manager. See the comprehensive Development with Pixi guide for detailed instructions on setting up a reproducible development environment.</p> <p>Where to store PDF sets?</p> <p>By default, <code>NeoPDF</code> stores PDF sets in <code>${HOME}/.local/share/neopdf</code>, however this can be overwritten via the environment variable <code>NEOPDF_DATA_PATH</code> to point to the LHAPDF path for example.</p> <pre><code>export NEOPDF_DATA_PATH=${LHAPDF_DATA_PATH}\n</code></pre>"},{"location":"installation/#rust-crate","title":"Rust Crate","text":"<p>To use <code>neopdf</code> in your Rust project, simply add the following to your <code>Cargo.toml</code>:</p> <pre><code>[dependencies]\nneopdf = \"0.1.0\" # select the version\n</code></pre> <p>Cargo will automatically fetch and compile the dependencies the next time you build your project with:</p> <pre><code>cargo build\n</code></pre>"},{"location":"installation/#python-api","title":"Python API","text":"<p><code>NeoPDF</code> is available on the Python Packaged Index (PyPI) as <code>neopdf-hep</code> and therefore can be installed easily with any of the Python's package managers. For example, using pipx:</p> <pre><code>pipx install neopdf-hep\n</code></pre> <p>Development Option</p> <p>Alternatively, to build the Python API from source, make sure that maturin is installed, go into the <code>neopdf_pyapi</code> directory, and then simply run:</p> <pre><code>maturin develop --release --extras test\n</code></pre> <p>This will build and install the <code>NeoPDF</code> Python extension in your current environment.</p>"},{"location":"installation/#cc-api","title":"C/C++ API","text":"<p>The simplest way to install the C API and the C++ OOP header is to download the pre-built libraries:</p> <pre><code>curl --proto '=https' --tlsv1.2 -sSf https://raw.githubusercontent.com/Radonirinaunimi/neopdf/refs/heads/master/install-capi.sh | sh\n</code></pre> <p>To pass the installation directory for where to put the files, change the arguments of the shell as follows:</p> <pre><code>.. | sh -s -- --prefix /custom/installation/path\n</code></pre> <p>By default, the script will download the latest stable release. If you would like a specific version, pass the version along with <code>--version</code>:</p> <pre><code>.. | sh -s -- --version 0.2.0-alpha1\n</code></pre> <p>Development Option</p> <p>Alternatively, to build the C-API from source, first install <code>cargo-c</code>:</p> <pre><code>cargo install cargo-c\n</code></pre> <p>Then go into the <code>neopdf_capi</code> directory and run the following command:</p> <pre><code>export CARGO_C_INSTALL_PREFIX=${prefix} # Required for the OOP C++ header\ncargo cinstall --release --prefix=${prefix}\n</code></pre> <p>This will install the library in the <code>${prefix}</code> path. This path can then be added to the <code>PKG_CONFIG_PATH</code> and <code>LD_LIBRARY_PATH</code> environment variables by running:</p> <pre><code>export LD_LIBRARY_PATH=${prefix}/lib:$LD_LIBRARY_PATH\nexport PKG_CONFIG_PATH=${prefix}/lib/pkgconfig:$PKG_CONFIG_PATH\n</code></pre> <p>Remember to source your shell configuration or restart your terminal for the changes to take effect.</p>"},{"location":"installation/#fortran-api","title":"Fortran API","text":"<p>In order to use the Fortran API, you have to install first the C/C++ API. Then, simply copy the <code>neopdf_fapi/neopdf.f90</code> in your working directory and generate the Fortran module:</p> <pre><code>gfortran -c neopdf.f90\n</code></pre> <p>If everything went fine, this will generate a <code>neopdf.mod</code> file. You can now the module in your fortran program by including the following:</p> <pre><code>use neopdf\n</code></pre>"},{"location":"installation/#cli-tool","title":"CLI Tool","text":"<p>The Command Line Interface (CLI) to the <code>NeoPDF</code> APIs is also available on the Python Packaged Index (PyPI) as <code>neopdf-cli</code> and therefore can be installed easily with any of the Python's package managers. For example, using pipx:</p> <pre><code>pipx install neopdf-cli\n</code></pre> <p> Development Option</p> <p>To build and install the NeoPDF command-line interface (CLI) from source, simply run:</p> <pre><code>cargo install --path neopdf_cli\n</code></pre> <p>This will compile the CLI in debug mode and make the <code>neopdf</code> command available in your cargo bin directory (usually <code>~/.cargo/bin</code>). You can then run <code>neopdf --help</code> to see the available commands.</p>"},{"location":"tmdlib/","title":"TMDlib Interface","text":"<p><code>NeoPDF</code> provides an interface to the <code>TMDlib</code> library which allows users for example to interpolate TMD PDFs from the CLI. Most importantly, it is used to convert TMDlib sets into <code>NeoPDF</code> formats.</p>"},{"location":"tmdlib/#installing-the-interface","title":"Installing the interface","text":"<p>To install the <code>TMDlib</code> interface, first clone the repository and run the following command:</p> <pre><code>cargo install --path neopdf_cli --features=tmdlib\n</code></pre> <p>Note that this requires <code>TMDlib</code> and its dependencies to be installed and available in the environment paths.</p>"},{"location":"tmdlib/#interpolating-tmdlib-sets","title":"Interpolating TMDlib sets","text":"<p>To interpolate <code>TMDlib</code> sets from the CLI, the command is similar to the one used for regular sets:</p> <pre><code>neopdf compute xfx_q2_kt --pdf-name MAP22_grids_FF_Km_N3LL --member 0 --pid 2 0.00010000000000000009 1.00000e-1 4.14987e3\n</code></pre> <p>For more details on the required arguments, refer to the helper:</p> <pre><code>&gt; neopdf compute xfx_q2_kt --help                                                                                                                                                                                                                                                                                         \u2500\u256f\n\nEvaluate TMD PDF for a given set, member, and input values\n\nUsage: neopdf compute xfx_q2_kt --pdf-name &lt;PDF_NAME&gt; --member &lt;MEMBER&gt; --pid &lt;PID&gt; &lt;INPUTS&gt;...\n\nArguments:\n  &lt;INPUTS&gt;...  Input values (kt, x, Q2)\n\nOptions:\n  -p, --pdf-name &lt;PDF_NAME&gt;  Name of the TMD PDF set\n  -m, --member &lt;MEMBER&gt;      Member index (0-based)\n  -i, --pid &lt;PID&gt;            PDG flavor ID\n  -h, --help                 Print help\n</code></pre>"},{"location":"tmdlib/#converting-tmdlib-sets-into-neopdf","title":"Converting TMDlib sets into NeoPDF","text":"<p>To convert a <code>TMDlib</code> set into the <code>NeoPDF</code> format, one needs to write a configuration file in the <code>.toml</code> format. This configuration file should contain all the information about the metadata and the grid configurations. The following is an example:</p> <pre><code>set_name = \"MAP22_grids_FF_Km_N3LL\"\nset_desc = \"MAP22 TMDs for K- fragmentation, converted to NeoPDF\"\nset_index = 0\nn_members = 2\n\n# Inner edges for the subgrids. Leave empty for no subgrids.\nx_inner_edges = [0.2]\nq_inner_edges = [] # Q, not Q2\nkt_inner_edges = [1e-2, 1.0]\n\n# Number of points for (subg)grids.\nn_x = [5, 5]\nn_q = [6]\nn_kt = [5, 5, 4]\n\n# Grid axes that are not part of the TMD interpolation\nnucleons = [0.0] # dummy value\nalphas = [0.118] # alpha_s(M_Z)\n\n# Metadata\npids = [-3, -2, -1, 21, 1, 2, 3]\npolarised = false\nset_type = \"TimeLike\"\ninterpolator_type = \"LogChebyshev\" # or LogTricubic\nerror_type = \"replicas\"\nhadron_pid = 321 # Kaon\nalphas_qs = [91.1876] # dummy values\nalphas_vals = [0.118] # dummy values\n\n# Physics Parameters\nflavor_scheme = \"fixed\"\norder_qcd = 2\nalphas_order_qcd = 2\nm_w = 80.352\nm_z = 91.1876\nm_up = 0.0\nm_down = 0.0\nm_strange = 0.0\nm_charm = 1.51\nm_bottom = 4.92\nm_top = 172.5\nalphas_type = \"ipol\"\nnumber_flavors = 4\n</code></pre> <p>We can now convert the <code>MAP22_grids_FF_Km_N3LL</code> set by running the following command: <pre><code>neopdf write convert-tmd --input MAP22_grids_FF_Km_N3LL.toml --output MAP22.neopdf.lz4\n</code></pre></p> <p>Once the conversion has been performed successfully (and the converted <code>NeoPDF</code> set available in the <code>$NEOPDF_DATA_PATH</code>), we can inspect the content of the subgrids to make sure that everything is correct.</p> <pre><code>&gt; neopdf read subgrid --pdf-name MAP22.neopdf.lz4 --member 0 --subgrid-index 0 --pid 2 --kt-index 0                                                                                                                                                                                                                       \u2500\u256f\n\nDisplaying grid for kT = 0.00010000000000000009\n\n  [x | Q2]   1.00000e0   2.40972e0   2.40972e1   4.14987e2   4.14987e3   1.00000e4\n1.00000e-1 -6.70867e-1 -4.80573e-1 -1.53370e-1 -1.26831e-2  1.49324e-2   0.00000e0\n1.10684e-1 -7.26434e-1 -4.81932e-1 -1.40332e-1 -7.62762e-3  1.61799e-2   0.00000e0\n1.41421e-1 -7.37791e-1 -3.84220e-1 -8.14145e-2  8.54183e-3  1.92982e-2   0.00000e0\n1.80695e-1 -5.23889e-1 -1.84548e-1 -1.28827e-2  2.17623e-2  1.98305e-2   0.00000e0\n2.00000e-1 -3.89947e-1 -1.06392e-1  7.02618e-3  2.38316e-2  1.86428e-2   0.00000e0\n</code></pre> <p>We can verify that the contents of the subgrids are correct by checking one of the entries:</p> <pre><code>&gt; neopdf compute xfx_q2_kt --pdf-name MAP22_grids_FF_Km_N3LL --member 0 --pid 2 0.00010000000000000009 1.00000e-1 2.40972e0                                                                                                                                                                                               \u2500\u256f\n\n-0.4805722561384916\n</code></pre>"},{"location":"examples/c-oop/","title":"C++ OOP API Example","text":"<p>This example briefly demonstrates how to use the <code>NeoPDF</code> C++ Object Oriented (OOP) API to load and evaluate parton distributions. More examples can be found in neopdf_capi/tests.</p>"},{"location":"examples/c-oop/#prerequisites","title":"Prerequisites","text":"<p>Build and install the C++ API as described in the installation guide. The C++ OOP header is needed for the following examples.</p>"},{"location":"examples/c-oop/#example-1-loading-and-evaluating-pdfs","title":"Example 1: Loading and Evaluating PDFs","text":"<p>This example demonstrates the use of the <code>NeoPDF</code> C++ OOP API to load both single and multiple PDF members, evaluate parton distributions for a range of \\(x\\) and \\(Q^2\\) values, and compare results to LHAPDF.</p> <p>Technical details:</p> <ul> <li>The <code>NeoPDF</code> and <code>NeoPDFs</code> objects manage their own memory and automatically release resources   when they go out of scope (RAII).</li> <li>The evaluation of \\(x f(x, Q^2)\\) and \\(\\alpha_s(Q^2)\\) is vectorized over the input axes for   efficiency.</li> <li>The code asserts that the results from <code>NeoPDF</code> and LHAPDF agree within a tight tolerance,   providing a robust validation.</li> </ul> <pre><code>#include &lt;LHAPDF/PDF.h&gt;\n#include &lt;LHAPDF/GridPDF.h&gt;\n#include &lt;NeoPDF.hpp&gt;\n#include &lt;cassert&gt;\n#include &lt;cmath&gt;\n#include &lt;iomanip&gt;\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\nusing namespace neopdf;\n\nconst double TOLERANCE= 1e-16;\n\ntemplate&lt;typename T&gt;\nstd::vector&lt;T&gt; geomspace(T start, T stop, int num, bool endpoint = false) {\n    std::vector&lt;T&gt; result(num);\n\n    if (num == 1) {\n        result[0] = start;\n        return result;\n    }\n\n    T log_start = std::log(start);\n    T log_stop = std::log(stop);\n    T step = (log_stop - log_start) / (endpoint ? (num - 1) : num);\n\n    for (int i = 0; i &lt; num; ++i) {\n        result[i] = std::exp(log_start + i * step);\n    }\n\n    return result;\n}\n\ntemplate&lt;typename T&gt;\nstd::vector&lt;T&gt; linspace(T start, T stop, int num, bool endpoint = true) {\n    std::vector&lt;T&gt; result(num);\n\n    if (num == 1) {\n        result[0] = start;\n        return result;\n    }\n\n    T step = (stop - start) / (endpoint ? (num - 1) : num);\n\n    for (int i = 0; i &lt; num; ++i) {\n        result[i] = start + i * step;\n    }\n\n    return result;\n}\n\nvoid test_xfxq2() {\n    std::cout &lt;&lt; \"=== Test xfxQ2 for single PDF member ===\\n\";\n\n    // disable LHAPDF banners to guarantee deterministic output\n    LHAPDF::setVerbosity(0);\n\n    std::string pdfname = \"NNPDF40_nnlo_as_01180\";\n    NeoPDF neo_pdf(pdfname.c_str(), 0);\n    const LHAPDF::PDF* basepdf = LHAPDF::mkPDF(pdfname);\n    const LHAPDF::GridPDF&amp; lha_pdf = * dynamic_cast&lt;const LHAPDF::GridPDF*&gt;(basepdf);\n\n    std::vector&lt;int&gt; pids = {-5, -4, -3, -2, -1, 21, 1, 2, 3, 4, 5};\n    std::vector&lt;double&gt; xs = geomspace(neo_pdf.x_min(), neo_pdf.x_max(), 200);\n    std::vector&lt;double&gt; q2s = geomspace(neo_pdf.q2_min(), neo_pdf.q2_max(), 200);\n\n    // Headers of the table to print the results\n    std::cout &lt;&lt; std::right\n        &lt;&lt; std::setw(6) &lt;&lt; \"pid\"\n        &lt;&lt; std::setw(15) &lt;&lt; \"x\"\n        &lt;&lt; std::setw(15) &lt;&lt; \"Q2\"\n        &lt;&lt; std::setw(15) &lt;&lt; \"LHAPDF\"\n        &lt;&lt; std::setw(15) &lt;&lt; \"NeoPDF\"\n        &lt;&lt; std::setw(15) &lt;&lt; \"Rel. Diff.\" &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; std::string(81, '-') &lt;&lt; \"\\n\";\n\n    for (const auto &amp;pid: pids) {\n        for (const auto &amp;x: xs) {\n            for (const auto &amp;q2: q2s) {\n                double expected = lha_pdf.xfxQ2(pid, x, q2);\n                double result = neo_pdf.xfxQ2(pid, x, q2);\n                double reldif = std::abs(result - expected) / expected;\n\n                assert(std::abs(result - expected) &lt; TOLERANCE);\n\n                // Print the results as a table\n                std::cout &lt;&lt; std::scientific &lt;&lt; std::setprecision(8)\n                    &lt;&lt; std::right\n                    &lt;&lt; std::setw(6)  &lt;&lt; pid\n                    &lt;&lt; std::setw(15) &lt;&lt; x\n                    &lt;&lt; std::setw(15) &lt;&lt; q2\n                    &lt;&lt; std::right\n                    &lt;&lt; std::setw(15) &lt;&lt; expected\n                    &lt;&lt; std::setw(15) &lt;&lt; result\n                    &lt;&lt; std::setw(15) &lt;&lt; reldif &lt;&lt; \"\\n\";\n                }\n            }\n\n    }\n}\n\nvoid test_alphas_q2() {\n    std::cout &lt;&lt; \"=== Test alphasQ2 for single PDF member ===\\n\";\n\n    // disable LHAPDF banners to guarantee deterministic output\n    LHAPDF::setVerbosity(0);\n\n    std::string pdfname = \"NNPDF40_nnlo_as_01180\";\n    NeoPDF neo_pdf(pdfname.c_str(), 0);\n    const LHAPDF::PDF* basepdf = LHAPDF::mkPDF(pdfname);\n    const LHAPDF::GridPDF&amp; lha_pdf = * dynamic_cast&lt;const LHAPDF::GridPDF*&gt;(basepdf);\n\n    std::vector&lt;double&gt; q2_points = linspace(4.0, 1e10, 500);\n\n    // Headers of the table to print the results\n    std::cout &lt;&lt; std::right\n        &lt;&lt; std::setw(15) &lt;&lt; \"Q2\"\n        &lt;&lt; std::setw(15) &lt;&lt; \"LHAPDF\"\n        &lt;&lt; std::setw(15) &lt;&lt; \"NeoPDF\"\n        &lt;&lt; std::setw(15) &lt;&lt; \"Rel. Diff.\" &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; std::string(60, '-') &lt;&lt; \"\\n\";\n\n    for (const auto&amp; q2: q2_points) {\n        double expected = lha_pdf.alphasQ2(q2);\n        double result = neo_pdf.alphasQ2(q2);\n        double reldif = std::abs(result - expected) / expected;\n\n        assert(std::abs(result - expected) &lt; TOLERANCE);\n\n        // Print the results as a table\n        std::cout &lt;&lt; std::scientific &lt;&lt; std::setprecision(8)\n            &lt;&lt; std::right\n            &lt;&lt; std::setw(15) &lt;&lt; q2\n            &lt;&lt; std::right\n            &lt;&lt; std::setw(15) &lt;&lt; expected\n            &lt;&lt; std::setw(15) &lt;&lt; result\n            &lt;&lt; std::setw(15) &lt;&lt; reldif &lt;&lt; \"\\n\";\n    }\n}\n\nvoid test_all_pdf_members() {\n    std::cout &lt;&lt; \"=== Test PDFs class (loading all members) ===\\n\";\n\n    // disable LHAPDF banners to guarantee deterministic output\n    LHAPDF::setVerbosity(0);\n\n    std::string pdfname = \"NNPDF40_nnlo_as_01180\";\n    NeoPDFs neo_pdfs(pdfname.c_str());\n\n    std::cout &lt;&lt; \"Loaded \" &lt;&lt; neo_pdfs.size() &lt;&lt; \" PDF members\\n\";\n\n    // Test case: evaluate a simple point across all members\n    int pid = 1;\n    double x = 1e-9;\n    double q2 = 1.65 * 1.65;\n\n    std::cout &lt;&lt; std::right\n        &lt;&lt; std::setw(8) &lt;&lt; \"Member\"\n        &lt;&lt; std::setw(15) &lt;&lt; \"LHAPDF\"\n        &lt;&lt; std::setw(15) &lt;&lt; \"NeoPDF\"\n        &lt;&lt; std::setw(15) &lt;&lt; \"Rel. Diff.\" &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; std::string(53, '-') &lt;&lt; \"\\n\";\n\n    // Evaluate the same point across all PDF members\n    std::vector&lt;double&gt; results;\n    for (size_t i = 0; i &lt; neo_pdfs.size(); ++i) {\n        const LHAPDF::PDF* basepdf = LHAPDF::mkPDF(pdfname, i);\n        const LHAPDF::GridPDF&amp; lha_pdf = * dynamic_cast&lt;const LHAPDF::GridPDF*&gt;(basepdf);\n\n        double expected = lha_pdf.xfxQ2(pid, x, q2);\n        double result = neo_pdfs[i].xfxQ2(pid, x, q2);\n\n        double reldif = std::abs(result - expected) / expected;\n        assert(std::abs(result - expected) &lt; TOLERANCE);\n        results.push_back(result);\n\n        std::cout &lt;&lt; std::right\n            &lt;&lt; std::setw(8) &lt;&lt; i\n            &lt;&lt; std::scientific &lt;&lt; std::setprecision(8)\n            &lt;&lt; std::setw(15) &lt;&lt; expected\n            &lt;&lt; std::setw(15) &lt;&lt; result\n            &lt;&lt; std::setw(15) &lt;&lt; reldif &lt;&lt; \"\\n\";\n    }\n\n    // Calculate some statistics\n    double sum = 0.0;\n    for (double result : results) {\n        sum += result;\n    }\n    double mean = sum / results.size();\n\n    double variance = 0.0;\n    for (double result : results) {\n        variance += (result - mean) * (result - mean);\n    }\n    variance /= results.size();\n    double std_dev = std::sqrt(variance);\n\n    std::cout &lt;&lt; \"\\nStatistics across all members:\\n\";\n    std::cout &lt;&lt; \"Mean: \" &lt;&lt; std::scientific &lt;&lt; std::setprecision(8) &lt;&lt; mean &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \"Std Dev: \" &lt;&lt; std_dev &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \"Relative Std Dev: \" &lt;&lt; std_dev / mean &lt;&lt; \"\\n\";\n}\n\nvoid test_lazy_loading() {\n    std::cout &lt;&lt; \"=== Test NeoPDFLazy class (lazy loading) ===\\n\";\n\n    // Disable LHAPDF banners to guarantee deterministic output\n    LHAPDF::setVerbosity(0);\n\n    std::string pdfname = \"NNPDF40_nnlo_as_01180.neopdf.lz4\";\n    NeoPDFLazy lazy_pdfs(pdfname);\n\n    std::cout &lt;&lt; \"Initialized lazy loader for \" &lt;&lt; pdfname &lt;&lt; \"\\n\";\n\n    // Test case: evaluate a simple point across all members\n    int pid = 1;\n    double x = 1e-9;\n    double q2 = 1.65 * 1.65;\n\n    std::cout &lt;&lt; std::right\n        &lt;&lt; std::setw(8) &lt;&lt; \"Member\"\n        &lt;&lt; std::setw(15) &lt;&lt; \"LHAPDF\"\n        &lt;&lt; std::setw(15) &lt;&lt; \"NeoPDF\"\n        &lt;&lt; std::setw(15) &lt;&lt; \"Rel. Diff.\" &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; std::string(53, '-') &lt;&lt; \"\\n\";\n\n    // Evaluate the same point across all PDF members\n    std::vector&lt;double&gt; results;\n    int member_idx = 0;\n    while (auto neo_pdf = lazy_pdfs.next()) {\n        const LHAPDF::PDF* basepdf = LHAPDF::mkPDF(\"NNPDF40_nnlo_as_01180\", member_idx);\n        const LHAPDF::GridPDF&amp; lha_pdf = *dynamic_cast&lt;const LHAPDF::GridPDF*&gt;(basepdf);\n\n        double expected = lha_pdf.xfxQ2(pid, x, q2);\n        double result = neo_pdf-&gt;xfxQ2(pid, x, q2);\n\n        double reldif = std::abs(result - expected) / expected;\n        assert(std::abs(result - expected) &lt; TOLERANCE);\n        results.push_back(result);\n\n        std::cout &lt;&lt; std::right\n            &lt;&lt; std::setw(8) &lt;&lt; member_idx\n            &lt;&lt; std::scientific &lt;&lt; std::setprecision(8)\n            &lt;&lt; std::setw(15) &lt;&lt; expected\n            &lt;&lt; std::setw(15) &lt;&lt; result\n            &lt;&lt; std::setw(15) &lt;&lt; reldif &lt;&lt; \"\\n\";\n        member_idx++;\n    }\n\n    std::cout &lt;&lt; \"\\nSuccessfully iterated through all members lazily.\\n\";\n}\n\nint main() {\n    // Test the computation of the PDF interpolations\n    test_xfxq2();\n\n    // Test the computation of the `alphas` interpolations\n    test_alphas_q2();\n\n    // Test the PDF interpolations by loading all the members\n    test_all_pdf_members();\n\n    // Test the lazy loading of PDF members\n    test_lazy_loading();\n\n    return EXIT_SUCCESS;\n}\n</code></pre>"},{"location":"examples/c-oop/#example-2-filling-and-writing-a-neopdf-grid","title":"Example 2: Filling and Writing a NeoPDF Grid","text":"<p>This example illustrates how to fill and write a <code>NeoPDF</code> grid using the C++ OOP API. It demonstrates the process of constructing a grid for each PDF member and serializing the collection to disk.</p> <p>The filling of the PDF grid in the following example assumes no dependence in the nucleon numbers \\(A\\) and strong coupling \\(\\alpha_s\\) (standard LHAPDF-like PDF). Refer to the Section below in the case the grid should explicitly depend on more parameters.</p> <p>Technical details:</p> <ul> <li>The grid axes are defined as vectors for \\(x\\), \\(Q^2\\), parton IDs, nucleons, and \\(\\alpha_s\\)   values.</li> <li>The grid data is stored in a 6D array, with the layout <code>[nucleons][alphas][pids][kT][xs][q2s]</code>.</li> <li>The <code>GridWriter</code> class manages the collection of grids and handles compression and serialization to disk.</li> <li>Metadata is filled in a <code>MetaData</code> object, which includes information about the set, axis ranges, flavors,   and interpolation type. This metadata is essential for correct interpretation of the grid file.</li> <li>All memory management is automatic; no manual deallocation is required.</li> <li>The output file is compressed and written in the <code>.neopdf.lz4</code> format, suitable for use with <code>NeoPDF</code> (CLI)   tools and APIs.</li> </ul> <p>NOTE</p> <p>The following example fills the <code>NeoPDF</code> grid by re-computing the values of the subgrids from another set. This makes it possible to explicitly check that the filling of the grid is correct. However, this makes the codes very verbose. To easily spot the parts that actually fills the grid, some lines are highlighted.</p> <pre><code>#include &lt;NeoPDF.hpp&gt;\n#include &lt;cassert&gt;\n#include &lt;cmath&gt;\n#include &lt;cstdio&gt;\n#include &lt;cstdlib&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace neopdf;\n\nconst double TOLERANCE= 1e-16;\n\nint main() {\n    const char* pdfname = \"NNPDF40_nnlo_as_01180\";\n    // Load all PDF members\n    NeoPDFs neo_pdfs(pdfname);\n    if (neo_pdfs.size() == 0) {\n        std::cerr &lt;&lt; \"Failed to load any PDF members!\\n\";\n        return 1;\n    }\n    std::cout &lt;&lt; \"Loaded \" &lt;&lt; neo_pdfs.size() &lt;&lt; \" PDF members\\n\";\n\n    // Get the first PDF as a reference for metadata\n    NeoPDF&amp; ref_pdf = neo_pdfs[0];\n\n    // Extract the PID values of the PDF set\n    auto pids = ref_pdf.pids();\n\n    // Extract the number of subgrids\n    std::size_t num_subgrids = ref_pdf.num_subgrids();\n\n    // Create a grid writer\n    GridWriter writer;\n\n    // For each member, build a grid\n    for (size_t m = 0; m &lt; neo_pdfs.size(); ++m) {\n        NeoPDF&amp; pdf = neo_pdfs[m];\n\n        // Start a new grid for the current member\n        writer.new_grid();\n\n        // Loop over the Subgrids\n        for (std::size_t subgrid_idx = 0; subgrid_idx != num_subgrids; subgrid_idx++) {\n            // Extract the knot values of the parameters for the subgrid\n            auto xs = pdf.subgrid_for_param(NEOPDF_SUBGRID_PARAMS_MOMENTUM, subgrid_idx);\n            auto q2s = pdf.subgrid_for_param(NEOPDF_SUBGRID_PARAMS_SCALE, subgrid_idx);\n            auto alphas = pdf.subgrid_for_param(NEOPDF_SUBGRID_PARAMS_ALPHAS, subgrid_idx);\n            auto nucleons = pdf.subgrid_for_param(NEOPDF_SUBGRID_PARAMS_NUCLEONS, subgrid_idx);\n            auto kts = pdf.subgrid_for_param(NEOPDF_SUBGRID_PARAMS_KT, subgrid_idx);\n\n            // Compute grid_data: [q2][x][flavor], instead of [nucleon][alphas][kt][q2][x][flavor]\n            // NOTE: This assumes that there is no 'A' and `alphas` dependence.\n            std::vector&lt;double&gt; grid_data;\n            for (double x : xs) {\n                for (double q2 : q2s) {\n                    for (int pid : pids) {\n                        double val = pdf.xfxQ2(pid, x, q2);\n                        grid_data.push_back(val);\n                    }\n                }\n            }\n\n            // Add subgrid\n            writer.add_subgrid(\n                nucleons,\n                alphas,\n                kts,\n                xs,\n                q2s,\n                grid_data\n            );\n        }\n\n        // Finalize the Grid (inc. its subgrids) for this member.\n        writer.push_grid(pids);\n        std::cout &lt;&lt; \"Added grid for member \" &lt;&lt; m &lt;&lt; \"\\n\";\n    }\n\n    // Fill the running of alphas with some random values\n    std::vector&lt;double&gt; alphas_qs = {2.0};\n    std::vector&lt;double&gt; alphas_vals = {0.118};\n\n    // Extract the ranges for the momentum x and scale Q2\n    auto x_range = ref_pdf.param_range(NEOPDF_SUBGRID_PARAMS_MOMENTUM);\n    auto q2_range = ref_pdf.param_range(NEOPDF_SUBGRID_PARAMS_SCALE);\n\n    PhysicsParameters phys_params = {\n        .flavor_scheme = \"variable\",\n        .order_qcd = 2,\n        .alphas_order_qcd = 2,\n        .m_w = 80.352,\n        .m_z = 91.1876,\n        .m_up = 0.0,\n        .m_down = 0.0,\n        .m_strange = 0.0,\n        .m_charm = 1.51,\n        .m_bottom = 4.92,\n        .m_top = 172.5,\n        .alphas_type = \"ipol\",\n        .number_flavors = 4,\n    };\n\n    MetaData meta = {\n        .set_desc = \"NNPDF40_nnlo_as_01180 collection\",\n        .set_index = 0,\n        .num_members = (uint32_t)neo_pdfs.size(),\n        .x_min = x_range[0],\n        .x_max = x_range[1],\n        .q_min = sqrt(q2_range[0]),\n        .q_max = sqrt(q2_range[1]),\n        .flavors = pids,\n        .format = \"neopdf\",\n        .alphas_q_values = alphas_qs,\n        .alphas_vals = alphas_vals,\n        .polarised = false,\n        .set_type = NEOPDF_SET_TYPE_SPACE_LIKE,\n        .interpolator_type = NEOPDF_INTERPOLATOR_TYPE_LOG_BICUBIC,\n        .error_type = \"replicas\",\n        .hadron_pid = 2212,\n        .phys_params = phys_params,\n    };\n\n    // Check if `NEOPDF_DATA_PATH` is defined and store the Grid there.\n    const char* filename = \"check-writer-oop.neopdf.lz4\";\n    const char* neopdf_path = std::getenv(\"NEOPDF_DATA_PATH\");\n    std::string output_path = neopdf_path\n        ? std::string(neopdf_path) + (std::string(neopdf_path).back() == '/' ? \"\" : \"/\") + filename\n        : filename;\n\n    // Write the PDF Grid into disk\n    try {\n        writer.compress(meta, output_path);\n        std::cout &lt;&lt; \"Compression succeeded!\\n\";\n    } catch (const std::runtime_error&amp; err) {\n        std::cerr &lt;&lt; \"Compression failed: \" &lt;&lt; err.what() &lt;&lt; \"\\n\";\n        return EXIT_FAILURE;\n    }\n\n    // If `NEOPDF_DATA_PATH` is defined, reload the grid and check ther results.\n    if (neopdf_path) {\n        int pid_test = 21;\n        double x_test = 1e-3;\n        double q2_test1 = 1e2;\n        double q2_test2 = 1e4;\n\n        double ref1 = neo_pdfs[0].xfxQ2(pid_test, x_test, q2_test1);\n        double ref2 = neo_pdfs[0].xfxQ2(pid_test, x_test, q2_test2);\n\n        NeoPDF wpdf(filename);\n        double res1 = wpdf.xfxQ2(pid_test, x_test, q2_test1);\n        double res2 = wpdf.xfxQ2(pid_test, x_test, q2_test2);\n\n        assert(std::abs(res1 - ref1) &lt; TOLERANCE);\n        assert(std::abs(res2 - ref2) &lt; TOLERANCE);\n    }\n\n    return EXIT_SUCCESS;\n}\n</code></pre> <p>Filling Grids that depend on Multiple Parameters</p> <p>In the case where the PDF grid depends on more parameters, the filling of <code>grid_data</code> in the above example simply now becomes:</p> <pre><code>std::vector&lt;double&gt; grid_data;\nfor (double nucleon : nucleons) {\n    for (double alpha_s : alphas) {\n        for (double x : xs) {\n            for (double q2 : q2s) {\n                for (int pid : pids) {\n                    std::vector&lt;double&gt; params = {nucleon, alpha_s, x, q2};\n                    double val = pdf.xfxQ2_ND(pid, params.data());\n                    grid_data.push_back(val);\n                }\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"examples/c-oop/#example-3-filling-tmd-grids-with-k_t-dependence","title":"Example 3: Filling TMD grids with \\(k_T\\) Dependence","text":"<p>In the following example, we are going to see how to fill TMD grids which contains a dependence on the transverse momentum \\(k_T\\). The following example makes use of the TMDlib library to provide the TMD distributions.</p> <pre><code>#include \"neopdf_capi.h\"\n#include \"tmdlib/TMDlib.h\"\n#include &lt;NeoPDF.hpp&gt;\n#include &lt;algorithm&gt;\n#include &lt;cassert&gt;\n#include &lt;cmath&gt;\n#include &lt;cstddef&gt;\n#include &lt;cstdlib&gt;\n#include &lt;fstream&gt;\n#include &lt;initializer_list&gt;\n#include &lt;string&gt;\n#include &lt;sstream&gt;\n#include &lt;tmdlib/factories.h&gt;\n#include &lt;vector&gt;\n\nusing namespace TMDlib;\nusing namespace neopdf;\n\nconst double TOLERANCE = 1e-16;\n\nstruct Kinematics {\n    std::vector&lt;double&gt; xs;\n    std::vector&lt;double&gt; kts;\n    std::vector&lt;double&gt; qs;\n};\n\nstd::vector&lt;double&gt; compute_tmds(TMD&amp; tmd, double x, double kt, double q2) {\n    double xbar = 0.0;\n    double mu = sqrt(q2);\n    std::vector&lt;double&gt; pdfs = tmd.TMDpdf(x, xbar, kt, mu);\n\n    return pdfs;\n}\n\nstd::vector&lt;double&gt; parse_array(const std::string&amp; line) {\n    std::vector&lt;double&gt; result;\n    size_t start = line.find('[');\n    size_t end = line.find(']');\n\n    if (start == std::string::npos || end == std::string::npos) {\n        return result;\n    }\n\n    double value;\n    std::string content = line.substr(start + 1, end - start - 1);\n    std::replace(content.begin(), content.end(), ',', ' ');\n    std::stringstream ss(content);\n    while (ss &gt;&gt; value) { result.push_back(value); }\n\n    return result;\n}\n\nKinematics read_kinematics() {\n    // Parse the Kinematics separately as it is difficult to retrieve\n    std::ifstream input_kins(\"MAP22_N3LL.kinematics\");\n\n    if (!input_kins.is_open()) {\n        input_kins.open(\"raw.data\");\n        if (!input_kins.is_open()) {\n            return {{}, {}, {}};\n        }\n    }\n\n    std::string line;\n    std::vector&lt;double&gt; xs, kts, qs;\n    while (std::getline(input_kins, line)) {\n        if (line.find(\"qToQg:\") != std::string::npos) { kts = parse_array(line); }\n        else if (line.find(\"Qg:\") != std::string::npos) { qs = parse_array(line); }\n        else if (line.find(\"xg:\") != std::string::npos) { xs = parse_array(line); }\n    }\n    input_kins.close();\n\n    return { xs, kts, qs };\n}\n\nint main() {\n    std::string setname = \"MAP22_grids_FF_Km_N3LL\";\n\n    TMD tmd;\n    tmd.setVerbosity(0);\n\n    // Extract various informations from the TMD\n    tmd.TMDinit(setname);\n    std::size_t n_members = tmd.TMDgetNumMembers();\n    double xmin = tmd.TMDgetXmin();\n    double xmax = tmd.TMDgetXmax();\n    double q2min = tmd.TMDgetQ2min();\n    double q2max = tmd.TMDgetQ2max();\n\n    // Define the kinematics\n    Kinematics kins = read_kinematics();\n    std::vector&lt;double&gt; xs = kins.xs;\n    std::vector&lt;double&gt; qs = kins.qs;\n    std::vector&lt;double&gt; kts = kins.kts;\n\n    // Square the energy scale Q\n    std::vector&lt;double&gt; q2s(qs.size());\n    for (size_t i = 0; i &lt; qs.size(); ++i) { q2s[i] = qs[i] * qs[i]; }\n\n    // Define some physical parameters\n    std::vector&lt;int&gt; pids = {-6, -5, -4, -3, -2, -1, 21, 1, 2, 3, 4, 5, 6};\n    std::vector&lt;double&gt; nucleons = { 1.0 }; // assume to be a Proton\n    std::vector&lt;double&gt; alphas = { 0.118 }; // assume to be determined with as=0.118\n\n    // Instantiate NeoPDF grid writer\n    GridWriter neopdf_writer;\n\n    for (std::size_t m = 0; m != n_members; m++) {\n        tmd.TMDinit(setname, m);\n        std::cout &lt;&lt; \"Member \" &lt;&lt; m &lt;&lt; \" loaded!\" &lt;&lt; \"\\n\";\n\n        // Start a new grid for the current member\n        neopdf_writer.new_grid();\n\n        std::vector&lt;double&gt; grid_data;\n        for (double kt : kts) {\n            for (double x : xs) {\n                for (double q2 : q2s) {\n                    std::vector&lt;double&gt; tmd_pds = tmd.TMDpdf(x, 0.0, kt, sqrt(q2));\n                    for (std::size_t pid_idx = 0; pid_idx != pids.size(); pid_idx++) {\n                        grid_data.push_back(tmd_pds[pid_idx]);\n                    }\n                }\n            }\n        }\n\n        // Add subgrid member to the Grid\n        neopdf_writer.add_subgrid(\n            nucleons,\n            alphas,\n            kts,\n            xs,\n            q2s,\n            grid_data\n        );\n\n        // Finalize the Grid (inc. its subgrids) for this member.\n        neopdf_writer.push_grid(pids);\n    }\n\n    // Fill the running of alphas with some random values\n    std::vector&lt;double&gt; alphas_qs = { 91.1876 };\n    std::vector&lt;double&gt; alphas_vals = { 0.118 };\n\n    // Construct the Metadata\n    PhysicsParameters phys_params = {\n        .flavor_scheme = \"fixed\",\n        .order_qcd = 2,\n        .alphas_order_qcd = 2,\n        .m_w = 80.352,\n        .m_z = 91.1876,\n        .m_up = 0.0,\n        .m_down = 0.0,\n        .m_strange = 0.0,\n        .m_charm = 1.51,\n        .m_bottom = 4.92,\n        .m_top = 172.5,\n        .alphas_type = \"ipol\",\n        .number_flavors = 4,\n    };\n\n    MetaData meta = {\n        .set_desc = \"NNPDF40_nnlo_as_01180 collection\",\n        .set_index = 0,\n        .num_members = (uint32_t)n_members,\n        .x_min = xmin,\n        .x_max = xmax,\n        .q_min = sqrt(q2min),\n        .q_max = sqrt(q2max),\n        .flavors = pids,\n        .format = \"neopdf\",\n        .alphas_q_values = alphas_qs,\n        .alphas_vals = alphas_vals,\n        .polarised = false,\n        .set_type = NEOPDF_SET_TYPE_SPACE_LIKE,\n        .interpolator_type = NEOPDF_INTERPOLATOR_TYPE_LOG_TRICUBIC,\n        .error_type = \"replicas\",\n        .hadron_pid = 2212,\n        .phys_params = phys_params,\n    };\n\n    // Check if `NEOPDF_DATA_PATH` is defined and store the Grid there.\n    const char* filename = \"check-tmds.neopdf.lz4\";\n    const char* neopdf_path = std::getenv(\"NEOPDF_DATA_PATH\");\n    std::string output_path = neopdf_path\n        ? std::string(neopdf_path) + (std::string(neopdf_path).back() == '/' ? \"\" : \"/\") + filename\n        : filename;\n\n    // Write the PDF Grid into disk\n    try {\n        neopdf_writer.compress(meta, output_path);\n        std::cout &lt;&lt; \"Compression succeeded!\\n\";\n    } catch (const std::runtime_error&amp; err) {\n        std::cerr &lt;&lt; \"Compression failed: \" &lt;&lt; err.what() &lt;&lt; \"\\n\";\n        return EXIT_FAILURE;\n    }\n\n\n    // If `NEOPDF_DATA_PATH` is defined, reload the grid and check ther results.\n    if (neopdf_path) {\n        int irep = 12;\n        int pid_test_idx = 2;\n        double x_test = xs[20];\n        double q_test = qs[25];\n\n        // Re-load the NeoPDF and TMDLib TMD sets\n        NeoPDF wpdf(filename, irep);\n        tmd.TMDinit(setname, irep);\n\n        for (double kt : kts) {\n            std::vector&lt;double&gt; refs = tmd.TMDpdf(x_test, 0.0, kt, q_test);\n            double ref = refs[pid_test_idx]; // Up Quark\n\n            std::vector&lt;double&gt; params = { kt,x_test, q_test * q_test };\n            double res = wpdf.xfxQ2_ND(pids[pid_test_idx], params);\n\n            assert(std::abs(ref - res) &lt; TOLERANCE);\n        }\n    }\n\n    return EXIT_SUCCESS;\n}\n</code></pre>"},{"location":"examples/c/","title":"C/C++ API Example","text":"<p>This example demonstrates how to use the <code>NeoPDF</code> C/C++ API to load and evaluate parton distributions. More examples can be found in neopdf_capi/tests.</p>"},{"location":"examples/c/#prerequisites","title":"Prerequisites","text":"<p>Build and install the C API as described in the installation guide.</p>"},{"location":"examples/c/#c-examples","title":"C Examples","text":"<p>In this section, we are goinge to illustrate how to use the C/C++ API in a pure C project.</p>"},{"location":"examples/c/#example-1-loading-and-evaluating-pdfs","title":"Example 1: Loading and Evaluating PDFs","text":"<p>In this first examples, we are going to show how to load both single and multiple PDF members, evaluate parton distributions for a given value of the momentum fraction \\(x\\) and momentum transfer \\(Q^2\\).</p> <pre><code>#include &lt;neopdf_capi.h&gt;\n#include &lt;assert.h&gt;\n#include &lt;math.h&gt;\n#include &lt;stdbool.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\ndouble* geomspace(double start, double stop, int num, bool endpoint) {\n    double* result = (double*)malloc(num * sizeof(double));\n    if (num == 1) {\n        result[0] = start;\n        return result;\n    }\n\n    double log_start = log(start);\n    double log_stop = log(stop);\n    double step = (log_stop - log_start) / (endpoint ? (num - 1) : num);\n\n    for (int i = 0; i &lt; num; ++i) {\n        result[i] = exp(log_start + i * step);\n    }\n\n    return result;\n}\n\nvoid test_single_pdf() {\n    printf(\"=== Test Loading a Single PDF Member ===\\n\");\n\n    const char* pdfname = \"NNPDF40_nnlo_as_01180\";\n    NeoPDFWrapper* neo_pdf = neopdf_pdf_load(pdfname, 0);\n\n    int pids[] = {-5, -4, -3, -2, -1, 21, 1, 2, 3, 4, 5};\n    int num_pids = sizeof(pids) / sizeof(pids[0]);\n\n    double x_min = neopdf_pdf_x_min(neo_pdf);\n    double x_max = neopdf_pdf_x_max(neo_pdf);\n    double q2_min = neopdf_pdf_q2_min(neo_pdf);\n    double q2_max = neopdf_pdf_q2_max(neo_pdf);\n\n    int num_xs = 20;\n    int num_q2s = 20;\n    double* xs = geomspace(x_min, x_max, num_xs, false);\n    double* q2s = geomspace(q2_min, q2_max, num_q2s, false);\n\n    printf(\"%6s %15s %15s %15s\\n\", \"pid\", \"x\", \"Q2\", \"NeoPDF\");\n    printf(\"----------------------------------------------------------------\\n\");\n\n    for (int i = 0; i &lt; num_pids; ++i) {\n        for (int j = 0; j &lt; num_xs; ++j) {\n            for (int k = 0; k &lt; num_q2s; ++k) {\n                double result = neopdf_pdf_xfxq2(neo_pdf, pids[i], xs[j], q2s[k]);\n                printf(\"%6d %15.8e %15.8e %15.8e\\n\", pids[i], xs[j], q2s[k], result);\n            }\n        }\n    }\n\n    free(xs);\n    free(q2s);\n    neopdf_pdf_free(neo_pdf);\n}\n\nvoid test_all_pdf_members() {\n    printf(\"=== Test Loading all the PDF Members ===\\n\");\n\n    const char* pdfname = \"NNPDF40_nnlo_as_01180\";\n    NeoPDFMembers neo_pdfs = neopdf_pdf_load_all(pdfname);\n\n    printf(\"Loaded %zu PDF members\\n\", neo_pdfs.size);\n\n    int pid = 1;\n    double x = 1e-9;\n    double q2 = 1.65 * 1.65;\n\n    printf(\"\\nEvaluating xfxQ2 for pid=%d, x=%e, Q2=%e across all members:\\n\", pid, x, q2);\n    printf(\"%8s %15s\\n\", \"Member\", \"NeoPDF\");\n    printf(\"-------------------------\\n\");\n\n    double* results = (double*)malloc(neo_pdfs.size * sizeof(double));\n    for (size_t i = 0; i &lt; neo_pdfs.size; ++i) {\n        NeoPDFWrapper* pdf = neo_pdfs.pdfs[i];\n        double result = neopdf_pdf_xfxq2(pdf, pid, x, q2);\n        results[i] = result;\n        printf(\"%8zu %15.8e\\n\", i, result);\n    }\n\n    double sum = 0.0;\n    for (size_t i = 0; i &lt; neo_pdfs.size; ++i) {\n        sum += results[i];\n    }\n    double mean = sum / neo_pdfs.size;\n\n    double variance = 0.0;\n    for (size_t i = 0; i &lt; neo_pdfs.size; ++i) {\n        variance += (results[i] - mean) * (results[i] - mean);\n    }\n    variance /= neo_pdfs.size;\n    double std_dev = sqrt(variance);\n\n    printf(\"\\nStatistics across all members:\\n\");\n    printf(\"Mean: %e\\n\", mean);\n    printf(\"Std Dev: %e\\n\", std_dev);\n    printf(\"Relative Std Dev: %e\\n\", std_dev / mean);\n\n    free(results);\n    neopdf_pdf_array_free(neo_pdfs);\n}\n\nvoid test_lazy_loading() {\n    printf(\"=== Test Lazy Loading of PDF Members ===\\n\");\n\n    const char* pdfname = \"NNPDF40_nnlo_as_01180.neopdf.lz4\";\n    NeoPDFLazyIterator* lazy_iter = neopdf_pdf_load_lazy(pdfname);\n\n    if (!lazy_iter) {\n        fprintf(stderr, \"Failed to load lazy iterator for %s\\n\", pdfname);\n        return;\n    }\n\n    printf(\"Successfully loaded lazy iterator for %s\\n\", pdfname);\n\n    int pid = 1;\n    double x = 1e-9;\n    double q2 = 1.65 * 1.65;\n\n    printf(\"\\nEvaluating xfxQ2 for pid=%d, x=%e, Q2=%e across all members (lazily):\\n\", pid, x, q2);\n    printf(\"%8s %15s\\n\", \"Member\", \"NeoPDF\");\n    printf(\"-------------------------\\n\");\n\n    int member_idx = 0;\n    NeoPDFWrapper* pdf;\n    while ((pdf = neopdf_lazy_iterator_next(lazy_iter))) {\n        double result = neopdf_pdf_xfxq2(pdf, pid, x, q2);\n        printf(\"%8d %15.8e\\n\", member_idx, result);\n        neopdf_pdf_free(pdf);\n        member_idx++;\n    }\n\n    neopdf_lazy_iterator_free(lazy_iter);\n\n    printf(\"\\nSuccessfully iterated through all members lazily.\\n\");\n}\n\nint main() {\n    test_single_pdf();\n    test_all_pdf_members();\n    test_lazy_loading();\n\n    return EXIT_SUCCESS;\n}\n</code></pre>"},{"location":"examples/c/#example-2-filling-and-writing-a-neopdf-grid","title":"Example 2: Filling and Writing a NeoPDF Grid","text":"<p>This example illustrates how to fill and write a <code>NeoPDF</code> grid using the C API. It demonstrates the process of constructing a grid for each PDF member and serializing the collection to disk.</p> <p>NOTE</p> <p>As in the other sectioons, the following example fills the <code>NeoPDF</code> grid by re-computing the values of the subgrids from another set. This makes it possible to explicitly check that the filling of the grid is correct. However, this makes the codes very verbose. To easily spot the parts that actually fills the grid, some lines are highlighted.</p> <pre><code>#include &lt;neopdf_capi.h&gt;\n#include &lt;assert.h&gt;\n#include &lt;math.h&gt;\n#include &lt;stdbool.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\nconst double TOLERANCE = 1e-16;\n\nstruct SubgridParams {\n    double * values;\n    size_t size;\n};\n\n// Helper function to extract subgrid parameters\nstruct SubgridParams extract_subgrid_params(\n    NeoPDFWrapper* pdf,\n    NeopdfSubgridParams param_type,\n    size_t subgrid_idx,\n    size_t num_subgrids\n) {\n    size_t* shape = (size_t*)malloc(num_subgrids * sizeof(size_t));\n    neopdf_pdf_subgrids_shape_for_param(\n        pdf,\n        shape,\n        num_subgrids,\n        param_type\n    );\n    size_t size = shape[subgrid_idx];\n\n    double* values = (double*)malloc(size * sizeof(double));\n    neopdf_pdf_subgrids_for_param(\n        pdf,\n        values,\n        param_type,\n        num_subgrids,\n        shape,\n        subgrid_idx\n    );\n\n    free(shape);\n    struct SubgridParams results = {.values=values, .size=size};\n    return results;\n}\n\nint main() {\n    const char* pdfname = \"NNPDF40_nnlo_as_01180\";\n    // Load all PDF members\n    NeoPDFMembers neo_pdfs = neopdf_pdf_load_all(pdfname);\n    if (neo_pdfs.size == 0) {\n        fprintf(stderr, \"Failed to load any PDF members!\\n\");\n        return 1;\n    }\n    printf(\"Loaded %zu PDF members\\n\", neo_pdfs.size);\n\n    // Extract the PID values of the PDF set\n    size_t num_pids = neopdf_pdf_num_pids(neo_pdfs.pdfs[0]);\n    int* pids = (int*)malloc(num_pids * sizeof(int));\n    neopdf_pdf_pids(neo_pdfs.pdfs[0], pids, num_pids);\n\n    // Extrac the number of subgrids\n    size_t num_subgrids = neopdf_pdf_num_subgrids(neo_pdfs.pdfs[0]);\n\n    // Create a collection\n    NeoPDFGridArrayCollection* collection = neopdf_gridarray_collection_new();\n    if (!collection) {\n        fprintf(stderr, \"Failed to create grid array collection!\\n\");\n        neopdf_pdf_array_free(neo_pdfs);\n        return 1;\n    }\n\n    // For each member, build a grid\n    for (size_t m = 0; m &lt; neo_pdfs.size; ++m) {\n        NeoPDFWrapper* pdf = neo_pdfs.pdfs[m];\n        NeoPDFGrid* grid = neopdf_grid_new();\n\n        if (!grid) {\n            fprintf(stderr, \"Failed to create grid for member: %zu!\\n\", m);\n            continue;\n        }\n\n        // Loop over the Subgrids\n        for (size_t subgrid_idx = 0; subgrid_idx != num_subgrids; subgrid_idx++) {\n            // Extrac the parameter values of the given subgrid\n            struct SubgridParams xs_obj = extract_subgrid_params(\n                pdf,\n                NEOPDF_SUBGRID_PARAMS_MOMENTUM,\n                subgrid_idx,\n                num_subgrids\n            );\n            struct SubgridParams q2s_obj = extract_subgrid_params(\n                pdf,\n                NEOPDF_SUBGRID_PARAMS_SCALE,\n                subgrid_idx,\n                num_subgrids\n            );\n            struct SubgridParams alphas_obj = extract_subgrid_params(\n                pdf,\n                NEOPDF_SUBGRID_PARAMS_ALPHAS,\n                subgrid_idx,\n                num_subgrids\n            );\n            struct SubgridParams nucleons_obj = extract_subgrid_params(\n                pdf,\n                NEOPDF_SUBGRID_PARAMS_NUCLEONS,\n                subgrid_idx,\n                num_subgrids\n            );\n            struct SubgridParams kts_obj = extract_subgrid_params(\n                pdf,\n                NEOPDF_SUBGRID_PARAMS_KT,\n                subgrid_idx,\n                num_subgrids\n            );\n\n            // Extract the values\n            double* xs =  xs_obj.values;\n            double* q2s =  q2s_obj.values;\n            double* alphas =  alphas_obj.values;\n            double* nucleons =  nucleons_obj.values;\n            double* kts =  kts_obj.values;\n\n            // Compute grid_data: [q2s][xs][flavors], instead of [nucleons][alphas][q2s][xs][flavors]\n            // NOTE: This assumes that there is no `A`, `kT`, and `alphas` dependence.\n            size_t xs_size = xs_obj.size;\n            size_t q2s_size = q2s_obj.size;\n            double* grid_data = (double*)malloc(xs_size * q2s_size * num_pids * sizeof(double));\n            int data_idx = 0;\n            for (size_t xi = 0; xi &lt; xs_size; ++xi) {\n                for (size_t qi = 0; qi &lt; q2s_size; ++qi) {\n                    for (size_t f = 0; f &lt; num_pids; ++f) {\n                        int pid = pids[f];\n                        double val = neopdf_pdf_xfxq2(pdf, pid, xs[xi], q2s[qi]);\n                        grid_data[data_idx++] = val;\n                    }\n                }\n            }\n\n            // Add subgrid\n            int add_subgrid = neopdf_grid_add_subgrid(\n                grid,\n                nucleons, 1,\n                alphas, 1,\n                kts, 1,\n                xs, xs_size,\n                q2s, q2s_size,\n                grid_data, data_idx\n            );\n            if (add_subgrid != NEOPDF_RESULT_SUCCESS) {\n                fprintf(stderr, \"Failed to add subgrid for member: %zu!\\n\", m);\n                neopdf_grid_free(grid);\n                continue;\n            }\n            free(xs);\n            free(q2s);\n            free(alphas);\n            free(nucleons);\n            free(kts);\n            free(grid_data);\n        }\n\n        // Set flavor PIDs\n        int add_flavors = neopdf_grid_set_flavors(grid, pids, num_pids);\n        if (add_flavors != 0) {\n            fprintf(stderr, \"Failed to set flavors for member: %zu!\\n\", m);\n            neopdf_grid_free(grid);\n            continue;\n        }\n\n        // Add grid to collection\n        int add_grid = neopdf_gridarray_collection_add_grid(collection, grid);\n        if (add_grid != 0) {\n            fprintf(stderr, \"Failed to add grid to collection for member: %zu!\\n\", m);\n            neopdf_grid_free(grid);\n            continue;\n        }\n        printf(\"Added grid for member %zu\\n\", m);\n    }\n\n    // Fill the running of alphas with some random values\n    double alphas_qs[] = {2.0};\n    double alphas_vals[] = {0.118};\n\n    // Extrac the ranges for the momentum x and scale Q2\n    double x_range[2];\n    double q2_range[2];\n    neopdf_pdf_param_range(neo_pdfs.pdfs[0], NEOPDF_SUBGRID_PARAMS_MOMENTUM, x_range);\n    neopdf_pdf_param_range(neo_pdfs.pdfs[0], NEOPDF_SUBGRID_PARAMS_SCALE, q2_range);\n\n    NeoPDFPhysicsParameters phys_params = {\n        .flavor_scheme = \"variable\",\n        .order_qcd = 2,\n        .alphas_order_qcd = 2,\n        .m_w = 80.352,\n        .m_z = 91.1876,\n        .m_up = 0.0,\n        .m_down = 0.0,\n        .m_strange = 0.0,\n        .m_charm = 1.51,\n        .m_bottom = 4.92,\n        .m_top = 172.5,\n        .alphas_type = \"ipol\",\n        .number_flavors = 4,\n    };\n\n    NeoPDFMetaData meta = {\n        .set_desc = \"NNPDF40_nnlo_as_01180 collection\",\n        .set_index = 0,\n        .num_members = (uint32_t)neo_pdfs.size,\n        .x_min = x_range[0],\n        .x_max = x_range[1],\n        .q_min = sqrt(q2_range[0]),\n        .q_max = sqrt(q2_range[1]),\n        .flavors = pids,\n        .num_flavors = (size_t)num_pids,\n        .format = \"neopdf\",\n        .alphas_q_values = alphas_qs,\n        .num_alphas_q = 1,\n        .alphas_vals = alphas_vals,\n        .num_alphas_vals = 1,\n        .polarised = false,\n        .set_type = NEOPDF_SET_TYPE_SPACE_LIKE,\n        .interpolator_type = NEOPDF_INTERPOLATOR_TYPE_LOG_BICUBIC,\n        .error_type = \"replicas\",\n        .hadron_pid = 2212,\n        .phys_params = phys_params,\n    };\n\n    // Check if `NEOPDF_DATA_PATH` is defined and store the Grid there.\n    const char* filename = \"check-xwriter.neopdf.lz4\";\n    const char* neopdf_path = getenv(\"NEOPDF_DATA_PATH\");\n    char output_path[256];\n    if (neopdf_path) {\n        snprintf(output_path, sizeof(output_path), \"%s/%s\", neopdf_path, filename);\n    } else {\n        snprintf(output_path, sizeof(output_path), \"%s\", filename);\n    }\n\n    // Write the PDF Grid into disk\n    int result = neopdf_grid_compress(collection, &amp;meta, output_path);\n    if (result != 0) {\n        fprintf(stderr, \"Compression failed with code %d\\n\", result);\n    } else {\n        printf(\"Compression succeeded!\\n\");\n    }\n\n    // If `NEOPDF_DATA_PATH` is defined, reload the grid and check ther results.\n    if (neopdf_path) {\n        int pid_test = 21;\n        double x_test = 1e-3;\n        double q2_test1 = 1e2;\n        double q2_test2 = 1e4;\n\n        double ref1 = neopdf_pdf_xfxq2(neo_pdfs.pdfs[0], pid_test, x_test, q2_test1);\n        double ref2 = neopdf_pdf_xfxq2(neo_pdfs.pdfs[0], pid_test, x_test, q2_test2);\n\n        NeoPDFWrapper* wpdf = neopdf_pdf_load(filename, 0);\n        double res1 = neopdf_pdf_xfxq2(wpdf, pid_test, x_test, q2_test1);\n        double res2 = neopdf_pdf_xfxq2(wpdf, pid_test, x_test, q2_test2);\n\n        assert(fabs(res1 - ref1) &lt; TOLERANCE);\n        assert(fabs(res2 - ref2) &lt; TOLERANCE);\n\n        // Delete PDF object from memory\n        neopdf_pdf_free(wpdf);\n    }\n\n    // Clip the interpolated values to zero when negatives\n    neopdf_pdf_set_force_positive(neo_pdfs.pdfs[0], NEOPDF_FORCE_POSITIVE_CLIP_NEGATIVE);\n    neopdf_force_positive pos_clip = neopdf_pdf_is_force_positive(neo_pdfs.pdfs[0]);\n    assert(pos_clip == NEOPDF_FORCE_POSITIVE_CLIP_NEGATIVE);\n\n    // Clip the interpolated values for all the PDF members\n    neopdf_pdf_set_force_positive_members(&amp;neo_pdfs, NEOPDF_FORCE_POSITIVE_CLIP_SMALL);\n    neopdf_force_positive clip_small = neopdf_pdf_is_force_positive(neo_pdfs.pdfs[4]);\n    assert(clip_small == NEOPDF_FORCE_POSITIVE_CLIP_SMALL);\n\n    // Cleanup\n    free(pids);\n    neopdf_gridarray_collection_free(collection);\n    neopdf_pdf_array_free(neo_pdfs);\n\n    return result == 0 ? 0 : 1;\n}\n</code></pre>"},{"location":"examples/c/#c-examples_1","title":"C++ Examples","text":"<p>In the following section, we are going to see how to use the C/C++ API in a C++ code. For some exampels of Object Oriented C++ codes, head over to the C++ OOP section.</p>"},{"location":"examples/c/#example-1-loading-and-evaluating-pdfs_1","title":"Example 1: Loading and Evaluating PDFs","text":"<p>This example demonstrates the use of the <code>NeoPDF</code> C API to load both single and multiple PDF members, evaluate parton distributions for a range of \\(x\\) and \\(Q^2\\) values, and compare the results to LHAPDF.</p> <p>Technical details:</p> <ul> <li>The C API requires explicit memory management: objects created with <code>neopdf_pdf_load</code> or   <code>neopdf_pdf_load_all</code> must be freed with <code>neopdf_pdf_free</code> or <code>neopdf_pdf_array_free</code> to   avoid memory leaks.</li> <li>The evaluation of \\(x f(x, Q^2)\\) and \\(\\alpha_s(Q^2)\\) is performed in nested loops for each parton,   \\(x\\), and \\(Q^2\\) value. See the documentation on how to use the parallelized <code>xfxQ2s</code>.</li> <li>The code asserts that the results from <code>NeoPDF</code> and <code>LHAPDF</code> agree within a tight tolerance.</li> </ul> <pre><code>#include &lt;LHAPDF/PDF.h&gt;\n#include &lt;neopdf_capi.h&gt;\n#include &lt;cassert&gt;\n#include &lt;cmath&gt;\n#include &lt;cstdlib&gt;\n#include &lt;iomanip&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nconst double TOLERANCE= 1e-16;\n\ntemplate&lt;typename T&gt;\nstd::vector&lt;T&gt; geomspace(T start, T stop, int num, bool endpoint = false) {\n    std::vector&lt;T&gt; result(num);\n\n    if (num == 1) {\n        result[0] = start;\n        return result;\n    }\n\n    T log_start = std::log(start);\n    T log_stop = std::log(stop);\n    T step = (log_stop - log_start) / (endpoint ? (num - 1) : num);\n\n    for (int i = 0; i &lt; num; ++i) {\n        result[i] = std::exp(log_start + i * step);\n    }\n\n    return result;\n}\n\nvoid test_single_pdf() {\n    std::cout &lt;&lt; \"=== Test Loading a Single PDF Member ===\\n\";\n\n    // disable LHAPDF banners to guarantee deterministic output\n    LHAPDF::setVerbosity(0);\n\n    std::string pdfname = \"NNPDF40_nnlo_as_01180\";\n    NeoPDFWrapper* neo_pdf = neopdf_pdf_load(pdfname.c_str(), 0);\n    auto lha_pdf = std::unique_ptr&lt;LHAPDF::PDF&gt;(LHAPDF::mkPDF(pdfname, 0));\n\n    std::vector&lt;int&gt; pids = {-5, -4, -3, -2, -1, 21, 1, 2, 3, 4, 5};\n    std::vector&lt;double&gt; xs = geomspace(lha_pdf-&gt;xMin(), lha_pdf-&gt;xMax(), 200);\n    std::vector&lt;double&gt; q2s = geomspace(lha_pdf-&gt;q2Min(), lha_pdf-&gt;q2Max(), 200);\n\n    // Headers of the table to print the results\n    std::cout &lt;&lt; std::right\n        &lt;&lt; std::setw(6) &lt;&lt; \"pid\"\n        &lt;&lt; std::setw(15) &lt;&lt; \"x\"\n        &lt;&lt; std::setw(15) &lt;&lt; \"Q2\"\n        &lt;&lt; std::setw(15) &lt;&lt; \"LHAPDF\"\n        &lt;&lt; std::setw(15) &lt;&lt; \"NeoPDF\"\n        &lt;&lt; std::setw(15) &lt;&lt; \"Rel. Diff.\" &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; std::string(81, '-') &lt;&lt; \"\\n\";\n\n    for (const auto &amp;pid: pids) {\n        for (const auto &amp;x: xs) {\n            for (const auto &amp;q2: q2s) {\n                double expected = lha_pdf-&gt;xfxQ2(pid, x, q2);\n                double result = neopdf_pdf_xfxq2(neo_pdf, pid, x, q2);\n                double reldif = std::abs(result - expected) / expected;\n\n                assert(std::abs(result - expected) &lt; TOLERANCE);\n\n                // Print the results as a table\n                std::cout &lt;&lt; std::scientific &lt;&lt; std::setprecision(8)\n                    &lt;&lt; std::right\n                    &lt;&lt; std::setw(6)  &lt;&lt; pid\n                    &lt;&lt; std::setw(15) &lt;&lt; x\n                    &lt;&lt; std::setw(15) &lt;&lt; q2\n                    &lt;&lt; std::right\n                    &lt;&lt; std::setw(15) &lt;&lt; expected\n                    &lt;&lt; std::setw(15) &lt;&lt; result\n                    &lt;&lt; std::setw(15) &lt;&lt; reldif &lt;&lt; \"\\n\";\n                }\n            }\n\n    }\n\n    // Delete PDF object from memory\n    neopdf_pdf_free(neo_pdf);\n}\n\nvoid test_all_pdf_members() {\n    std::cout &lt;&lt; \"=== Test Loading all the PDF Members ===\\n\";\n\n    // disable LHAPDF banners to guarantee deterministic output\n    LHAPDF::setVerbosity(0);\n\n    std::string pdfname = \"NNPDF40_nnlo_as_01180\";\n    NeoPDFMembers neo_pdfs = neopdf_pdf_load_all(pdfname.c_str());\n\n    std::cout &lt;&lt; \"Loaded \" &lt;&lt; neo_pdfs.size &lt;&lt; \" PDF members\\n\";\n\n    // Test case: evaluate a simple point across all members\n    int pid = 1;\n    double x = 1e-9;\n    double q2 = 1.65 * 1.65;\n\n    std::cout &lt;&lt; \"\\nEvaluating xfxQ2 for pid=\" &lt;&lt; pid\n              &lt;&lt; \", x=\" &lt;&lt; std::scientific &lt;&lt; x\n              &lt;&lt; \", Q2=\" &lt;&lt; q2 &lt;&lt; \" across all members:\\n\";\n\n    std::cout &lt;&lt; std::right\n        &lt;&lt; std::setw(8) &lt;&lt; \"Member\"\n        &lt;&lt; std::setw(15) &lt;&lt; \"LHAPDF\"\n        &lt;&lt; std::setw(15) &lt;&lt; \"NeoPDF\"\n        &lt;&lt; std::setw(15) &lt;&lt; \"Rel. Diff.\" &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; std::string(53, '-') &lt;&lt; \"\\n\";\n\n    // Evaluate the same point across all PDF members\n    std::vector&lt;double&gt; results;\n    for (size_t i = 0; i &lt; neo_pdfs.size; ++i) {\n        NeoPDFWrapper* pdf = neo_pdfs.pdfs[i];\n        auto lha_pdf = std::unique_ptr&lt;LHAPDF::PDF&gt;(LHAPDF::mkPDF(pdfname, i));\n\n        double expected = lha_pdf-&gt;xfxQ2(pid, x, q2);\n        double result = neopdf_pdf_xfxq2(pdf, pid, x, q2);\n\n        double reldif = std::abs(result - expected) / expected;\n        assert(std::abs(result - expected) &lt; TOLERANCE);\n        results.push_back(result);\n\n        std::cout &lt;&lt; std::right\n            &lt;&lt; std::setw(8) &lt;&lt; i\n            &lt;&lt; std::scientific &lt;&lt; std::setprecision(8)\n            &lt;&lt; std::setw(15) &lt;&lt; expected\n            &lt;&lt; std::setw(15) &lt;&lt; result\n            &lt;&lt; std::setw(15) &lt;&lt; reldif &lt;&lt; \"\\n\";\n    }\n\n    // Calculate some statistics\n    double sum = 0.0;\n    for (double result : results) {\n        sum += result;\n    }\n    double mean = sum / results.size();\n\n    double variance = 0.0;\n    for (double result : results) {\n        variance += (result - mean) * (result - mean);\n    }\n    variance /= results.size();\n    double std_dev = std::sqrt(variance);\n\n    std::cout &lt;&lt; \"\\nStatistics across all members:\\n\";\n    std::cout &lt;&lt; \"Mean: \" &lt;&lt; std::scientific &lt;&lt; std::setprecision(8) &lt;&lt; mean &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \"Std Dev: \" &lt;&lt; std_dev &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \"Relative Std Dev: \" &lt;&lt; std_dev / mean &lt;&lt; \"\\n\";\n\n    // Delete objects from memory.\n    neopdf_pdf_array_free(neo_pdfs);\n}\n\nvoid test_lazy_loading() {\n    std::cout &lt;&lt; \"=== Test Lazy Loading of PDF Members ===\\n\";\n\n    // Disable LHAPDF banners to guarantee deterministic output\n    LHAPDF::setVerbosity(0);\n\n    std::string pdfname = \"NNPDF40_nnlo_as_01180\";\n    std::string neopdf_name = pdfname + \".neopdf.lz4\";\n    NeoPDFLazyIterator* lazy_iter = neopdf_pdf_load_lazy(neopdf_name.c_str());\n\n    if (!lazy_iter) {\n        std::cerr &lt;&lt; \"Failed to load lazy iterator for \" &lt;&lt; pdfname &lt;&lt; std::endl;\n        return;\n    }\n\n    std::cout &lt;&lt; \"Successfully loaded lazy iterator for \" &lt;&lt; pdfname &lt;&lt; \"\\n\";\n\n    // Test case: evaluate a simple point across all members\n    int pid = 1;\n    double x = 1e-9;\n    double q2 = 1.65 * 1.65;\n\n    std::cout &lt;&lt; \"\\nEvaluating xfxQ2 for pid=\" &lt;&lt; pid\n              &lt;&lt; \", x=\" &lt;&lt; std::scientific &lt;&lt; x\n              &lt;&lt; \", Q2=\" &lt;&lt; q2 &lt;&lt; \" across all members (lazily):\\n\";\n\n    std::cout &lt;&lt; std::right\n        &lt;&lt; std::setw(8) &lt;&lt; \"Member\"\n        &lt;&lt; std::setw(15) &lt;&lt; \"LHAPDF\"\n        &lt;&lt; std::setw(15) &lt;&lt; \"NeoPDF\"\n        &lt;&lt; std::setw(15) &lt;&lt; \"Rel. Diff.\" &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; std::string(53, '-') &lt;&lt; \"\\n\";\n\n    // Evaluate the same point across all PDF members\n    std::vector&lt;double&gt; results;\n    int member_idx = 0;\n    while (NeoPDFWrapper* pdf = neopdf_lazy_iterator_next(lazy_iter)) {\n        auto lha_pdf = std::unique_ptr&lt;LHAPDF::PDF&gt;(LHAPDF::mkPDF(pdfname, member_idx));\n\n        double expected = lha_pdf-&gt;xfxQ2(pid, x, q2);\n        double result = neopdf_pdf_xfxq2(pdf, pid, x, q2);\n\n        double reldif = std::abs(result - expected) / expected;\n        assert(std::abs(result - expected) &lt; TOLERANCE);\n        results.push_back(result);\n\n        std::cout &lt;&lt; std::right\n            &lt;&lt; std::setw(8) &lt;&lt; member_idx\n            &lt;&lt; std::scientific &lt;&lt; std::setprecision(8)\n            &lt;&lt; std::setw(15) &lt;&lt; expected\n            &lt;&lt; std::setw(15) &lt;&lt; result\n            &lt;&lt; std::setw(15) &lt;&lt; reldif &lt;&lt; \"\\n\";\n\n        neopdf_pdf_free(pdf); // Free the individual PDF member\n        member_idx++;\n    }\n\n    // Free the lazy iterator\n    neopdf_lazy_iterator_free(lazy_iter);\n\n    std::cout &lt;&lt; \"\\nSuccessfully iterated through all members lazily.\\n\";\n}\n\n\nint main() {\n    // Test loading single PDF member\n    test_single_pdf();\n\n    // Test loading all the PDF members\n    test_all_pdf_members();\n\n    // Test lazy loading of PDF members\n    test_lazy_loading();\n\n    return EXIT_SUCCESS;\n}\n</code></pre>"},{"location":"examples/c/#example-2-filling-and-writing-a-neopdf-grid_1","title":"Example 2: Filling and Writing a NeoPDF Grid","text":"<p>This example illustrates how to fill and write a <code>NeoPDF</code> grid using the C API. It demonstrates the process of constructing a grid for each PDF member and serializing the collection to disk.</p> <p>Technical details:</p> <ul> <li>The grid axes are defined as arrays for \\(x\\), \\(Q^2\\), parton IDs, nucleons, and \\(\\alpha_s\\) values.</li> <li>The grid data is stored in a 6D array, with the layout <code>[nucleons][alphas][pids][kT][xs][q2s]</code>.</li> <li>The <code>NeoPDFGridArrayCollection</code> manages the collection of grids and handles compression and   serialization to disk.</li> <li>Metadata is filled in a <code>NeoPDFMetaData</code> struct, which includes information about the set, axis   ranges, flavors, and interpolation type. This metadata is essential for correct interpretation   of the grid file.</li> <li>All memory management must be handled manually; every object created must be freed with the   appropriate function to avoid leaks.</li> <li>The output file is compressed and written in the <code>.neopdf.lz4</code> format, suitable for use with   <code>NeoPDF</code> tools and APIs.</li> </ul> <p>NOTE</p> <p>The following example fills the <code>NeoPDF</code> grid by re-computing the values of the subgrids from another set. This makes it possible to explicitly check that the filling of the grid is correct. However, this makes the codes very verbose. To easily spot the parts that actually fills the grid, some lines are highlighted.</p> <pre><code>#include &lt;cstddef&gt;\n#include &lt;neopdf_capi.h&gt;\n#include &lt;cassert&gt;\n#include &lt;cmath&gt;\n#include &lt;cstdio&gt;\n#include &lt;cstdlib&gt;\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\nconst double TOLERANCE= 1e-16;\n\ntemplate&lt;typename T&gt;\nstd::vector&lt;T&gt; geomspace(T start, T stop, int num, bool endpoint = false) {\n    std::vector&lt;T&gt; result(num);\n\n    if (num == 1) {\n        result[0] = start;\n        return result;\n    }\n\n    T log_start = std::log(start);\n    T log_stop = std::log(stop);\n    T step = (log_stop - log_start) / (endpoint ? (num - 1) : num);\n\n    for (int i = 0; i &lt; num; ++i) {\n        result[i] = std::exp(log_start + i * step);\n    }\n\n    return result;\n}\n\n// Helper function to extract subgrid parameters\nstd::vector&lt;double&gt; extract_subgrid_params(\n    NeoPDFWrapper* pdf,\n    NeopdfSubgridParams param_type,\n    std::size_t subgrid_idx,\n    std::size_t num_subgrids\n) {\n    std::vector&lt;std::size_t&gt; shape(num_subgrids);\n    neopdf_pdf_subgrids_shape_for_param(\n        pdf,\n        shape.data(),\n        num_subgrids,\n        param_type\n    );\n\n    std::vector&lt;double&gt; values(shape[subgrid_idx]);\n    neopdf_pdf_subgrids_for_param(\n        pdf,\n        values.data(),\n        param_type,\n        num_subgrids,\n        shape.data(),\n        subgrid_idx\n    );\n\n    return values;\n}\n\nint main() {\n    const char* pdfname = \"NNPDF40_nnlo_as_01180\";\n    // Load all PDF members\n    NeoPDFMembers neo_pdfs = neopdf_pdf_load_all(pdfname);\n    if (neo_pdfs.size == 0) {\n        std::cerr &lt;&lt; \"Failed to load any PDF members!\\n\";\n        return 1;\n    }\n    std::cout &lt;&lt; \"Loaded \" &lt;&lt; neo_pdfs.size &lt;&lt; \" PDF members\\n\";\n\n    // Extract the PID values of the PDF set\n    std::size_t num_pids = neopdf_pdf_num_pids(neo_pdfs.pdfs[0]);\n    std::vector&lt;int&gt; pids(num_pids);\n    neopdf_pdf_pids(neo_pdfs.pdfs[0], pids.data(), num_pids);\n\n    // Extrac the number of subgrids\n    std::size_t num_subgrids = neopdf_pdf_num_subgrids(neo_pdfs.pdfs[0]);\n\n    // Create a collection\n    NeoPDFGridArrayCollection* collection = neopdf_gridarray_collection_new();\n    if (!collection) {\n        std::cerr &lt;&lt; \"Failed to create grid array collection!\\n\";\n        neopdf_pdf_array_free(neo_pdfs);\n        return 1;\n    }\n\n    // For each member, build a grid\n    for (size_t m = 0; m &lt; neo_pdfs.size; ++m) {\n        NeoPDFWrapper* pdf = neo_pdfs.pdfs[m];\n        NeoPDFGrid* grid = neopdf_grid_new();\n\n        if (!grid) {\n            std::cerr &lt;&lt; \"Failed to create grid for member: \" &lt;&lt; m &lt;&lt; \"!\\n\";\n            continue;\n        }\n\n        // Loop over the Subgrids\n        for (std::size_t subgrid_idx = 0; subgrid_idx != num_subgrids; subgrid_idx++) {\n            // Extrac the parameter values of the given subgrid\n            auto xs = extract_subgrid_params(pdf, NEOPDF_SUBGRID_PARAMS_MOMENTUM, subgrid_idx, num_subgrids);\n            auto q2s = extract_subgrid_params(pdf, NEOPDF_SUBGRID_PARAMS_SCALE, subgrid_idx, num_subgrids);\n            auto alphas = extract_subgrid_params(pdf, NEOPDF_SUBGRID_PARAMS_ALPHAS, subgrid_idx, num_subgrids);\n            auto nucleons = extract_subgrid_params(pdf, NEOPDF_SUBGRID_PARAMS_NUCLEONS, subgrid_idx, num_subgrids);\n            auto kts = extract_subgrid_params(pdf, NEOPDF_SUBGRID_PARAMS_KT, subgrid_idx, num_subgrids);\n\n            // Compute grid_data: [q2s][xs][flavors], instead of [nucleons][alphas][q2s][xs][flavors]\n            // NOTE: This assumes that there is no 'A' and `alphas` dependence.\n            assert(nucleons.size() == 1);\n            assert(alphas.size() == 1);\n            assert(kts.size() == 1);\n            std::vector&lt;double&gt; grid_data;\n            for (size_t xi = 0; xi &lt; xs.size(); ++xi) {\n                for (size_t qi = 0; qi &lt; q2s.size(); ++qi) {\n                    for (size_t f = 0; f &lt; pids.size(); ++f) {\n                        int pid = pids[f];\n                        double val = neopdf_pdf_xfxq2(pdf, pid, xs[xi], q2s[qi]);\n                        grid_data.push_back(val);\n                    }\n                }\n            }\n\n            // Add subgrid\n            int add_subgrid = neopdf_grid_add_subgrid(\n                grid,\n                nucleons.data(), nucleons.size(),\n                alphas.data(), alphas.size(),\n                kts.data(), kts.size(),\n                xs.data(), xs.size(),\n                q2s.data(), q2s.size(),\n                grid_data.data(), grid_data.size()\n            );\n            if (add_subgrid != NEOPDF_RESULT_SUCCESS) {\n                std::cerr &lt;&lt; \"Failed to add subgrid for member: \" &lt;&lt; m &lt;&lt; \"!\\n\";\n                neopdf_grid_free(grid);\n                continue;\n            }\n        }\n\n        // Set flavor PIDs\n        int add_flavors = neopdf_grid_set_flavors(grid, pids.data(), pids.size());\n        if (add_flavors != 0) {\n            std::cerr &lt;&lt; \"Failed to set flavors for member: \" &lt;&lt; m &lt;&lt; \"!\\n\";\n            neopdf_grid_free(grid);\n            continue;\n        }\n\n        // Add grid to collection\n        int add_grid = neopdf_gridarray_collection_add_grid(collection, grid);\n        if (add_grid != 0) {\n            std::cerr &lt;&lt; \"Failed to add grid to collection for member: \" &lt;&lt; m &lt;&lt; \"!\\n\";\n            neopdf_grid_free(grid);\n            continue;\n        }\n        std::cout &lt;&lt; \"Added grid for member \" &lt;&lt; m &lt;&lt; \"\\n\";\n    }\n\n    // Fill the running of alphas with some random values\n    double alphas_qs[] = {2.0};\n    double alphas_vals[] = {0.118};\n\n    // Extrac the ranges for the momentum x and scale Q2\n    std::vector&lt;double&gt; x_range(2);\n    std::vector&lt;double&gt; q2_range(2);\n    neopdf_pdf_param_range(neo_pdfs.pdfs[0], NEOPDF_SUBGRID_PARAMS_MOMENTUM, x_range.data());\n    neopdf_pdf_param_range(neo_pdfs.pdfs[0], NEOPDF_SUBGRID_PARAMS_SCALE, q2_range.data());\n\n    NeoPDFPhysicsParameters phys_params = {\n        .flavor_scheme = \"variable\",\n        .order_qcd = 2,\n        .alphas_order_qcd = 2,\n        .m_w = 80.352,\n        .m_z = 91.1876,\n        .m_up = 0.0,\n        .m_down = 0.0,\n        .m_strange = 0.0,\n        .m_charm = 1.51,\n        .m_bottom = 4.92,\n        .m_top = 172.5,\n        .alphas_type = \"ipol\",\n        .number_flavors = 4,\n    };\n\n    NeoPDFMetaData meta = {\n        .set_desc = \"NNPDF40_nnlo_as_01180 collection\",\n        .set_index = 0,\n        .num_members = (uint32_t)neo_pdfs.size,\n        .x_min = x_range[0],\n        .x_max = x_range[1],\n        .q_min = sqrt(q2_range[0]),\n        .q_max = sqrt(q2_range[1]),\n        .flavors = pids.data(),\n        .num_flavors = (size_t)pids.size(),\n        .format = \"neopdf\",\n        .alphas_q_values = alphas_qs,\n        .num_alphas_q = 1,\n        .alphas_vals = alphas_vals,\n        .num_alphas_vals = 1,\n        .polarised = false,\n        .set_type = NEOPDF_SET_TYPE_SPACE_LIKE,\n        .interpolator_type = NEOPDF_INTERPOLATOR_TYPE_LOG_BICUBIC,\n        .error_type = \"replicas\",\n        .hadron_pid = 2212,\n        .phys_params = phys_params,\n    };\n\n    // Check if `NEOPDF_DATA_PATH` is defined and store the Grid there.\n    const char* filename = \"check-writer.neopdf.lz4\";\n    const char* neopdf_path = std::getenv(\"NEOPDF_DATA_PATH\");\n    std::string output_path = neopdf_path\n        ? std::string(neopdf_path) + (std::string(neopdf_path).back() == '/' ? \"\" : \"/\") + filename\n        : filename;\n\n    // Write the PDF Grid into disk\n    int result = neopdf_grid_compress(collection, &amp;meta, output_path.c_str());\n    if (result != 0) {\n        std::cerr &lt;&lt; \"Compression failed with code \" &lt;&lt; result &lt;&lt; \"\\n\";\n    } else {\n        std::cout &lt;&lt; \"Compression succeeded!\" &lt;&lt; \"\\n\";\n    }\n\n    // If `NEOPDF_DATA_PATH` is defined, reload the grid and check ther results.\n    if (neopdf_path) {\n        int pid_test = 21;\n        double x_test = 1e-3;\n        double q2_test1 = 1e2;\n        double q2_test2 = 1e4;\n\n        double ref1 = neopdf_pdf_xfxq2(neo_pdfs.pdfs[0], pid_test, x_test, q2_test1);\n        double ref2 = neopdf_pdf_xfxq2(neo_pdfs.pdfs[0], pid_test, x_test, q2_test2);\n\n        NeoPDFWrapper* wpdf = neopdf_pdf_load(filename, 0);\n        double res1 = neopdf_pdf_xfxq2(wpdf, pid_test, x_test, q2_test1);\n        double res2 = neopdf_pdf_xfxq2(wpdf, pid_test, x_test, q2_test2);\n\n        assert(std::abs(res1 - ref1) &lt; TOLERANCE);\n        assert(std::abs(res2 - ref2) &lt; TOLERANCE);\n\n        // Delete PDF object from memory\n        neopdf_pdf_free(wpdf);\n    }\n\n    // Cleanup\n    neopdf_gridarray_collection_free(collection);\n    neopdf_pdf_array_free(neo_pdfs);\n\n    return result == 0 ? 0 : 1;\n}\n</code></pre>"},{"location":"examples/c/#example-3-filling-and-writing-a-neopdf-grid-with-generic-parameters","title":"Example 3: Filling and Writing a NeoPDF Grid with generic Parameters","text":"<p>In the case where the PDF grid depends on more parameters, the filling of <code>grid_data</code> in the above example simply now becomes:</p> <pre><code>std::vector&lt;double&gt; grid_data;\nfor (size_t ni = 0; ni &lt; nucleons.size(); ++ni) {\n    for (size_t asi = 0; asi &lt; alphas.size(); ++asi) {\n        for (size_t xi = 0; xi &lt; xs.size(); ++xi) {\n            for (size_t qi = 0; qi &lt; q2s.size(); ++qi) {\n                for (size_t f = 0; f &lt; pids.size(); ++f) {\n                    int pid = pids[f];\n                    std::vector&lt;double&gt; params = {nucleons[ni], alphas[asi], xs[xi], q2s[qi]};\n                    double val = neopdf_pdf_xfxq2_nd(pdf, pid, params.data(), params.size());\n                    grid_data.push_back(val);\n                }\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"examples/fortran/","title":"Fortran API Example","text":"<p>The following examples illustrate how to use the Fortran interface to the <code>NeoPDF</code> library and to evaluate distributions.</p>"},{"location":"examples/fortran/#prerequisites","title":"Prerequisites","text":"<p>Build and install the C API as described in the installation guide. Then, copy the <code>neopdf_fapi/neopdf.f90</code> in the working directory and include it in the compilation. The following is an example of Makefile:</p> Makefile<pre><code>FC = gfortran\nFFLAGS = -Wall -Wextra -O0 -g -ffree-line-length-none\nNEOPDF_LIBS != pkg-config neopdf_capi --libs\nLHAPDF_LIBS != pkg-config lhapdf --libs\n\nPROGRAMS = check-fapi\n\nall: $(PROGRAMS)\n\ntest-examples: $(PROGRAMS)\n    set -e &amp;&amp; for i in $(PROGRAMS); do ./$${i} &gt; output; diff -u $${i}.output output; done; rm output\n\nneopdf.o: neopdf.f90\n    $(FC) $(FFLAGS) -c $&lt; -o $@\n\ncheck-fapi: check-fapi.f90 neopdf.o\n    $(FC) $(FFLAGS) $&lt; neopdf.o $(LHAPDF_LIBS) $(NEOPDF_LIBS) -o $@\n\ncheck-lazy-fapi: check-lazy-fapi.f90 neopdf.o\n    $(FC) $(FFLAGS) $&lt; neopdf.o $(NEOPDF_LIBS) -o $@\n\ncheck-writer-fapi: check-writer-fapi.f90 neopdf.o\n    $(FC) $(FFLAGS) $&lt; neopdf.o $(NEOPDF_LIBS) -o $@\n\n.PHONY: clean\n\nclean:\n    rm -f *.o *.mod $(PROGRAMS)\n</code></pre>"},{"location":"examples/fortran/#example-1-loading-and-evaluating-pdfs","title":"Example 1: Loading and Evaluating PDFs","text":"<p>This example demonstrates the use of the <code>NeoPDF</code> Fortran API to load a single PDF member, evaluate parton distributions for a range of \\(x\\) values, and compare the results to LHAPDF.</p> <pre><code>program check_fapi\n    use neopdf\n    use iso_c_binding\n\n    implicit none\n\n    type (neopdf_pdf)  :: pdf\n    character(len=256) :: pdf_name\n    integer            :: id, ix, member\n    double precision   :: x, q2, g_neo, g_lha\n    double precision xfs(-6:6)\n\n    pdf_name = \"NNPDF40_nnlo_as_01180\"\n    member = 0\n    q2 = 100.0\n    id = 21\n\n    call setlhaparm(\"SILENT\")\n    call initpdfsetbyname(pdf_name)\n    pdf = neopdf_pdf_load(trim(pdf_name), member)\n\n    write(*,'(A)') repeat('-', 38)\n    write(*,'(A10, 2X, A12, 2X, A12)') 'x', 'LHAPDF', 'NeOPDF'\n    write(*,'(A)') repeat('-', 38)\n\n    do ix=1,10\n        x = (ix - 0.5d0) / 10.0d0\n\n        call evolvepdf(x, sqrt(q2), xfs)\n        g_lha = xfs(0)\n        g_neo = neopdf_pdf_xfxq2(pdf, id, x, q2)\n\n        ! check the agreement (absolute value)\n        if (abs(g_lha - g_neo) &gt; 1e-16) then\n            write(*, *) \"LHAPDF and NeoPDF differs\"\n            stop 1\n        end if\n\n        write(*,'(ES10.3, 2X, ES12.5, 2X, ES12.5)') x, g_lha, g_neo\n    enddo\n\n    write(*,'(A)') repeat('-', 38)\n\n    call neopdf_pdf_free(pdf)\n\nend program check_fapi\n</code></pre> <p>The above code would print the following results:</p> <pre><code>--------------------------------------\n         x        LHAPDF        NeOPDF\n--------------------------------------\n 5.000E-02   2.35826E+00   2.35826E+00\n 1.500E-01   6.21341E-01   6.21341E-01\n 2.500E-01   2.34180E-01   2.34180E-01\n 3.500E-01   1.00192E-01   1.00192E-01\n 4.500E-01   3.86353E-02   3.86353E-02\n 5.500E-01   1.14658E-02   1.14658E-02\n 6.500E-01   2.41062E-03   2.41062E-03\n 7.500E-01   3.15737E-04   3.15737E-04\n 8.500E-01   1.94082E-05   1.94082E-05\n 9.500E-01   1.35325E-07   1.35325E-07\n--------------------------------------\n</code></pre>"},{"location":"examples/fortran/#example-2-loading-pdf-members-in-lazy-mode","title":"Example 2: Loading PDF Members in Lazy Mode","text":"<p>The following example illustrates how to load all the PDF members lazily. This presents some advantages in terms of speed and memory efficiency. However, the cost is delegated to when the interpolation is computed an usually loading the entire PDF members in eager mode when peforming evaluations on the members is generally much faster.</p> <pre><code>program check_lazy_fapi\n    use neopdf\n    use iso_c_binding\n\n    implicit none\n\n    type (neopdf_pdf)  :: pdf\n    type (neopdf_lazy_iterator) :: iter\n    character(len=256) :: pdf_name\n    integer            :: id, member\n    double precision   :: x, q2, g_neo\n\n    pdf_name = \"NNPDF40_nnlo_as_01180.neopdf.lz4\"\n    q2 = 100.0\n    id = 21\n    x = 0.1\n\n    iter = neopdf_pdf_load_lazy(trim(pdf_name))\n\n    write(*,'(A)') repeat('-', 26)\n    write(*,'(A10, 2X, A12)') 'Member', 'NeOPDF'\n    write(*,'(A)') repeat('-', 26)\n\n    do member=0,100\n        pdf = neopdf_lazy_iterator_next(iter)\n        if (.not. c_associated(pdf%ptr)) exit\n\n        g_neo = neopdf_pdf_xfxq2(pdf, id, x, q2)\n\n        write(*,'(I10, 2X, ES12.5)') member, g_neo\n\n        call neopdf_pdf_free(pdf)\n    enddo\n\n    write(*,'(A)') repeat('-', 26)\n\n    call neopdf_lazy_iterator_free(iter)\n\nend program check_lazy_fapi\n</code></pre>"},{"location":"examples/fortran/#example-3-filling-and-writing-a-neopdf-grid","title":"Example 3: Filling and Writing a NeoPDF Grid","text":"<p>The following example illustrates how to fill, write, and compress <code>NeoPDF</code> grids using the Fortran API.</p> <p>The filling of the PDF grid in the following example assumes no dependence in the nucleon numbers \\(A\\) and strong coupling \\(\\alpha_s\\) (ie. standard LHAPDF-like PDF). Refer to the C++ tutorials in the case the grid should explicitly depend on more parameters.</p> <p>NOTE</p> <p>The following example fills the <code>NeoPDF</code> grid by re-computing the values of the subgrids from an LHAPDF set. This makes it possible to explicitly check that the filling of the grid is correct. However, this makes the codes very verbose. To easily spot the parts that actually fills the grid, some lines are highlighted.</p> <pre><code>program check_writer_fapi\n    use neopdf\n    use iso_c_binding\n    use iso_fortran_env, only: real64\n\n    implicit none\n\n    integer, parameter :: dp = real64\n\n    type (neopdf_pdf) :: pdf\n    type (neopdf_pdf_members) :: pdfs\n    type (neopdf_grid) :: grid\n    type (neopdf_grid_array_collection) :: collection\n    character(len=256) :: pdf_name, output_path\n    integer, allocatable, target :: pids(:)\n    integer :: num_pids, num_subgrids, m, subgrid_idx, res\n    real(dp), allocatable :: xs(:), q2s(:), alphas(:), nucleons(:), kts(:), grid_data(:)\n    real(dp) :: x_range(2), q2_range(2)\n    real(dp), target :: alphas_q_values(1), alphas_vals(1)\n    type(neopdf_metadata) :: meta\n    type(neopdf_physics_parameters) :: phys_params\n\n    pdf_name = \"NNPDF40_nnlo_as_01180\"\n    output_path = \"check-writer-fapi.neopdf.lz4\"\n\n    pdfs = neopdf_pdf_load_all(trim(pdf_name))\n    pdf%ptr = c_get_pointer_to_member(pdfs, 0)\n\n    num_pids = neopdf_pdf_num_pids(pdf)\n    allocate(pids(num_pids))\n    call neopdf_pdf_pids(pdf, pids)\n\n    num_subgrids = neopdf_pdf_num_subgrids(pdf)\n\n    collection = neopdf_gridarray_collection_new()\n\n    do m = 0, pdfs%size - 1\n        pdf%ptr = c_get_pointer_to_member(pdfs, m)\n        grid = neopdf_grid_new()\n\n        do subgrid_idx = 0, num_subgrids - 1\n            call extract_subgrid_params(pdf, NEOPDF_SUBGRID_PARAMS_MOMENTUM, subgrid_idx+1, num_subgrids, xs)\n            call extract_subgrid_params(pdf, NEOPDF_SUBGRID_PARAMS_SCALE, subgrid_idx+1, num_subgrids, q2s)\n            call extract_subgrid_params(pdf, NEOPDF_SUBGRID_PARAMS_ALPHAS, subgrid_idx+1, num_subgrids, alphas)\n            call extract_subgrid_params(pdf, NEOPDF_SUBGRID_PARAMS_NUCLEONS, subgrid_idx+1, num_subgrids, nucleons)\n            call extract_subgrid_params(pdf, NEOPDF_SUBGRID_PARAMS_KT, subgrid_idx+1, num_subgrids, kts)\n\n            call compute_grid_data(pdf, xs, q2s, pids, grid_data)\n\n            res = neopdf_grid_add_subgrid(grid, nucleons, alphas, kts, xs, q2s, grid_data)\n            if (res /= 0) then\n                write(*,*) \"Failed to add subgrid\"\n                stop 1\n            end if\n        end do\n\n        res = neopdf_grid_set_flavors(grid, pids)\n        if (res /= 0) then\n            write(*,*) \"Failed to set flavors\"\n            stop 1\n        end if\n\n        res = neopdf_gridarray_collection_add_grid(collection, grid)\n        if (res /= 0) then\n            write(*,*) \"Failed to add grid to collection\"\n            stop 1\n        end if\n    end do\n\n    call neopdf_pdf_param_range(pdf, NEOPDF_SUBGRID_PARAMS_MOMENTUM, x_range)\n    call neopdf_pdf_param_range(pdf, NEOPDF_SUBGRID_PARAMS_SCALE, q2_range)\n\n    phys_params = neopdf_physics_parameters( &amp;\n        flavor_scheme=c_char_ptr(\"variable\" // c_null_char), &amp;\n        order_qcd=2, alphas_order_qcd=2, &amp;\n        m_w=80.352_dp, m_z=91.1876_dp, &amp;\n        m_up=0.0_dp, m_down=0.0_dp, m_strange=0.0_dp, &amp;\n        m_charm=1.51_dp, m_bottom=4.92_dp, m_top=172.5_dp, &amp;\n        alphas_type=c_char_ptr(\"ipol\" // c_null_char), &amp;\n        number_flavors=4)\n\n    meta = neopdf_metadata( &amp;\n        set_desc=c_char_ptr(\"NNPDF40_nnlo_as_01180 collection\" // c_null_char), &amp;\n        set_index=0, num_members=int(pdfs%size, c_int32_t), &amp;\n        x_min=x_range(1), x_max=x_range(2), &amp;\n        q_min=sqrt(q2_range(1)), q_max=sqrt(q2_range(2)), &amp;\n        flavors=c_loc(pids), num_flavors=size(pids), &amp;\n        format=c_char_ptr(\"neopdf\" // c_null_char), &amp;\n        alphas_q_values=c_loc(alphas_q_values), num_alphas_q=1, &amp;\n        alphas_vals=c_loc(alphas_vals), num_alphas_vals=1, &amp;\n        polarised=.false._c_bool, set_type=0, interpolator_type=0, &amp;\n        error_type=c_char_ptr(\"replicas\" // c_null_char), hadron_pid=2212, &amp;\n        phys_params=phys_params)\n\n    res = neopdf_grid_compress(collection, meta, trim(output_path))\n    if (res /= 0) then\n        write(*,*) \"Compression failed\"\n        stop 1\n    end if\n\n    call neopdf_gridarray_collection_free(collection)\n    call neopdf_pdf_array_free(pdfs)\n\ncontains\n    function c_get_pointer_to_member(pdfs, m) result(pdf_ptr)\n        use iso_c_binding\n        implicit none\n        type(neopdf_pdf_members), intent(in) :: pdfs\n        integer, intent(in) :: m\n        type(c_ptr) :: pdf_ptr\n        type(c_ptr), pointer :: pdf_array_ptr(:)\n\n        call c_f_pointer(pdfs%pdfs, pdf_array_ptr, [pdfs%size])\n        pdf_ptr = pdf_array_ptr(m + 1)\n    end function\n\n    subroutine extract_subgrid_params(pdf, param_type, subgrid_idx, num_subgrids, values)\n        implicit none\n        type(neopdf_pdf), intent(in) :: pdf\n        integer, intent(in) :: param_type, subgrid_idx, num_subgrids\n        real(dp), allocatable, intent(out) :: values(:)\n        integer(c_size_t) :: shape(num_subgrids)\n\n        call neopdf_pdf_subgrids_shape_for_param(pdf, shape, param_type)\n        allocate(values(shape(subgrid_idx)))\n        call neopdf_pdf_subgrids_for_param(pdf, values, param_type, shape, subgrid_idx-1)\n    end subroutine\n\n    subroutine compute_grid_data(pdf, xs, q2s, pids, grid_data)\n        implicit none\n        type(neopdf_pdf), intent(in) :: pdf\n        real(dp), intent(in) :: xs(:), q2s(:)\n        integer, intent(in) :: pids(:)\n        real(dp), allocatable, intent(out) :: grid_data(:)\n        integer :: xi, qi, f, idx\n\n        allocate(grid_data(size(xs) * size(q2s) * size(pids)))\n        idx = 1\n        do xi = 1, size(xs)\n            do qi = 1, size(q2s)\n                do f = 1, size(pids)\n                    grid_data(idx) = neopdf_pdf_xfxq2(pdf, pids(f), xs(xi), q2s(qi))\n                    idx = idx + 1\n                end do\n            end do\n        end do\n    end subroutine\n\n    function c_char_ptr(s) result(p)\n        use iso_c_binding\n        implicit none\n        character(*), intent(in) :: s\n        type(c_ptr) :: p\n        character(len=len(s), kind=c_char), target :: s_c\n        s_c = transfer(s, s_c)\n        p = c_loc(s_c)\n    end function\nend program check_writer_fapi\n</code></pre>"},{"location":"examples/mathematica/","title":"Mathematica Interface Example","text":"<p>The following provides a short example on how to use the <code>Mathematica</code> interface of <code>NeoPDF</code>. More examples can be found in neopdf_wolfram.</p>"},{"location":"examples/mathematica/#prerequisites","title":"Prerequisites","text":"<p>In order to use the interface, we first need to install the bindings to the Wolfram LibraryLink and the Wolfram Language. To do so, clone the repository and go into the <code>neopdf_wolfram</code> directory. Then run the following command:</p> <pre><code>cargo build --release --manifest-path neopdf_wolfram/Cargo.toml\n</code></pre> <p>This will generate a <code>libneopdf_wolfram.dylib</code> in the <code>$PWD/target/release/</code> directory which can be loaded in Mathematica using the <code>LibraryFunctionLoad</code> function.</p>"},{"location":"examples/mathematica/#example-interpolating-pdfs","title":"Example interpolating PDFs","text":"<p>The following example illustrates how to load and interpolate PDFs from <code>Mathematica</code>.</p> <pre><code>(* ::Package:: *)\n\n(* Mathematica example for neopdf_wolfram *)\n\n(* Step 1: Load the library *)\n(* Replace with the actual path to the compiled library *)\nlibPath = \"/path/to/neopdf/target/release/libneopdf_wolfram.dylib\";\n\nloadPDF = LibraryFunctionLoad[libPath, \"NeoPDF_Load\", {\"UTF8String\", Integer}, Integer];\nxfxq2 = LibraryFunctionLoad[libPath, \"NeoPDF_XFXQ2\", {Integer, Integer, {Real, 1}}, Real];\nalphasQ2 = LibraryFunctionLoad[libPath, \"NeoPDF_AlphasQ2\", {Integer, Real}, Real];\nclearPDFs = LibraryFunctionLoad[libPath, \"NeoPDF_Clear\", {}, \"Void\"];\n\n(* Step 2: Load a PDF set *)\npdfName = \"NNPDF40_nnlo_as_01180\";\nmember = 0;\npdfIndex = loadPDF[pdfName, member];\nPrint[\"Loaded PDF set \", pdfName, \" with member \", member, \" at index \", pdfIndex];\n\n(* Step 3: Calculate xfxq2 *)\npid = 21; (* gluon *)\nx = 0.01;\nq2 = 100.0;\npoints = {x, q2};\nresultXFXQ2 = xfxq2[pdfIndex, pid, points];\nPrint[\"xfxq2 for pid=\", pid, \", x=\", x, \", q2=\", q2, \" is \", resultXFXQ2];\n\n(* Step 4: Calculate alpha_s *)\nq2AlphaS = 100.0;\nresultAlphaS = alphasQ2[pdfIndex, q2AlphaS];\nPrint[\"alpha_s for q2=\", q2AlphaS, \" is \", resultAlphaS];\n\n(* Step 5: Clear the loaded PDFs *)\nclearPDFs[];\nPrint[\"Cleared loaded PDFs.\"];\n</code></pre>"},{"location":"examples/neopdf-pyapi/","title":"<i class=\"devicon-python-plain colored\"></i> Python API","text":"<p>In the following example, we are going to showcase some of the main features of the <code>NeoPDF</code> Python API. The outline of the tutorial is as follow:</p> <ol> <li>Standard PDF Manipulation</li> <li>Convert LHAPDF into NeoPDF Format</li> <li>Create a NeoPDF Grid</li> <li>Combining LHAPDF Nuclear Sets into a Single NeoPDF Grid</li> </ol> In\u00a0[1]: Copied! <pre>import numpy as np\n\nfrom neopdf.pdf import PDF as NEOPDF\n</pre> import numpy as np  from neopdf.pdf import PDF as NEOPDF In\u00a0[2]: Copied! <pre># To load NeoPDF sets, if available, append the name with `.neopdf.lz4`\npdf = NEOPDF.mkPDF(\"NNPDF40_nnlo_as_01180\")\n</pre> # To load NeoPDF sets, if available, append the name with `.neopdf.lz4` pdf = NEOPDF.mkPDF(\"NNPDF40_nnlo_as_01180\") In\u00a0[3]: Copied! <pre># Get the Metadata of the PDF set.\nmetadata = pdf.metadata()\nmetadata_dict = metadata.to_dict()\nmetadata_dict.keys()\n</pre> # Get the Metadata of the PDF set. metadata = pdf.metadata() metadata_dict = metadata.to_dict() metadata_dict.keys() Out[3]: <pre>dict_keys(['set_desc', 'set_index', 'num_members', 'x_min', 'x_max', 'q_min', 'q_max', 'flavors', 'format', 'alphas_q_values', 'alphas_vals', 'polarised', 'set_type', 'interpolator_type', 'error_type', 'hadron_pid', 'git_version', 'code_version', 'flavor_scheme', 'order_qcd', 'alphas_order_qcd', 'm_w', 'm_z', 'm_up', 'm_down', 'm_strange', 'm_charm', 'm_bottom', 'm_top'])</pre> In\u00a0[4]: Copied! <pre>metadata_dict[\"set_desc\"]\n</pre> metadata_dict[\"set_desc\"] Out[4]: <pre>'NNPDF4.0 NNLO global fit, alphas(MZ)=0.1180. mem=0 =&gt; average on replicas; mem=1-100 =&gt; PDF replicas'</pre> In\u00a0[5]: Copied! <pre>metadata_dict[\"alphas_vals\"][:4]\n</pre> metadata_dict[\"alphas_vals\"][:4] Out[5]: <pre>[0.33074891, 0.3176246, 0.30507081, 0.29305875]</pre> In\u00a0[6]: Copied! <pre>metadata_dict[\"set_type\"]\n</pre> metadata_dict[\"set_type\"] Out[6]: <pre>'PDF'</pre> <p>We can also check the shape of the subgrids. In the following example, we are checking the shape of the first subgrid:</p> In\u00a0[7]: Copied! <pre>pdf_subgrids = pdf.subgrids()\npdf_subgrids[0].grid_shape()\n</pre> pdf_subgrids = pdf.subgrids() pdf_subgrids[0].grid_shape() Out[7]: <pre>(1, 1, 11, 1, 196, 12)</pre> <p>The way to compute the value of the interpolated PDF $x f(x, Q^2)$ and the strong coupling $\\alpha_s$ is the same as in LHAPDF.</p> In\u00a0[8]: Copied! <pre>pdf.alphasQ2(q2=10)\n</pre> pdf.alphasQ2(q2=10) Out[8]: <pre>0.2485925816007479</pre> In\u00a0[9]: Copied! <pre>pdf.xfxQ2(id=21, x=1e-5, q2=1e3)\n</pre> pdf.xfxQ2(id=21, x=1e-5, q2=1e3) Out[9]: <pre>111.20984759980468</pre> <p>One can also compute $x f(x, Q^2)$ for values of PID, $x$, and $Q^2$:</p> In\u00a0[10]: Copied! <pre>xs = np.geomspace(1e-9, 1.0, 50, endpoint=False)\nq2s = np.geomspace(1e2, 1e6, 50, endpoint=False)\npids = [nf for nf in range(-4, 5) if nf != 0]\n\nresult = pdf.xfxQ2s(pids=pids, xs=xs, q2s=q2s)\nresult = result.reshape(len(pids), xs.size, q2s.size)\nresult[0][0][0]\n</pre> xs = np.geomspace(1e-9, 1.0, 50, endpoint=False) q2s = np.geomspace(1e2, 1e6, 50, endpoint=False) pids = [nf for nf in range(-4, 5) if nf != 0]  result = pdf.xfxQ2s(pids=pids, xs=xs, q2s=q2s) result = result.reshape(len(pids), xs.size, q2s.size) result[0][0][0] Out[10]: <pre>12.628715124538546</pre> <p>NOTE: To load all the PDF members at once, as in LHAPDF, one can simply do:</p> <pre>all_pdfs = NEOPDF.mkPDFs(\"NNPDF40_nnlo_as_01180\")\n</pre> In\u00a0[11]: Copied! <pre>from neopdf.converter import convert_lhapdf\n</pre> from neopdf.converter import convert_lhapdf In\u00a0[12]: Copied! <pre># NeoPDF files should be appended with the suffix `neopdf.lz4`\nconvert_lhapdf(\n    pdf_name=\"NNPDF40_nnlo_as_01180\", output_path=\"NNPDF40_nnlo_as_01180.neopdf.lz4\"\n)\n</pre> # NeoPDF files should be appended with the suffix `neopdf.lz4` convert_lhapdf(     pdf_name=\"NNPDF40_nnlo_as_01180\", output_path=\"NNPDF40_nnlo_as_01180.neopdf.lz4\" ) <p>The above code will generate a file called <code>NNPDF40_nnlo_as_01180.neopdf.lz4</code> in the current directory. In order to load it, put it in the (default) <code>NEOPDF_DATA_PATH</code> path. See the <code>installation</code> section for more details. The set can be loaded in the same way as for standard LHAPDF sets.</p> In\u00a0[13]: Copied! <pre>neopdf = NEOPDF.mkPDF(\"NNPDF40_nnlo_as_01180.neopdf.lz4\")\npdf.xfxQ2(id=21, x=1e-5, q2=1e3)\n</pre> neopdf = NEOPDF.mkPDF(\"NNPDF40_nnlo_as_01180.neopdf.lz4\") pdf.xfxQ2(id=21, x=1e-5, q2=1e3) Out[13]: <pre>111.20984759980468</pre> In\u00a0[14]: Copied! <pre># Some imports\nfrom neopdf.writer import compress\nfrom neopdf.gridpdf import GridArray, SubGrid\nfrom neopdf.metadata import InterpolatorType, SetType, MetaData, PhysicsParameters\n</pre> # Some imports from neopdf.writer import compress from neopdf.gridpdf import GridArray, SubGrid from neopdf.metadata import InterpolatorType, SetType, MetaData, PhysicsParameters In\u00a0[15]: Copied! <pre># Construct the shared Metadata\nnum_members = 10\nx_min = 1e-5\nx_max = 1.0\nq_min = 4.0\nq_max = 1e5\nflavors = [nf for nf in range(-4, 5)]\nnum_alphas = 6\nalphas_vals = np.random.uniform(0.1, 0.2, num_alphas)\nalphas_qvalues = np.geomspace(q_min, q_max, num_alphas)\n\n# Define the Physical Parameters in the Metadata\nphysparams_kwargs = {\n    \"flavor_scheme\": \"fixed\",\n    \"order_qcd\": 2,\n    \"alphas_order_qcd\": 2,\n    \"m_w\": 80.3520,\n    \"m_z\": 91.1876,\n    \"m_up\": 0.0,\n    \"m_down\": 0.0,\n    \"m_strange\": 0.0,\n    \"m_charm\": 1.51,\n    \"m_bottom\": 4.92,\n    \"m_top\": 172.5,\n}\n\nphys_params = PhysicsParameters(**physparams_kwargs)\n\n# Construct the PDF Metadata\nmetadata_kwargs = {\n    \"set_desc\": \"Some Toy NeoPDF set\",\n    \"set_index\": 123456,\n    \"num_members\": num_members,\n    \"x_min\": x_min,\n    \"x_max\": x_max,\n    \"q_min\": q_min,\n    \"q_max\": q_max,\n    \"flavors\": flavors,\n    \"format\": \"neopdf\",\n    \"alphas_q_values\": alphas_qvalues,\n    \"alphas_vals\": alphas_vals,\n    \"polarised\": False,\n    \"set_type\": SetType.SpaceLike,\n    \"interpolator_type\": InterpolatorType.LogBicubic,\n    \"phys_params\": phys_params,\n}\n\nmetadata = MetaData(**metadata_kwargs)\n</pre> # Construct the shared Metadata num_members = 10 x_min = 1e-5 x_max = 1.0 q_min = 4.0 q_max = 1e5 flavors = [nf for nf in range(-4, 5)] num_alphas = 6 alphas_vals = np.random.uniform(0.1, 0.2, num_alphas) alphas_qvalues = np.geomspace(q_min, q_max, num_alphas)  # Define the Physical Parameters in the Metadata physparams_kwargs = {     \"flavor_scheme\": \"fixed\",     \"order_qcd\": 2,     \"alphas_order_qcd\": 2,     \"m_w\": 80.3520,     \"m_z\": 91.1876,     \"m_up\": 0.0,     \"m_down\": 0.0,     \"m_strange\": 0.0,     \"m_charm\": 1.51,     \"m_bottom\": 4.92,     \"m_top\": 172.5, }  phys_params = PhysicsParameters(**physparams_kwargs)  # Construct the PDF Metadata metadata_kwargs = {     \"set_desc\": \"Some Toy NeoPDF set\",     \"set_index\": 123456,     \"num_members\": num_members,     \"x_min\": x_min,     \"x_max\": x_max,     \"q_min\": q_min,     \"q_max\": q_max,     \"flavors\": flavors,     \"format\": \"neopdf\",     \"alphas_q_values\": alphas_qvalues,     \"alphas_vals\": alphas_vals,     \"polarised\": False,     \"set_type\": SetType.SpaceLike,     \"interpolator_type\": InterpolatorType.LogBicubic,     \"phys_params\": phys_params, }  metadata = MetaData(**metadata_kwargs) In\u00a0[16]: Copied! <pre># Construct the PDF Grid:\n#   - A subrid is represented by the `SubGrid` object\n#   - A member is represented by the `GridArray` object\n\nnucleons = [1]  # Proton Only\nalphas_mZ = [0.118]  # Only one value\nkts = [0.0]  # No dependence on the Transverse Momentum\ngrid_members = []\n\nx_values = np.geomspace(x_min, x_max, 50)\n# Subdivide the Q2 range into subgrids\nq_mid = int(q_max / 3)\nq2_sub1 = np.geomspace(q_min * q_min, q_mid * q_mid, 25)\nq2_sub2 = np.geomspace(q_mid * q_mid, q_max * q_max, 25)\nq2_values = [q2_sub1, q2_sub2]\n\nfor _ in range(num_members):\n    sub_grids = []\n    for q2_vals in q2_values:\n        grid_shape = (\n            len(nucleons),\n            len(alphas_mZ),\n            len(flavors),\n            len(kts),\n            x_values.size,\n            q2_vals.size,\n        )\n        grid = np.random.uniform(0, 1, grid_shape)\n\n        sub_grid = SubGrid(\n            xs=x_values,\n            q2s=q2_vals,\n            kts=kts,\n            nucleons=nucleons,\n            alphas=alphas_mZ,\n            grid=grid,\n        )\n        sub_grids.append(sub_grid)\n\n    grid_member = GridArray(pids=flavors, subgrids=sub_grids)\n    grid_members.append(grid_member)\n\n# Write the compressed PDF set into disk\ncompress(grids=grid_members, metadata=metadata, path=\"TOY_NEOPDF.neopdf.lz4\")\n</pre> # Construct the PDF Grid: #   - A subrid is represented by the `SubGrid` object #   - A member is represented by the `GridArray` object  nucleons = [1]  # Proton Only alphas_mZ = [0.118]  # Only one value kts = [0.0]  # No dependence on the Transverse Momentum grid_members = []  x_values = np.geomspace(x_min, x_max, 50) # Subdivide the Q2 range into subgrids q_mid = int(q_max / 3) q2_sub1 = np.geomspace(q_min * q_min, q_mid * q_mid, 25) q2_sub2 = np.geomspace(q_mid * q_mid, q_max * q_max, 25) q2_values = [q2_sub1, q2_sub2]  for _ in range(num_members):     sub_grids = []     for q2_vals in q2_values:         grid_shape = (             len(nucleons),             len(alphas_mZ),             len(flavors),             len(kts),             x_values.size,             q2_vals.size,         )         grid = np.random.uniform(0, 1, grid_shape)          sub_grid = SubGrid(             xs=x_values,             q2s=q2_vals,             kts=kts,             nucleons=nucleons,             alphas=alphas_mZ,             grid=grid,         )         sub_grids.append(sub_grid)      grid_member = GridArray(pids=flavors, subgrids=sub_grids)     grid_members.append(grid_member)  # Write the compressed PDF set into disk compress(grids=grid_members, metadata=metadata, path=\"TOY_NEOPDF.neopdf.lz4\") <p>This will generate a file called <code>TOY_NEOPDF.neopdf.lz4</code> in the current directory that one can then move into the (default) <code>NEOPDF_DATA_PATH</code>. Alternatively, one can pass directly the path to where the the grid will be written in <code>compress</code> via the <code>path</code> argument.</p> In\u00a0[17]: Copied! <pre>from neopdf.converter import combine_lhapdf_npdfs\n</pre> from neopdf.converter import combine_lhapdf_npdfs In\u00a0[18]: Copied! <pre># List of nuclear PDFs to be combined - at least 4\nnpdfs_list = [\n    \"nNNPDF30_nlo_as_0118_p\",\n    \"nNNPDF30_nlo_as_0118_A2_Z1\",\n    \"nNNPDF30_nlo_as_0118_A4_Z2\",\n    \"nNNPDF30_nlo_as_0118_A6_Z3\",\n    \"nNNPDF30_nlo_as_0118_A9_Z4\",\n]\n\ncombine_lhapdf_npdfs(\n    pdf_names=npdfs_list, output_path=\"nNNPDF30_nlo_as_0118_A1_A9.neopdf.lz4\"\n)\n</pre> # List of nuclear PDFs to be combined - at least 4 npdfs_list = [     \"nNNPDF30_nlo_as_0118_p\",     \"nNNPDF30_nlo_as_0118_A2_Z1\",     \"nNNPDF30_nlo_as_0118_A4_Z2\",     \"nNNPDF30_nlo_as_0118_A6_Z3\",     \"nNNPDF30_nlo_as_0118_A9_Z4\", ]  combine_lhapdf_npdfs(     pdf_names=npdfs_list, output_path=\"nNNPDF30_nlo_as_0118_A1_A9.neopdf.lz4\" ) <p>We can now load the combined nuclear PDF sets and check that we can now interpolate the $A$-dependence using the <code>xfxQ2_ND</code> function.</p> In\u00a0[19]: Copied! <pre>nuclear_neopdfs = NEOPDF.mkPDF(\"nNNPDF30_nlo_as_0118_A1_A9.neopdf.lz4\")\n</pre> nuclear_neopdfs = NEOPDF.mkPDF(\"nNNPDF30_nlo_as_0118_A1_A9.neopdf.lz4\") In\u00a0[20]: Copied! <pre>A_value = 5  # No nPDF available\nnuclear_neopdfs.xfxQ2_ND(21, [A_value, 1e-5, 1e3])\n</pre> A_value = 5  # No nPDF available nuclear_neopdfs.xfxQ2_ND(21, [A_value, 1e-5, 1e3]) Out[20]: <pre>134.7438112942475</pre> <p>If instead of the $A$ dependence the grid containts the $\\alpha_s$ dependence, then one can just replace <code>A_value</code> with <code>alphas_value</code>. If the grid has a dependence on both, then syntax becomes:</p> <pre>A_value = 5\nalphas_value = 0.117\nnuclear_neopdfs.xfxQ2_ND(21, [A_value, alphas_value, 1e-5, 1e3]) # Note the Order\n</pre>"},{"location":"examples/neopdf-pyapi/#1-standard-pdf-manipulation","title":"1. Standard PDF Manipulation \u00b6","text":""},{"location":"examples/neopdf-pyapi/#2-convert-lhapdf-into-neopdf-format","title":"2. Convert LHAPDF into NeoPDF Format \u00b6","text":"<p>One can convert PDF sets in the LHAPDF format into the new format used by NeoPDF.</p>"},{"location":"examples/neopdf-pyapi/#3-create-a-neopdf-grid","title":"3. Create a NeoPDF Grid \u00b6","text":"<p>The following section shows how one can create a NeoPDF PDF grid from a given predictions/fits. As mentioned in the <code>Design</code> section, a NeoPDF subgrid is a 5-dimensional array in $(A, \\alpha_s, x, Q^2)$. In turn, each PDF member can contain multiple subgrids.</p>"},{"location":"examples/neopdf-pyapi/#4-combining-lhapdf-nuclear-sets-into-a-single-neopdf-grid","title":"4. Combining LHAPDF Nuclear Sets into a Single NeoPDF Grid \u00b6","text":"<p><code>NeoPDF</code> can combine multiple LHAPDF sets along a given parameter into a single <code>NeoPDF</code> grid such that the parameter-dependence is intrinsically included. In the following example, we are going to combine the nuclear $A$ dependence, however combining multiple $\\alpha_s$ variations also works the same.</p> <p>NOTE: As a default, the bi-cubic log-interpolation is used, and because of how such an interpolation works, the cardinal of the $\\left\\{A\\right\\}$ set must at least be four (04).</p>"},{"location":"lhapdf_benchmark/pdfs/","title":"LHAPDF Sets Benchmark","text":"<p>The following records the benchmark of <code>NeoPDF</code> against <code>LHAPDF</code> for all the available <code>LHAPDF</code> sets using the same Cubic Hermite Splines interpolation. The benchmark are done in the entire range of \\((x, Q^2)\\) for all PDF flavours and members. Sucess \u2705 means that the results are exactly the same, otherwise it is flagged as failed \u274c.</p> \\(xf_i (x, Q^2)\\) comparison\\(\\alpha_s (Q^2)\\) comparison <p>Comments on failed runs</p> <p>The failures in the computations of \\(xf_i (x, Q^2)\\) are not genuine and the failed runs need to be re-generated in order for them to succeed. For instance, the <code>Items are not equal</code> error is a result of how negative values are addressed. The <code>NeoPDF</code> runs used <code>ForcePositive::ClipSmall</code> to clip negative values to <code>1e-10</code> and upon using <code>ForcePositive::NoClipping</code> the results will be the same. Similarly, the error <code>Process failed: thread</code> is because, for some reasons, the sets were not available due to failures in downloading them.</p> PDF Set Benchmark Error Details ABMP15_3_nnlo \u2705 ABMP15_3_nnlo \u2705 ABMP15_4_nnlo \u2705 ABMP15_4_nnlo \u2705 ABMP15_5_nnlo \u2705 ABMP15_5_nnlo \u2705 ABMP16_3_nlo \u2705 ABMP16_3_nlo \u2705 ABMP16_3_nnlo \u2705 ABMP16_3_nnlo \u2705 ABMP16_4_nlo \u2705 ABMP16_4_nlo \u2705 ABMP16_4_nnlo \u2705 ABMP16_4_nnlo \u2705 ABMP16_5_nlo \u2705 ABMP16_5_nlo \u2705 ABMP16_5_nnlo \u2705 ABMP16_5_nnlo \u2705 ABMP16_5_nnlo_high_x \u274c Process failed: thread '' panicked at ne... ABMP16_5_nnlo_high_x \u274c Process failed: thread '' panicked at ne... ABMP16als112_5_nnlo \u2705 ABMP16als112_5_nnlo \u2705 ABMP16als113_5_nnlo \u2705 ABMP16als113_5_nnlo \u2705 ABMP16als114_5_nlo \u2705 ABMP16als114_5_nlo \u2705 ABMP16als114_5_nnlo \u2705 ABMP16als114_5_nnlo \u2705 ABMP16als115_5_nlo \u2705 ABMP16als115_5_nlo \u2705 ABMP16als115_5_nnlo \u2705 ABMP16als115_5_nnlo \u2705 ABMP16als116_5_nlo \u2705 ABMP16als116_5_nlo \u2705 ABMP16als116_5_nnlo \u2705 ABMP16als116_5_nnlo \u2705 ABMP16als117_5_nlo \u2705 ABMP16als117_5_nlo \u2705 ABMP16als117_5_nnlo \u2705 ABMP16als117_5_nnlo \u2705 ABMP16als118_5_nlo \u2705 ABMP16als118_5_nlo \u2705 ABMP16als118_5_nnlo \u2705 ABMP16als118_5_nnlo \u2705 ABMP16als119_5_nlo \u2705 ABMP16als119_5_nlo \u2705 ABMP16als119_5_nnlo \u2705 ABMP16als119_5_nnlo \u2705 ABMP16als120_5_nlo \u2705 ABMP16als120_5_nlo \u2705 ABMP16als120_5_nnlo \u2705 ABMP16als120_5_nnlo \u2705 ABMP16als121_5_nlo \u2705 ABMP16als121_5_nlo \u2705 ABMP16als122_5_nlo \u2705 ABMP16als122_5_nlo \u2705 ABMP16als123_5_nlo \u2705 ABMP16als123_5_nlo \u2705 ABMP16free_3_nlo \u2705 ABMP16free_3_nlo \u2705 ABMP16free_4_nlo \u2705 ABMP16free_4_nlo \u2705 ABMP16free_5_nlo \u2705 ABMP16free_5_nlo \u2705 CT09MC1 \u274c Items are not equal: ACTUAL: -0.012... CT09MC1 \u274c Items are not equal: ACTUAL: -0.012... CT09MC2 \u274c Items are not equal: ACTUAL: -1.961... CT09MC2 \u274c Items are not equal: ACTUAL: -1.961... CT09MCS \u274c Items are not equal: ACTUAL: -0.136... CT09MCS \u274c Items are not equal: ACTUAL: -0.136... CT10 \u274c Items are not equal: ACTUAL: -7.693... CT10 \u274c Items are not equal: ACTUAL: -0.077... CT10as \u274c Items are not equal: ACTUAL: -0.089... CT10as \u274c Items are not equal: ACTUAL: -0.089... CT10f3 \u274c Items are not equal: ACTUAL: -3.223... CT10f3 \u274c Items are not equal: ACTUAL: -3.223... CT10f4 \u274c Items are not equal: ACTUAL: -2.390... CT10f4 \u274c Items are not equal: ACTUAL: -2.390... CT10nlo \u274c Items are not equal: ACTUAL: -0.082... CT10nlo \u274c Items are not equal: ACTUAL: -0.077... CT10nlo_as_0112 \u274c Items are not equal: ACTUAL: -0.091... CT10nlo_as_0112 \u274c Items are not equal: ACTUAL: -0.091... CT10nlo_as_0113 \u274c Items are not equal: ACTUAL: -0.095... CT10nlo_as_0113 \u274c Items are not equal: ACTUAL: -0.095... CT10nlo_as_0114 \u274c Items are not equal: ACTUAL: -0.099... CT10nlo_as_0114 \u274c Items are not equal: ACTUAL: -0.099... CT10nlo_as_0115 \u274c Items are not equal: ACTUAL: -0.103... CT10nlo_as_0115 \u274c Items are not equal: ACTUAL: -0.103... CT10nlo_as_0116 \u274c Items are not equal: ACTUAL: -0.107... CT10nlo_as_0116 \u274c Items are not equal: ACTUAL: -0.107... CT10nlo_as_0117 \u274c Items are not equal: ACTUAL: -0.111... CT10nlo_as_0117 \u274c Items are not equal: ACTUAL: -0.111... CT10nlo_as_0118 \u274c Items are not equal: ACTUAL: -0.115... CT10nlo_as_0118 \u274c Items are not equal: ACTUAL: -0.115... CT10nlo_as_0119 \u274c Items are not equal: ACTUAL: -0.120... CT10nlo_as_0119 \u274c Items are not equal: ACTUAL: -0.120... CT10nlo_as_0120 \u274c Items are not equal: ACTUAL: -0.125... CT10nlo_as_0120 \u274c Items are not equal: ACTUAL: -0.125... CT10nlo_as_0121 \u274c Items are not equal: ACTUAL: -0.129... CT10nlo_as_0121 \u274c Items are not equal: ACTUAL: -0.129... CT10nlo_as_0122 \u274c Items are not equal: ACTUAL: -0.134... CT10nlo_as_0122 \u274c Items are not equal: ACTUAL: -0.134... CT10nlo_as_0123 \u274c Items are not equal: ACTUAL: -0.139... CT10nlo_as_0123 \u274c Items are not equal: ACTUAL: -0.139... CT10nlo_as_0124 \u274c Items are not equal: ACTUAL: -0.144... CT10nlo_as_0124 \u274c Items are not equal: ACTUAL: -0.144... CT10nlo_as_0125 \u274c Items are not equal: ACTUAL: -0.150... CT10nlo_as_0125 \u274c Items are not equal: ACTUAL: -0.150... CT10nlo_as_0126 \u274c Items are not equal: ACTUAL: -0.155... CT10nlo_as_0126 \u274c Items are not equal: ACTUAL: -0.155... CT10nlo_as_0127 \u274c Items are not equal: ACTUAL: -0.160... CT10nlo_as_0127 \u274c Items are not equal: ACTUAL: -0.160... CT10nlo_nf3 \u274c Items are not equal: ACTUAL: -1.609... CT10nlo_nf3 \u274c Items are not equal: ACTUAL: -1.609... CT10nlo_nf4 \u274c Items are not equal: ACTUAL: -2.414... CT10nlo_nf4 \u274c Items are not equal: ACTUAL: -2.414... CT10nnlo \u274c Items are not equal: ACTUAL: -0.001... CT10nnlo \u274c Items are not equal: ACTUAL: -0.001... CT10nnlo_as_0110 \u274c Items are not equal: ACTUAL: -0.001... CT10nnlo_as_0110 \u274c Items are not equal: ACTUAL: -0.001... CT10nnlo_as_0111 \u274c Items are not equal: ACTUAL: -0.001... CT10nnlo_as_0111 \u274c Items are not equal: ACTUAL: -0.001... CT10nnlo_as_0112 \u274c Items are not equal: ACTUAL: -0.001... CT10nnlo_as_0112 \u274c Items are not equal: ACTUAL: -0.001... CT10nnlo_as_0113 \u274c Items are not equal: ACTUAL: -0.001... CT10nnlo_as_0113 \u274c Items are not equal: ACTUAL: -0.001... CT10nnlo_as_0114 \u274c Items are not equal: ACTUAL: -0.001... CT10nnlo_as_0114 \u274c Items are not equal: ACTUAL: -0.001... CT10nnlo_as_0115 \u274c Items are not equal: ACTUAL: -0.001... CT10nnlo_as_0115 \u274c Items are not equal: ACTUAL: -0.001... CT10nnlo_as_0116 \u274c Items are not equal: ACTUAL: -0.001... CT10nnlo_as_0116 \u274c Items are not equal: ACTUAL: -0.001... CT10nnlo_as_0117 \u274c Items are not equal: ACTUAL: -0.001... CT10nnlo_as_0117 \u274c Items are not equal: ACTUAL: -0.001... CT10nnlo_as_0118 \u274c Items are not equal: ACTUAL: -0.001... CT10nnlo_as_0118 \u274c Items are not equal: ACTUAL: -0.001... CT10nnlo_as_0119 \u274c Items are not equal: ACTUAL: -0.001... CT10nnlo_as_0119 \u274c Items are not equal: ACTUAL: -0.001... CT10nnlo_as_0120 \u274c Items are not equal: ACTUAL: -0.001... CT10nnlo_as_0120 \u274c Items are not equal: ACTUAL: -0.001... CT10nnlo_as_0121 \u274c Items are not equal: ACTUAL: -0.001... CT10nnlo_as_0121 \u274c Items are not equal: ACTUAL: -0.001... CT10nnlo_as_0122 \u274c Items are not equal: ACTUAL: -0.000... CT10nnlo_as_0122 \u274c Items are not equal: ACTUAL: -0.000... CT10nnlo_as_0123 \u274c Items are not equal: ACTUAL: -0.000... CT10nnlo_as_0123 \u274c Items are not equal: ACTUAL: -0.000... CT10nnlo_as_0124 \u274c Items are not equal: ACTUAL: -0.000... CT10nnlo_as_0124 \u274c Items are not equal: ACTUAL: -0.000... CT10nnlo_as_0125 \u274c Items are not equal: ACTUAL: -0.000... CT10nnlo_as_0125 \u274c Items are not equal: ACTUAL: -0.000... CT10nnlo_as_0126 \u274c Items are not equal: ACTUAL: -0.000... CT10nnlo_as_0126 \u274c Items are not equal: ACTUAL: -0.000... CT10nnlo_as_0127 \u274c Items are not equal: ACTUAL: -0.000... CT10nnlo_as_0127 \u274c Items are not equal: ACTUAL: -0.000... CT10nnlo_as_0128 \u274c Items are not equal: ACTUAL: -0.000... CT10nnlo_as_0128 \u274c Items are not equal: ACTUAL: -0.000... CT10nnlo_as_0129 \u274c Items are not equal: ACTUAL: -7.094... CT10nnlo_as_0129 \u274c Items are not equal: ACTUAL: -7.094... CT10nnlo_as_0130 \u274c Items are not equal: ACTUAL: -2.418... CT10nnlo_as_0130 \u274c Items are not equal: ACTUAL: -2.418... CT10w \u274c Items are not equal: ACTUAL: -0.080... CT10w \u274c Items are not equal: ACTUAL: -0.080... CT10was \u274c Items are not equal: ACTUAL: -0.096... CT10was \u274c Items are not equal: ACTUAL: -0.077... CT10wf3 \u274c Items are not equal: ACTUAL: -1.421... CT10wf3 \u274c Items are not equal: ACTUAL: -1.421... CT10wf4 \u274c Items are not equal: ACTUAL: -1.514... CT10wf4 \u274c Items are not equal: ACTUAL: -1.514... CT10wnlo \u274c Items are not equal: ACTUAL: -0.081... CT10wnlo \u274c Items are not equal: ACTUAL: -0.080... CT10wnlo_as_0112 \u274c Items are not equal: ACTUAL: -0.092... CT10wnlo_as_0112 \u274c Items are not equal: ACTUAL: -0.092... CT10wnlo_as_0113 \u274c Items are not equal: ACTUAL: -0.095... CT10wnlo_as_0113 \u274c Items are not equal: ACTUAL: -0.095... CT10wnlo_as_0114 \u274c Items are not equal: ACTUAL: -0.099... CT10wnlo_as_0114 \u274c Items are not equal: ACTUAL: -0.099... CT10wnlo_as_0115 \u274c Items are not equal: ACTUAL: -0.103... CT10wnlo_as_0115 \u274c Items are not equal: ACTUAL: -0.103... CT10wnlo_as_0116 \u274c Items are not equal: ACTUAL: -0.108... CT10wnlo_as_0116 \u274c Items are not equal: ACTUAL: -0.108... CT10wnlo_as_0117 \u274c Items are not equal: ACTUAL: -0.112... CT10wnlo_as_0117 \u274c Items are not equal: ACTUAL: -0.112... CT10wnlo_as_0118 \u274c Items are not equal: ACTUAL: -0.116... CT10wnlo_as_0118 \u274c Items are not equal: ACTUAL: -0.116... CT10wnlo_as_0119 \u274c Items are not equal: ACTUAL: -0.121... CT10wnlo_as_0119 \u274c Items are not equal: ACTUAL: -0.121... CT10wnlo_as_0120 \u274c Items are not equal: ACTUAL: -0.126... CT10wnlo_as_0120 \u274c Items are not equal: ACTUAL: -0.126... CT10wnlo_as_0121 \u274c Items are not equal: ACTUAL: -0.130... CT10wnlo_as_0121 \u274c Items are not equal: ACTUAL: -0.130... CT10wnlo_as_0122 \u274c Items are not equal: ACTUAL: -0.135... CT10wnlo_as_0122 \u274c Items are not equal: ACTUAL: -0.135... CT10wnlo_as_0123 \u274c Items are not equal: ACTUAL: -0.140... CT10wnlo_as_0123 \u274c Items are not equal: ACTUAL: -0.140... CT10wnlo_as_0124 \u274c Items are not equal: ACTUAL: -0.145... CT10wnlo_as_0124 \u274c Items are not equal: ACTUAL: -0.145... CT10wnlo_as_0125 \u274c Items are not equal: ACTUAL: -0.150... CT10wnlo_as_0125 \u274c Items are not equal: ACTUAL: -0.150... CT10wnlo_as_0126 \u274c Items are not equal: ACTUAL: -0.155... CT10wnlo_as_0126 \u274c Items are not equal: ACTUAL: -0.155... CT10wnlo_as_0127 \u274c Items are not equal: ACTUAL: -0.161... CT10wnlo_as_0127 \u274c Items are not equal: ACTUAL: -0.161... CT10wnlo_nf3 \u274c Items are not equal: ACTUAL: -1.610... CT10wnlo_nf3 \u274c Items are not equal: ACTUAL: -2.583... CT10wnlo_nf4 \u274c Items are not equal: ACTUAL: -5.355... CT10wnlo_nf4 \u274c Items are not equal: ACTUAL: -5.355... CT14MC1nlo \u2705 CT14MC1nlo \u2705 CT14MC1nnlo \u2705 CT14MC1nnlo \u2705 CT14MC2nlo \u2705 CT14MC2nlo \u2705 CT14MC2nnlo \u2705 CT14MC2nnlo \u2705 CT14llo \u274c Items are not equal: ACTUAL: -0.016... CT14llo \u274c Items are not equal: ACTUAL: -0.016... CT14llo_NF3 \u274c Items are not equal: ACTUAL: -1.840... CT14llo_NF3 \u274c Items are not equal: ACTUAL: -1.840... CT14llo_NF4 \u274c Items are not equal: ACTUAL: -1.208... CT14llo_NF4 \u274c Items are not equal: ACTUAL: -1.208... CT14llo_NF6 \u274c Items are not equal: ACTUAL: -7.309... CT14llo_NF6 \u274c Items are not equal: ACTUAL: -7.309... CT14lo \u274c Items are not equal: ACTUAL: -0.011... CT14lo \u274c Items are not equal: ACTUAL: -0.011... CT14lo_NF3 \u274c Items are not equal: ACTUAL: -3.081... CT14lo_NF3 \u274c Items are not equal: ACTUAL: -3.081... CT14lo_NF4 \u274c Items are not equal: ACTUAL: -9.629... CT14lo_NF4 \u274c Items are not equal: ACTUAL: -9.629... CT14lo_NF6 \u274c Items are not equal: ACTUAL: -4.983... CT14lo_NF6 \u274c Items are not equal: ACTUAL: -4.983... CT14nlo \u274c Items are not equal: ACTUAL: -0.013... CT14nlo \u274c Items are not equal: ACTUAL: -0.013... CT14nlo_Ag108 \u274c Process failed: thread '' panicked at ne... CT14nlo_Al27 \u274c Process failed: thread '' panicked at ne... CT14nlo_Au197 \u274c Process failed: thread '' panicked at ne... CT14nlo_Be9 \u274c Process failed: thread '' panicked at ne... CT14nlo_C12 \u274c Process failed: thread '' panicked at ne... CT14nlo_Ca40 \u274c Process failed: thread '' panicked at ne... CT14nlo_Cu64 \u274c Process failed: thread '' panicked at ne... CT14nlo_Fe56 \u274c Process failed: thread '' panicked at ne... CT14nlo_He4 \u274c Process failed: thread '' panicked at ne... CT14nlo_Li6 \u274c Process failed: thread '' panicked at ne... CT14nlo_NF3 \u274c Items are not equal: ACTUAL: -9.131... CT14nlo_NF3 \u274c Items are not equal: ACTUAL: -9.131... CT14nlo_NF4 \u274c Items are not equal: ACTUAL: -8.834... CT14nlo_NF4 \u274c Items are not equal: ACTUAL: -8.834... CT14nlo_NF6 \u274c Items are not equal: ACTUAL: -4.300... CT14nlo_NF6 \u274c Items are not equal: ACTUAL: -4.300... CT14nlo_Pb208 \u274c Process failed: thread '' panicked at ne... CT14nlo_Pt195 \u274c Process failed: thread '' panicked at ne... CT14nlo_Sn119 \u274c Process failed: thread '' panicked at ne... CT14nlo_W184 \u274c Process failed: thread '' panicked at ne... CT14nlo_as_0111 \u274c Items are not equal: ACTUAL: -0.010... CT14nlo_as_0111 \u274c Items are not equal: ACTUAL: -0.010... CT14nlo_as_0112 \u274c Items are not equal: ACTUAL: -0.010... CT14nlo_as_0112 \u274c Items are not equal: ACTUAL: -0.010... CT14nlo_as_0113 \u274c Items are not equal: ACTUAL: -0.011... CT14nlo_as_0113 \u274c Items are not equal: ACTUAL: -0.011... CT14nlo_as_0114 \u274c Items are not equal: ACTUAL: -0.011... CT14nlo_as_0114 \u274c Items are not equal: ACTUAL: -0.011... CT14nlo_as_0115 \u274c Items are not equal: ACTUAL: -0.011... CT14nlo_as_0115 \u274c Items are not equal: ACTUAL: -0.011... CT14nlo_as_0116 \u274c Items are not equal: ACTUAL: -0.012... CT14nlo_as_0116 \u274c Items are not equal: ACTUAL: -0.012... CT14nlo_as_0117 \u274c Items are not equal: ACTUAL: -0.012... CT14nlo_as_0117 \u274c Items are not equal: ACTUAL: -0.012... CT14nlo_as_0118 \u274c Items are not equal: ACTUAL: -0.013... CT14nlo_as_0118 \u274c Items are not equal: ACTUAL: -0.013... CT14nlo_as_0119 \u274c Items are not equal: ACTUAL: -0.014... CT14nlo_as_0119 \u274c Items are not equal: ACTUAL: -0.014... CT14nlo_as_0120 \u274c Items are not equal: ACTUAL: -0.014... CT14nlo_as_0120 \u274c Items are not equal: ACTUAL: -0.014... CT14nlo_as_0121 \u274c Items are not equal: ACTUAL: -0.015... CT14nlo_as_0121 \u274c Items are not equal: ACTUAL: -0.015... CT14nlo_as_0122 \u274c Items are not equal: ACTUAL: -0.016... CT14nlo_as_0122 \u274c Items are not equal: ACTUAL: -0.016... CT14nlo_as_0123 \u274c Items are not equal: ACTUAL: -0.016... CT14nlo_as_0123 \u274c Items are not equal: ACTUAL: -0.016... CT14nnlo \u274c Items are not equal: ACTUAL: -0.001... CT14nnlo \u274c Items are not equal: ACTUAL: -0.001... CT14nnloIC \u274c Items are not equal: ACTUAL: -0.001... CT14nnloIC \u274c Items are not equal: ACTUAL: -0.001... CT14nnlo_NF3 \u274c Items are not equal: ACTUAL: -2.524... CT14nnlo_NF3 \u274c Items are not equal: ACTUAL: -2.524... CT14nnlo_NF4 \u274c Items are not equal: ACTUAL: -2.436... CT14nnlo_NF4 \u274c Items are not equal: ACTUAL: -2.436... CT14nnlo_NF6 \u274c Items are not equal: ACTUAL: -2.478... CT14nnlo_NF6 \u274c Items are not equal: ACTUAL: -2.478... CT14nnlo_as_0111 \u274c Items are not equal: ACTUAL: -0.001... CT14nnlo_as_0111 \u274c Items are not equal: ACTUAL: -0.001... CT14nnlo_as_0112 \u274c Items are not equal: ACTUAL: -0.001... CT14nnlo_as_0112 \u274c Items are not equal: ACTUAL: -0.001... CT14nnlo_as_0113 \u274c Items are not equal: ACTUAL: -0.001... CT14nnlo_as_0113 \u274c Items are not equal: ACTUAL: -0.001... CT14nnlo_as_0114 \u274c Items are not equal: ACTUAL: -0.001... CT14nnlo_as_0114 \u274c Items are not equal: ACTUAL: -0.001... CT14nnlo_as_0115 \u274c Items are not equal: ACTUAL: -0.001... CT14nnlo_as_0115 \u274c Items are not equal: ACTUAL: -0.001... CT14nnlo_as_0116 \u274c Items are not equal: ACTUAL: -0.001... CT14nnlo_as_0116 \u274c Items are not equal: ACTUAL: -0.001... CT14nnlo_as_0117 \u274c Items are not equal: ACTUAL: -0.001... CT14nnlo_as_0117 \u274c Items are not equal: ACTUAL: -0.001... CT14nnlo_as_0118 \u274c Items are not equal: ACTUAL: -0.001... CT14nnlo_as_0118 \u274c Items are not equal: ACTUAL: -0.001... CT14nnlo_as_0119 \u274c Items are not equal: ACTUAL: -0.001... CT14nnlo_as_0119 \u274c Items are not equal: ACTUAL: -0.001... CT14nnlo_as_0120 \u274c Items are not equal: ACTUAL: -0.001... CT14nnlo_as_0120 \u274c Items are not equal: ACTUAL: -0.001... CT14nnlo_as_0121 \u274c Items are not equal: ACTUAL: -0.001... CT14nnlo_as_0121 \u274c Items are not equal: ACTUAL: -0.001... CT14nnlo_as_0122 \u274c Items are not equal: ACTUAL: -0.001... CT14nnlo_as_0122 \u274c Items are not equal: ACTUAL: -0.001... CT14nnlo_as_0123 \u274c Items are not equal: ACTUAL: -0.000... CT14nnlo_as_0123 \u274c Items are not equal: ACTUAL: -0.000... CT14qed_inc_neutron \u274c Process failed: thread '' panicked at ne... CT14qed_inc_neutron \u274c Process failed: thread '' panicked at ne... CT14qed_inc_proton \u274c Process failed: thread '' panicked at ne... CT14qed_inc_proton \u274c Process failed: thread '' panicked at ne... CT14qed_neutron \u274c Process failed: thread '' panicked at ne... CT14qed_neutron \u274c Process failed: thread '' panicked at ne... CT14qed_proton \u274c Process failed: thread '' panicked at ne... CT14qed_proton \u274c Process failed: thread '' panicked at ne... CT18ANLO \u2705 CT18ANLO \u2705 CT18ANLO_as_0110 \u2705 CT18ANLO_as_0110 \u2705 CT18ANLO_as_0111 \u2705 CT18ANLO_as_0111 \u2705 CT18ANLO_as_0112 \u2705 CT18ANLO_as_0112 \u2705 CT18ANLO_as_0113 \u2705 CT18ANLO_as_0113 \u2705 CT18ANLO_as_0114 \u2705 CT18ANLO_as_0114 \u2705 CT18ANLO_as_0115 \u2705 CT18ANLO_as_0115 \u2705 CT18ANLO_as_0116 \u2705 CT18ANLO_as_0116 \u2705 CT18ANLO_as_0117 \u2705 CT18ANLO_as_0117 \u2705 CT18ANLO_as_0118 \u2705 CT18ANLO_as_0118 \u2705 CT18ANLO_as_0119 \u2705 CT18ANLO_as_0119 \u2705 CT18ANLO_as_0120 \u2705 CT18ANLO_as_0120 \u2705 CT18ANLO_as_0121 \u2705 CT18ANLO_as_0121 \u2705 CT18ANLO_as_0122 \u2705 CT18ANLO_as_0122 \u2705 CT18ANLO_as_0123 \u2705 CT18ANLO_as_0123 \u2705 CT18ANLO_as_0124 \u2705 CT18ANLO_as_0124 \u2705 CT18ANNLO \u2705 CT18ANNLO \u2705 CT18ANNLO_as_0110 \u2705 CT18ANNLO_as_0110 \u2705 CT18ANNLO_as_0111 \u2705 CT18ANNLO_as_0111 \u2705 CT18ANNLO_as_0112 \u2705 CT18ANNLO_as_0112 \u2705 CT18ANNLO_as_0113 \u2705 CT18ANNLO_as_0113 \u2705 CT18ANNLO_as_0114 \u2705 CT18ANNLO_as_0114 \u2705 CT18ANNLO_as_0115 \u2705 CT18ANNLO_as_0115 \u2705 CT18ANNLO_as_0116 \u2705 CT18ANNLO_as_0116 \u2705 CT18ANNLO_as_0117 \u2705 CT18ANNLO_as_0117 \u2705 CT18ANNLO_as_0118 \u2705 CT18ANNLO_as_0118 \u2705 CT18ANNLO_as_0119 \u2705 CT18ANNLO_as_0119 \u2705 CT18ANNLO_as_0120 \u2705 CT18ANNLO_as_0120 \u2705 CT18ANNLO_as_0121 \u2705 CT18ANNLO_as_0121 \u2705 CT18ANNLO_as_0122 \u2705 CT18ANNLO_as_0122 \u2705 CT18ANNLO_as_0123 \u2705 CT18ANNLO_as_0123 \u2705 CT18ANNLO_as_0124 \u2705 CT18ANNLO_as_0124 \u2705 CT18Anlo_Ag108 \u274c Process failed: thread '' panicked at ne... CT18Anlo_Al27 \u274c Process failed: thread '' panicked at ne... CT18Anlo_Ar40 \u274c Process failed: thread '' panicked at ne... CT18Anlo_Au197 \u274c Process failed: thread '' panicked at ne... CT18Anlo_Be9 \u274c Process failed: thread '' panicked at ne... CT18Anlo_C12 \u274c Process failed: thread '' panicked at ne... CT18Anlo_Ca40 \u274c Process failed: thread '' panicked at ne... CT18Anlo_Cu64 \u274c Process failed: thread '' panicked at ne... CT18Anlo_Fe56 \u274c Process failed: thread '' panicked at ne... CT18Anlo_He3 \u274c Process failed: thread '' panicked at ne... CT18Anlo_He4 \u274c Process failed: thread '' panicked at ne... CT18Anlo_Li6 \u274c Process failed: thread '' panicked at ne... CT18Anlo_O16 \u274c Process failed: thread '' panicked at ne... CT18Anlo_Pb208 \u274c Process failed: thread '' panicked at ne... CT18Anlo_Pt195 \u274c Process failed: thread '' panicked at ne... CT18Anlo_Sn119 \u274c Process failed: thread '' panicked at ne... CT18Anlo_W184 \u274c Process failed: thread '' panicked at ne... CT18FC \u2705 CT18FC \u2705 CT18LO \u2705 CT18LO \u2705 CT18NLO \u2705 CT18NLO \u2705 CT18NLO_NF3 \u2705 CT18NLO_NF3 \u2705 CT18NLO_NF4 \u2705 CT18NLO_NF4 \u2705 CT18NLO_NF6 \u2705 CT18NLO_NF6 \u2705 CT18NLO_as_0110 \u2705 CT18NLO_as_0110 \u2705 CT18NLO_as_0111 \u2705 CT18NLO_as_0111 \u2705 CT18NLO_as_0112 \u2705 CT18NLO_as_0112 \u2705 CT18NLO_as_0113 \u2705 CT18NLO_as_0113 \u2705 CT18NLO_as_0114 \u2705 CT18NLO_as_0114 \u2705 CT18NLO_as_0115 \u2705 CT18NLO_as_0115 \u2705 CT18NLO_as_0116 \u2705 CT18NLO_as_0116 \u2705 CT18NLO_as_0117 \u2705 CT18NLO_as_0117 \u2705 CT18NLO_as_0118 \u2705 CT18NLO_as_0118 \u2705 CT18NLO_as_0119 \u2705 CT18NLO_as_0119 \u2705 CT18NLO_as_0120 \u2705 CT18NLO_as_0120 \u2705 CT18NLO_as_0121 \u2705 CT18NLO_as_0121 \u2705 CT18NLO_as_0122 \u2705 CT18NLO_as_0122 \u2705 CT18NLO_as_0123 \u2705 CT18NLO_as_0123 \u2705 CT18NLO_as_0124 \u2705 CT18NLO_as_0124 \u2705 CT18NNLO \u2705 CT18NNLO \u2705 CT18NNLO_NF3 \u2705 CT18NNLO_NF3 \u2705 CT18NNLO_NF4 \u2705 CT18NNLO_NF4 \u2705 CT18NNLO_NF6 \u2705 CT18NNLO_NF6 \u2705 CT18NNLO_as_0110 \u2705 CT18NNLO_as_0110 \u2705 CT18NNLO_as_0111 \u2705 CT18NNLO_as_0111 \u2705 CT18NNLO_as_0112 \u2705 CT18NNLO_as_0112 \u2705 CT18NNLO_as_0113 \u2705 CT18NNLO_as_0113 \u2705 CT18NNLO_as_0114 \u2705 CT18NNLO_as_0114 \u2705 CT18NNLO_as_0115 \u2705 CT18NNLO_as_0115 \u2705 CT18NNLO_as_0116 \u2705 CT18NNLO_as_0116 \u2705 CT18NNLO_as_0117 \u2705 CT18NNLO_as_0117 \u2705 CT18NNLO_as_0118 \u2705 CT18NNLO_as_0118 \u2705 CT18NNLO_as_0119 \u2705 CT18NNLO_as_0119 \u2705 CT18NNLO_as_0120 \u2705 CT18NNLO_as_0120 \u2705 CT18NNLO_as_0121 \u2705 CT18NNLO_as_0121 \u2705 CT18NNLO_as_0122 \u2705 CT18NNLO_as_0122 \u2705 CT18NNLO_as_0123 \u2705 CT18NNLO_as_0123 \u2705 CT18NNLO_as_0124 \u2705 CT18NNLO_as_0124 \u2705 CT18XNLO \u2705 CT18XNLO \u2705 CT18XNLO_as_0110 \u2705 CT18XNLO_as_0110 \u2705 CT18XNLO_as_0111 \u2705 CT18XNLO_as_0111 \u2705 CT18XNLO_as_0112 \u2705 CT18XNLO_as_0112 \u2705 CT18XNLO_as_0113 \u2705 CT18XNLO_as_0113 \u2705 CT18XNLO_as_0114 \u2705 CT18XNLO_as_0114 \u2705 CT18XNLO_as_0115 \u2705 CT18XNLO_as_0115 \u2705 CT18XNLO_as_0116 \u2705 CT18XNLO_as_0116 \u2705 CT18XNLO_as_0117 \u2705 CT18XNLO_as_0117 \u2705 CT18XNLO_as_0118 \u2705 CT18XNLO_as_0118 \u2705 CT18XNLO_as_0119 \u2705 CT18XNLO_as_0119 \u2705 CT18XNLO_as_0120 \u2705 CT18XNLO_as_0120 \u2705 CT18XNLO_as_0121 \u2705 CT18XNLO_as_0121 \u2705 CT18XNLO_as_0122 \u2705 CT18XNLO_as_0122 \u2705 CT18XNLO_as_0123 \u2705 CT18XNLO_as_0123 \u2705 CT18XNLO_as_0124 \u2705 CT18XNLO_as_0124 \u2705 CT18XNNLO \u2705 CT18XNNLO \u2705 CT18XNNLO_as_0110 \u2705 CT18XNNLO_as_0110 \u2705 CT18XNNLO_as_0111 \u2705 CT18XNNLO_as_0111 \u2705 CT18XNNLO_as_0112 \u2705 CT18XNNLO_as_0112 \u2705 CT18XNNLO_as_0113 \u2705 CT18XNNLO_as_0113 \u2705 CT18XNNLO_as_0114 \u2705 CT18XNNLO_as_0114 \u2705 CT18XNNLO_as_0115 \u2705 CT18XNNLO_as_0115 \u2705 CT18XNNLO_as_0116 \u2705 CT18XNNLO_as_0116 \u2705 CT18XNNLO_as_0117 \u2705 CT18XNNLO_as_0117 \u2705 CT18XNNLO_as_0118 \u2705 CT18XNNLO_as_0118 \u2705 CT18XNNLO_as_0119 \u2705 CT18XNNLO_as_0119 \u2705 CT18XNNLO_as_0120 \u2705 CT18XNNLO_as_0120 \u2705 CT18XNNLO_as_0121 \u2705 CT18XNNLO_as_0121 \u2705 CT18XNNLO_as_0122 \u2705 CT18XNNLO_as_0122 \u2705 CT18XNNLO_as_0123 \u2705 CT18XNNLO_as_0123 \u2705 CT18XNNLO_as_0124 \u2705 CT18XNNLO_as_0124 \u2705 CT18ZNLO \u2705 CT18ZNLO \u2705 CT18ZNLO_NF3 \u2705 CT18ZNLO_NF3 \u2705 CT18ZNLO_NF4 \u2705 CT18ZNLO_NF4 \u2705 CT18ZNLO_NF6 \u2705 CT18ZNLO_NF6 \u2705 CT18ZNLO_as_0110 \u2705 CT18ZNLO_as_0110 \u2705 CT18ZNLO_as_0111 \u2705 CT18ZNLO_as_0111 \u2705 CT18ZNLO_as_0112 \u2705 CT18ZNLO_as_0112 \u2705 CT18ZNLO_as_0113 \u2705 CT18ZNLO_as_0113 \u2705 CT18ZNLO_as_0114 \u2705 CT18ZNLO_as_0114 \u2705 CT18ZNLO_as_0115 \u2705 CT18ZNLO_as_0115 \u2705 CT18ZNLO_as_0116 \u2705 CT18ZNLO_as_0116 \u2705 CT18ZNLO_as_0117 \u2705 CT18ZNLO_as_0117 \u2705 CT18ZNLO_as_0118 \u2705 CT18ZNLO_as_0118 \u2705 CT18ZNLO_as_0119 \u2705 CT18ZNLO_as_0119 \u2705 CT18ZNLO_as_0120 \u2705 CT18ZNLO_as_0120 \u2705 CT18ZNLO_as_0121 \u2705 CT18ZNLO_as_0121 \u2705 CT18ZNLO_as_0122 \u2705 CT18ZNLO_as_0122 \u2705 CT18ZNLO_as_0123 \u2705 CT18ZNLO_as_0123 \u2705 CT18ZNLO_as_0124 \u2705 CT18ZNLO_as_0124 \u2705 CT18ZNNLO \u2705 CT18ZNNLO \u2705 CT18ZNNLO_NF3 \u2705 CT18ZNNLO_NF3 \u2705 CT18ZNNLO_NF4 \u2705 CT18ZNNLO_NF4 \u2705 CT18ZNNLO_NF6 \u2705 CT18ZNNLO_NF6 \u2705 CT18ZNNLO_as_0110 \u2705 CT18ZNNLO_as_0110 \u2705 CT18ZNNLO_as_0111 \u2705 CT18ZNNLO_as_0111 \u2705 CT18ZNNLO_as_0112 \u2705 CT18ZNNLO_as_0112 \u2705 CT18ZNNLO_as_0113 \u2705 CT18ZNNLO_as_0113 \u2705 CT18ZNNLO_as_0114 \u2705 CT18ZNNLO_as_0114 \u2705 CT18ZNNLO_as_0115 \u2705 CT18ZNNLO_as_0115 \u2705 CT18ZNNLO_as_0116 \u2705 CT18ZNNLO_as_0116 \u2705 CT18ZNNLO_as_0117 \u2705 CT18ZNNLO_as_0117 \u2705 CT18ZNNLO_as_0118 \u2705 CT18ZNNLO_as_0118 \u2705 CT18ZNNLO_as_0119 \u2705 CT18ZNNLO_as_0119 \u2705 CT18ZNNLO_as_0120 \u2705 CT18ZNNLO_as_0120 \u2705 CT18ZNNLO_as_0121 \u2705 CT18ZNNLO_as_0121 \u2705 CT18ZNNLO_as_0122 \u2705 CT18ZNNLO_as_0122 \u2705 CT18ZNNLO_as_0123 \u2705 CT18ZNNLO_as_0123 \u2705 CT18ZNNLO_as_0124 \u2705 CT18ZNNLO_as_0124 \u2705 CT18qed_neutron \u2705 CT18qed_neutron \u2705 CT18qed_neutron_elastic \u2705 CT18qed_neutron_elastic \u2705 CT18qed_neutron_inelastic \u2705 CT18qed_neutron_inelastic \u2705 CT18qed_proton \u2705 CT18qed_proton \u2705 CT18qed_proton_elastic \u2705 CT18qed_proton_elastic \u2705 CT18qed_proton_inelastic \u2705 CT18qed_proton_inelastic \u2705 EPPS16_B_90CL_Au_hess \u2705 EPPS16_B_90CL_Au_hess \u2705 EPPS16_B_90CL_Pb_hess \u2705 EPPS16_B_90CL_Pb_hess \u2705 EPPS16_B_c_90CL_Au_hess \u2705 EPPS16_B_c_90CL_Au_hess \u2705 EPPS16_B_c_90CL_Pb_hess \u2705 EPPS16_B_c_90CL_Pb_hess \u2705 EPPS16_B_d_90CL_Au_hess \u2705 EPPS16_B_d_90CL_Au_hess \u2705 EPPS16_B_d_90CL_Pb_hess \u2705 EPPS16_B_d_90CL_Pb_hess \u2705 EPPS16_B_u_90CL_Au_hess \u2705 EPPS16_B_u_90CL_Au_hess \u2705 EPPS16_B_u_90CL_Pb_hess \u2705 EPPS16_B_u_90CL_Pb_hess \u2705 EPPS16_D_90CL_Au_hess \u2705 EPPS16_D_90CL_Au_hess \u2705 EPPS16_D_90CL_Pb_hess \u2705 EPPS16_D_90CL_Pb_hess \u2705 EPPS16_D_c_90CL_Au_hess \u2705 EPPS16_D_c_90CL_Au_hess \u2705 EPPS16_D_c_90CL_Pb_hess \u2705 EPPS16_D_c_90CL_Pb_hess \u2705 EPPS16_D_d_90CL_Au_hess \u2705 EPPS16_D_d_90CL_Au_hess \u2705 EPPS16_D_d_90CL_Pb_hess \u2705 EPPS16_D_d_90CL_Pb_hess \u2705 EPPS16_D_u_90CL_Au_hess \u2705 EPPS16_D_u_90CL_Au_hess \u2705 EPPS16_D_u_90CL_Pb_hess \u2705 EPPS16_D_u_90CL_Pb_hess \u2705 EPPS16_Jpsi_90CL_Au_hess \u2705 EPPS16_Jpsi_90CL_Au_hess \u2705 EPPS16_Jpsi_90CL_Pb_hess \u2705 EPPS16_Jpsi_90CL_Pb_hess \u2705 EPPS16_Jpsi_c_90CL_Au_hess \u2705 EPPS16_Jpsi_c_90CL_Au_hess \u2705 EPPS16_Jpsi_c_90CL_Pb_hess \u2705 EPPS16_Jpsi_c_90CL_Pb_hess \u2705 EPPS16_Jpsi_d_90CL_Au_hess \u2705 EPPS16_Jpsi_d_90CL_Au_hess \u2705 EPPS16_Jpsi_d_90CL_Pb_hess \u2705 EPPS16_Jpsi_d_90CL_Pb_hess \u2705 EPPS16_Jpsi_u_90CL_Au_hess \u2705 EPPS16_Jpsi_u_90CL_Au_hess \u2705 EPPS16_Jpsi_u_90CL_Pb_hess \u2705 EPPS16_Jpsi_u_90CL_Pb_hess \u2705 EPPS16nlo_CT14nlo_Ag108 \u2705 EPPS16nlo_CT14nlo_Ag108 \u2705 EPPS16nlo_CT14nlo_Al27 \u2705 EPPS16nlo_CT14nlo_Al27 \u2705 EPPS16nlo_CT14nlo_Au197 \u2705 EPPS16nlo_CT14nlo_Au197 \u2705 EPPS16nlo_CT14nlo_Be9 \u2705 EPPS16nlo_CT14nlo_Be9 \u2705 EPPS16nlo_CT14nlo_C12 \u2705 EPPS16nlo_CT14nlo_C12 \u2705 EPPS16nlo_CT14nlo_Ca40 \u2705 EPPS16nlo_CT14nlo_Ca40 \u2705 EPPS16nlo_CT14nlo_Cu64 \u2705 EPPS16nlo_CT14nlo_Cu64 \u2705 EPPS16nlo_CT14nlo_Fe56 \u2705 EPPS16nlo_CT14nlo_Fe56 \u2705 EPPS16nlo_CT14nlo_He4 \u2705 EPPS16nlo_CT14nlo_He4 \u2705 EPPS16nlo_CT14nlo_Li6 \u2705 EPPS16nlo_CT14nlo_Li6 \u2705 EPPS16nlo_CT14nlo_Pb208 \u2705 EPPS16nlo_CT14nlo_Pb208 \u2705 EPPS16nlo_CT14nlo_Pt195 \u2705 EPPS16nlo_CT14nlo_Pt195 \u2705 EPPS16nlo_CT14nlo_Sn119 \u2705 EPPS16nlo_CT14nlo_Sn119 \u2705 EPPS16nlo_CT14nlo_W184 \u2705 EPPS16nlo_CT14nlo_W184 \u2705 EPPS21nlo_CT18Anlo_Ag108 \u2705 EPPS21nlo_CT18Anlo_Ag108 \u2705 EPPS21nlo_CT18Anlo_Al27 \u2705 EPPS21nlo_CT18Anlo_Al27 \u2705 EPPS21nlo_CT18Anlo_Ar40 \u2705 EPPS21nlo_CT18Anlo_Ar40 \u2705 EPPS21nlo_CT18Anlo_Au197 \u2705 EPPS21nlo_CT18Anlo_Au197 \u2705 EPPS21nlo_CT18Anlo_Be9 \u2705 EPPS21nlo_CT18Anlo_Be9 \u2705 EPPS21nlo_CT18Anlo_C12 \u2705 EPPS21nlo_CT18Anlo_C12 \u2705 EPPS21nlo_CT18Anlo_Ca40 \u2705 EPPS21nlo_CT18Anlo_Ca40 \u2705 EPPS21nlo_CT18Anlo_Cu64 \u2705 EPPS21nlo_CT18Anlo_Cu64 \u2705 EPPS21nlo_CT18Anlo_Fe56 \u2705 EPPS21nlo_CT18Anlo_Fe56 \u2705 EPPS21nlo_CT18Anlo_He3 \u2705 EPPS21nlo_CT18Anlo_He3 \u2705 EPPS21nlo_CT18Anlo_He4 \u2705 EPPS21nlo_CT18Anlo_He4 \u2705 EPPS21nlo_CT18Anlo_Li6 \u2705 EPPS21nlo_CT18Anlo_Li6 \u2705 EPPS21nlo_CT18Anlo_O16 \u2705 EPPS21nlo_CT18Anlo_O16 \u2705 EPPS21nlo_CT18Anlo_Pb208 \u2705 EPPS21nlo_CT18Anlo_Pb208 \u2705 EPPS21nlo_CT18Anlo_Pt195 \u2705 EPPS21nlo_CT18Anlo_Pt195 \u2705 EPPS21nlo_CT18Anlo_Sn119 \u2705 EPPS21nlo_CT18Anlo_Sn119 \u2705 EPPS21nlo_CT18Anlo_W184 \u2705 EPPS21nlo_CT18Anlo_W184 \u2705 MMHT2014lo68cl \u2705 MMHT2014lo68cl \u2705 MMHT2014lo_asmzsmallrange \u2705 MMHT2014lo_asmzsmallrange \u2705 MMHT2014nlo68cl \u2705 MMHT2014nlo68cl \u2705 MMHT2014nlo68cl_nf3 \u2705 MMHT2014nlo68cl_nf3 \u2705 MMHT2014nlo68cl_nf4 \u2705 MMHT2014nlo68cl_nf4 \u2705 MMHT2014nlo68cl_nf4as5 \u2705 MMHT2014nlo68cl_nf4as5 \u2705 MMHT2014nlo68clas118 \u2705 MMHT2014nlo68clas118 \u2705 MMHT2014nlo68clas118_nf3 \u2705 MMHT2014nlo68clas118_nf3 \u2705 MMHT2014nlo68clas118_nf4 \u2705 MMHT2014nlo68clas118_nf4 \u2705 MMHT2014nlo68clas118_nf4as5 \u2705 MMHT2014nlo68clas118_nf4as5 \u2705 MMHT2014nlo_asmzlargerange \u2705 MMHT2014nlo_asmzlargerange \u2705 MMHT2014nlo_asmzsmallrange \u2705 MMHT2014nlo_asmzsmallrange \u2705 MMHT2014nlo_asmzsmallrange_nf3 \u2705 MMHT2014nlo_asmzsmallrange_nf3 \u2705 MMHT2014nlo_asmzsmallrange_nf4 \u2705 MMHT2014nlo_asmzsmallrange_nf4 \u2705 MMHT2014nlo_mbrange_nf3 \u2705 MMHT2014nlo_mbrange_nf3 \u2705 MMHT2014nlo_mbrange_nf4 \u2705 MMHT2014nlo_mbrange_nf4 \u2705 MMHT2014nlo_mbrange_nf5 \u2705 MMHT2014nlo_mbrange_nf5 \u2705 MMHT2014nlo_mcrange_nf3 \u274c Process failed: thread '' panicked at ne... MMHT2014nlo_mcrange_nf3 \u2705 MMHT2014nlo_mcrange_nf4 \u2705 MMHT2014nlo_mcrange_nf4 \u2705 MMHT2014nlo_mcrange_nf5 \u2705 MMHT2014nlo_mcrange_nf5 \u2705 MMHT2014nloas118_mbrange_nf3 \u2705 MMHT2014nloas118_mbrange_nf3 \u2705 MMHT2014nloas118_mbrange_nf4 \u2705 MMHT2014nloas118_mbrange_nf4 \u2705 MMHT2014nloas118_mbrange_nf5 \u2705 MMHT2014nloas118_mbrange_nf5 \u2705 MMHT2014nloas118_mcrange_nf3 \u274c Process failed: thread '' panicked at ne... MMHT2014nloas118_mcrange_nf3 \u274c Process failed: thread '' panicked at ne... MMHT2014nloas118_mcrange_nf4 \u274c Process failed: thread '' panicked at ne... MMHT2014nloas118_mcrange_nf4 \u274c Process failed: thread '' panicked at ne... MMHT2014nloas118_mcrange_nf5 \u274c Process failed: thread '' panicked at ne... MMHT2014nloas118_mcrange_nf5 \u274c Process failed: thread '' panicked at ne... MMHT2014nnlo68cl \u2705 MMHT2014nnlo68cl \u2705 MMHT2014nnlo68cl_nf3 \u2705 MMHT2014nnlo68cl_nf3 \u2705 MMHT2014nnlo68cl_nf4 \u2705 MMHT2014nnlo68cl_nf4 \u2705 MMHT2014nnlo68cl_nf4as5 \u2705 MMHT2014nnlo68cl_nf4as5 \u2705 MMHT2014nnlo_asmzlargerange \u2705 MMHT2014nnlo_asmzlargerange \u2705 MMHT2014nnlo_asmzsmallrange \u2705 MMHT2014nnlo_asmzsmallrange \u2705 MMHT2014nnlo_asmzsmallrange_nf3 \u2705 MMHT2014nnlo_asmzsmallrange_nf3 \u2705 MMHT2014nnlo_asmzsmallrange_nf4 \u2705 MMHT2014nnlo_asmzsmallrange_nf4 \u2705 MMHT2014nnlo_mbrange_nf3 \u2705 MMHT2014nnlo_mbrange_nf3 \u2705 MMHT2014nnlo_mbrange_nf4 \u2705 MMHT2014nnlo_mbrange_nf4 \u2705 MMHT2014nnlo_mbrange_nf5 \u2705 MMHT2014nnlo_mbrange_nf5 \u2705 MMHT2014nnlo_mcrange_nf3 \u2705 MMHT2014nnlo_mcrange_nf3 \u2705 MMHT2014nnlo_mcrange_nf4 \u274c Process failed: thread '' panicked at ne... MMHT2014nnlo_mcrange_nf4 \u2705 MMHT2014nnlo_mcrange_nf5 \u2705 MMHT2014nnlo_mcrange_nf5 \u274c Process failed: thread '' panicked at ne... MMHT2015qed_nlo \u2705 MMHT2015qed_nlo \u2705 MMHT2015qed_nlo_elastic \u2705 MMHT2015qed_nlo_elastic \u2705 MMHT2015qed_nlo_inelastic \u2705 MMHT2015qed_nlo_inelastic \u2705 MMHT2015qed_nnlo \u2705 MMHT2015qed_nnlo \u2705 MMHT2015qed_nnlo_elastic \u2705 MMHT2015qed_nnlo_elastic \u2705 MMHT2015qed_nnlo_inelastic \u2705 MMHT2015qed_nnlo_inelastic \u2705 MSHT20an3lo_as118 \u2705 MSHT20an3lo_as118 \u2705 MSHT20an3lo_as118_Kcorr \u2705 MSHT20an3lo_as118_Kcorr \u2705 MSHT20an3lo_as_smallrange \u2705 MSHT20an3lo_as_smallrange \u2705 MSHT20lo_as130 \u2705 MSHT20lo_as130 \u2705 MSHT20nlo_as118 \u2705 MSHT20nlo_as118 \u2705 MSHT20nlo_as120 \u2705 MSHT20nlo_as120 \u2705 MSHT20nlo_as120_mbrange_nf3 \u274c Process failed: thread '' panicked at ne... MSHT20nlo_as120_mbrange_nf3 \u274c Process failed: thread '' panicked at ne... MSHT20nlo_as120_mbrange_nf4 \u2705 MSHT20nlo_as120_mbrange_nf4 \u2705 MSHT20nlo_as120_mbrange_nf5 \u2705 MSHT20nlo_as120_mbrange_nf5 \u2705 MSHT20nlo_as120_mcrange_nf3 \u2705 MSHT20nlo_as120_mcrange_nf3 \u2705 MSHT20nlo_as120_mcrange_nf4 \u2705 MSHT20nlo_as120_mcrange_nf4 \u2705 MSHT20nlo_as120_mcrange_nf5 \u2705 MSHT20nlo_as120_mcrange_nf5 \u2705 MSHT20nlo_as120_nf3 \u2705 MSHT20nlo_as120_nf3 \u2705 MSHT20nlo_as120_nf4 \u2705 MSHT20nlo_as120_nf4 \u2705 MSHT20nlo_as_largerange \u2705 MSHT20nlo_as_largerange \u2705 MSHT20nlo_as_smallrange \u2705 MSHT20nlo_as_smallrange \u2705 MSHT20nlo_as_smallrange_nf3 \u2705 MSHT20nlo_as_smallrange_nf3 \u2705 MSHT20nlo_as_smallrange_nf4 \u2705 MSHT20nlo_as_smallrange_nf4 \u2705 MSHT20nlo_mbrange_nf3 \u2705 MSHT20nlo_mbrange_nf3 \u2705 MSHT20nlo_mbrange_nf4 \u2705 MSHT20nlo_mbrange_nf4 \u2705 MSHT20nlo_mbrange_nf5 \u2705 MSHT20nlo_mbrange_nf5 \u2705 MSHT20nlo_mcrange_nf3 \u2705 MSHT20nlo_mcrange_nf3 \u2705 MSHT20nlo_mcrange_nf4 \u2705 MSHT20nlo_mcrange_nf4 \u2705 MSHT20nlo_mcrange_nf5 \u2705 MSHT20nlo_mcrange_nf5 \u2705 MSHT20nlo_nf3 \u2705 MSHT20nlo_nf3 \u2705 MSHT20nlo_nf4 \u2705 MSHT20nlo_nf4 \u2705 MSHT20nnlo_as118 \u2705 MSHT20nnlo_as118 \u2705 MSHT20nnlo_as_largerange \u2705 MSHT20nnlo_as_largerange \u2705 MSHT20nnlo_as_smallrange \u2705 MSHT20nnlo_as_smallrange \u2705 MSHT20nnlo_as_smallrange_nf3 \u2705 MSHT20nnlo_as_smallrange_nf3 \u2705 MSHT20nnlo_as_smallrange_nf4 \u2705 MSHT20nnlo_as_smallrange_nf4 \u2705 MSHT20nnlo_mbrange_nf3 \u2705 MSHT20nnlo_mbrange_nf3 \u2705 MSHT20nnlo_mbrange_nf4 \u2705 MSHT20nnlo_mbrange_nf4 \u2705 MSHT20nnlo_mbrange_nf5 \u2705 MSHT20nnlo_mbrange_nf5 \u2705 MSHT20nnlo_mcrange_nf3 \u2705 MSHT20nnlo_mcrange_nf3 \u2705 MSHT20nnlo_mcrange_nf4 \u2705 MSHT20nnlo_mcrange_nf4 \u2705 MSHT20nnlo_mcrange_nf5 \u2705 MSHT20nnlo_mcrange_nf5 \u2705 MSHT20nnlo_nf3 \u2705 MSHT20nnlo_nf3 \u2705 MSHT20nnlo_nf4 \u2705 MSHT20nnlo_nf4 \u2705 MSHT20qed_an3lo \u2705 MSHT20qed_an3lo \u2705 MSHT20qed_an3lo_elastic \u2705 MSHT20qed_an3lo_elastic \u2705 MSHT20qed_an3lo_inelastic \u2705 MSHT20qed_an3lo_inelastic \u2705 MSHT20qed_lo \u2705 MSHT20qed_lo \u2705 MSHT20qed_lo_elastic \u2705 MSHT20qed_lo_elastic \u2705 MSHT20qed_lo_inelastic \u2705 MSHT20qed_lo_inelastic \u2705 MSHT20qed_nnlo \u2705 MSHT20qed_nnlo \u2705 MSHT20qed_nnlo_elastic \u2705 MSHT20qed_nnlo_elastic \u2705 MSHT20qed_nnlo_inelastic \u2705 MSHT20qed_nnlo_inelastic \u2705 MSHT20qed_nnlo_neutron \u2705 MSHT20qed_nnlo_neutron \u2705 MSHT20qed_nnlo_neutron_elastic \u2705 MSHT20qed_nnlo_neutron_elastic \u2705 MSHT20qed_nnlo_neutron_inelastic \u2705 MSHT20qed_nnlo_neutron_inelastic \u2705 MSTW2008CPdeutnlo68cl \u2705 MSTW2008CPdeutnlo68cl \u2705 MSTW2008CPdeutnnlo68cl \u2705 MSTW2008CPdeutnnlo68cl \u2705 MSTW2008lo68cl \u274c Items are not equal: ACTUAL: -1.061... MSTW2008lo68cl \u274c Items are not equal: ACTUAL: -2.161... MSTW2008lo68cl_nf3 \u274c Items are not equal: ACTUAL: -0.000... MSTW2008lo68cl_nf3 \u274c Items are not equal: ACTUAL: -0.000... MSTW2008lo68cl_nf4 \u274c Items are not equal: ACTUAL: -2.399... MSTW2008lo68cl_nf4 \u274c Items are not equal: ACTUAL: -7.284... MSTW2008lo68cl_nf4as5 \u274c Items are not equal: ACTUAL: -4.766... MSTW2008lo68cl_nf4as5 \u274c Items are not equal: ACTUAL: -5.468... MSTW2008lo90cl \u274c Items are not equal: ACTUAL: -1.305... MSTW2008lo90cl \u274c Items are not equal: ACTUAL: -1.916... MSTW2008lo90cl_nf3 \u274c Items are not equal: ACTUAL: -5.454... MSTW2008lo90cl_nf3 \u274c Items are not equal: ACTUAL: -0.000... MSTW2008lo90cl_nf4 \u274c Items are not equal: ACTUAL: -5.367... MSTW2008lo90cl_nf4 \u274c Items are not equal: ACTUAL: -2.532... MSTW2008lo90cl_nf4as5 \u274c Items are not equal: ACTUAL: -4.709... MSTW2008lo90cl_nf4as5 \u274c Items are not equal: ACTUAL: -1.991... MSTW2008nlo68cl \u2705 MSTW2008nlo68cl \u2705 MSTW2008nlo68cl_asmz+68cl \u2705 MSTW2008nlo68cl_asmz+68cl \u2705 MSTW2008nlo68cl_asmz+68clhalf \u2705 MSTW2008nlo68cl_asmz+68clhalf \u2705 MSTW2008nlo68cl_asmz-68cl \u2705 MSTW2008nlo68cl_asmz-68cl \u2705 MSTW2008nlo68cl_asmz-68clhalf \u2705 MSTW2008nlo68cl_asmz-68clhalf \u2705 MSTW2008nlo68cl_nf3 \u2705 MSTW2008nlo68cl_nf3 \u2705 MSTW2008nlo68cl_nf4 \u2705 MSTW2008nlo68cl_nf4 \u2705 MSTW2008nlo68cl_nf4as5 \u2705 MSTW2008nlo68cl_nf4as5 \u2705 MSTW2008nlo90cl \u2705 MSTW2008nlo90cl \u2705 MSTW2008nlo90cl_asmz+90cl \u2705 MSTW2008nlo90cl_asmz+90cl \u2705 MSTW2008nlo90cl_asmz+90clhalf \u2705 MSTW2008nlo90cl_asmz+90clhalf \u2705 MSTW2008nlo90cl_asmz-90cl \u2705 MSTW2008nlo90cl_asmz-90cl \u2705 MSTW2008nlo90cl_asmz-90clhalf \u2705 MSTW2008nlo90cl_asmz-90clhalf \u2705 MSTW2008nlo90cl_nf3 \u2705 MSTW2008nlo90cl_nf3 \u2705 MSTW2008nlo90cl_nf4 \u2705 MSTW2008nlo90cl_nf4 \u2705 MSTW2008nlo90cl_nf4as5 \u2705 MSTW2008nlo90cl_nf4as5 \u2705 MSTW2008nlo_asmzrange \u2705 MSTW2008nlo_asmzrange \u2705 MSTW2008nlo_mbrange \u2705 MSTW2008nlo_mbrange \u2705 MSTW2008nlo_mbrange_nf4 \u2705 MSTW2008nlo_mbrange_nf4 \u2705 MSTW2008nlo_mcrange \u2705 MSTW2008nlo_mcrange \u2705 MSTW2008nlo_mcrange_fixasmz \u274c Process failed: thread '' panicked at ne... MSTW2008nlo_mcrange_fixasmz \u274c Process failed: thread '' panicked at ne... MSTW2008nlo_mcrange_fixasmz_nf3 \u274c Process failed: thread '' panicked at ne... MSTW2008nlo_mcrange_fixasmz_nf3 \u274c Process failed: thread '' panicked at ne... MSTW2008nlo_mcrange_nf3 \u274c Process failed: thread '' panicked at ne... MSTW2008nlo_mcrange_nf3 \u2705 MSTW2008nnlo68cl \u2705 MSTW2008nnlo68cl \u2705 MSTW2008nnlo68cl_asmz+68cl \u2705 MSTW2008nnlo68cl_asmz+68cl \u2705 MSTW2008nnlo68cl_asmz+68clhalf \u2705 MSTW2008nnlo68cl_asmz+68clhalf \u2705 MSTW2008nnlo68cl_asmz-68cl \u2705 MSTW2008nnlo68cl_asmz-68cl \u2705 MSTW2008nnlo68cl_asmz-68clhalf \u2705 MSTW2008nnlo68cl_asmz-68clhalf \u2705 MSTW2008nnlo68cl_nf3 \u2705 MSTW2008nnlo68cl_nf3 \u2705 MSTW2008nnlo68cl_nf4 \u2705 MSTW2008nnlo68cl_nf4 \u2705 MSTW2008nnlo68cl_nf4as5 \u2705 MSTW2008nnlo68cl_nf4as5 \u2705 MSTW2008nnlo90cl \u2705 MSTW2008nnlo90cl \u2705 MSTW2008nnlo90cl_asmz+90cl \u2705 MSTW2008nnlo90cl_asmz+90cl \u2705 MSTW2008nnlo90cl_asmz+90clhalf \u2705 MSTW2008nnlo90cl_asmz+90clhalf \u2705 MSTW2008nnlo90cl_asmz-90cl \u2705 MSTW2008nnlo90cl_asmz-90cl \u2705 MSTW2008nnlo90cl_asmz-90clhalf \u2705 MSTW2008nnlo90cl_asmz-90clhalf \u2705 MSTW2008nnlo90cl_nf3 \u2705 MSTW2008nnlo90cl_nf3 \u2705 MSTW2008nnlo90cl_nf4 \u2705 MSTW2008nnlo90cl_nf4 \u2705 MSTW2008nnlo90cl_nf4as5 \u2705 MSTW2008nnlo90cl_nf4as5 \u2705 MSTW2008nnlo_asmzrange \u2705 MSTW2008nnlo_asmzrange \u2705 MSTW2008nnlo_mbrange \u2705 MSTW2008nnlo_mbrange \u2705 MSTW2008nnlo_mbrange_nf4 \u2705 MSTW2008nnlo_mbrange_nf4 \u2705 MSTW2008nnlo_mcrange \u274c Process failed: thread '' panicked at ne... MSTW2008nnlo_mcrange \u2705 MSTW2008nnlo_mcrange_fixasmz \u2705 MSTW2008nnlo_mcrange_fixasmz \u274c Process failed: thread '' panicked at ne... MSTW2008nnlo_mcrange_fixasmz_nf3 \u2705 MSTW2008nnlo_mcrange_fixasmz_nf3 \u274c Process failed: thread '' panicked at ne... MSTW2008nnlo_mcrange_nf3 \u2705 MSTW2008nnlo_mcrange_nf3 \u2705 NNPDF10_nlo_as_0118_Ag108 \u274c Process failed: thread '' panicked at ne... NNPDF10_nlo_as_0118_Al27 \u274c Process failed: thread '' panicked at ne... NNPDF10_nlo_as_0118_Au197 \u274c Process failed: thread '' panicked at ne... NNPDF10_nlo_as_0118_Be9 \u274c Process failed: thread '' panicked at ne... NNPDF10_nlo_as_0118_C12 \u274c Process failed: thread '' panicked at ne... NNPDF10_nlo_as_0118_Ca40 \u274c Process failed: thread '' panicked at ne... NNPDF10_nlo_as_0118_Cu64 \u274c Process failed: thread '' panicked at ne... NNPDF10_nlo_as_0118_D2 \u274c Process failed: thread '' panicked at ne... NNPDF10_nlo_as_0118_Fe56 \u274c Process failed: thread '' panicked at ne... NNPDF10_nlo_as_0118_He4 \u274c Process failed: thread '' panicked at ne... NNPDF10_nlo_as_0118_Li6 \u274c Process failed: thread '' panicked at ne... NNPDF10_nlo_as_0118_N1 \u274c Process failed: thread '' panicked at ne... NNPDF10_nlo_as_0118_N14 \u274c Process failed: thread '' panicked at ne... NNPDF10_nlo_as_0118_Pb208 \u274c Process failed: thread '' panicked at ne... NNPDF10_nlo_as_0118_Sn119 \u274c Process failed: thread '' panicked at ne... NNPDF10_nlo_as_0118_Xe131 \u274c Process failed: thread '' panicked at ne... NNPDF10_nnlo_as_0118_Ag108 \u274c Process failed: thread '' panicked at ne... NNPDF10_nnlo_as_0118_Al27 \u274c Process failed: thread '' panicked at ne... NNPDF10_nnlo_as_0118_Au197 \u274c Process failed: thread '' panicked at ne... NNPDF10_nnlo_as_0118_Be9 \u274c Process failed: thread '' panicked at ne... NNPDF10_nnlo_as_0118_C12 \u274c Process failed: thread '' panicked at ne... NNPDF10_nnlo_as_0118_Ca40 \u274c Process failed: thread '' panicked at ne... NNPDF10_nnlo_as_0118_Cu64 \u274c Process failed: thread '' panicked at ne... NNPDF10_nnlo_as_0118_D2 \u274c Process failed: thread '' panicked at ne... NNPDF10_nnlo_as_0118_Fe56 \u274c Process failed: thread '' panicked at ne... NNPDF10_nnlo_as_0118_He4 \u274c Process failed: thread '' panicked at ne... NNPDF10_nnlo_as_0118_Li6 \u274c Process failed: thread '' panicked at ne... NNPDF10_nnlo_as_0118_N1 \u274c Process failed: thread '' panicked at ne... NNPDF10_nnlo_as_0118_N14 \u274c Process failed: thread '' panicked at ne... NNPDF10_nnlo_as_0118_Pb208 \u274c Process failed: thread '' panicked at ne... NNPDF10_nnlo_as_0118_Sn119 \u274c Process failed: thread '' panicked at ne... NNPDF10_nnlo_as_0118_Xe131 \u274c Process failed: thread '' panicked at ne... NNPDF20_nlo_as_0118_Ag108 \u274c Process failed: thread '' panicked at ne... NNPDF20_nlo_as_0118_Al27 \u274c Process failed: thread '' panicked at ne... NNPDF20_nlo_as_0118_Au197 \u274c Process failed: thread '' panicked at ne... NNPDF20_nlo_as_0118_Be9 \u274c Process failed: thread '' panicked at ne... NNPDF20_nlo_as_0118_C12 \u274c Process failed: thread '' panicked at ne... NNPDF20_nlo_as_0118_Ca40 \u274c Process failed: thread '' panicked at ne... NNPDF20_nlo_as_0118_Cu64 \u274c Process failed: thread '' panicked at ne... NNPDF20_nlo_as_0118_D2 \u274c Process failed: thread '' panicked at ne... NNPDF20_nlo_as_0118_Fe56 \u274c Process failed: thread '' panicked at ne... NNPDF20_nlo_as_0118_He4 \u274c Process failed: thread '' panicked at ne... NNPDF20_nlo_as_0118_Li6 \u274c Process failed: thread '' panicked at ne... NNPDF20_nlo_as_0118_N1 \u274c Process failed: thread '' panicked at ne... NNPDF20_nlo_as_0118_N14 \u274c Process failed: thread '' panicked at ne... NNPDF20_nlo_as_0118_O16 \u274c Process failed: thread '' panicked at ne... NNPDF20_nlo_as_0118_Pb208 \u274c Process failed: thread '' panicked at ne... NNPDF20_nlo_as_0118_Sn119 \u274c Process failed: thread '' panicked at ne... NNPDF20_nlo_as_0118_W184 \u274c Process failed: thread '' panicked at ne... NNPDF20_nlo_as_0118_Xe131 \u274c Process failed: thread '' panicked at ne... NNPDF21_lo_as_0119_100 \u2705 NNPDF21_lo_as_0119_100 \u2705 NNPDF21_lo_as_0130_100 \u2705 NNPDF21_lo_as_0130_100 \u2705 NNPDF21_lostar_as_0119_100 \u2705 NNPDF21_lostar_as_0119_100 \u2705 NNPDF21_lostar_as_0130_100 \u2705 NNPDF21_lostar_as_0130_100 \u2705 NNPDF23_lo_as_0119_qed \u2705 NNPDF23_lo_as_0119_qed \u2705 NNPDF23_lo_as_0130_qed \u2705 NNPDF23_lo_as_0130_qed \u2705 NNPDF23_nlo_FFN_NF4_as_0116 \u2705 NNPDF23_nlo_FFN_NF4_as_0116 \u2705 NNPDF23_nlo_FFN_NF4_as_0116_mc \u274c Items are not equal: ACTUAL: 8.7016... NNPDF23_nlo_FFN_NF4_as_0116_mc \u274c Items are not equal: ACTUAL: 1.5273... NNPDF23_nlo_FFN_NF4_as_0117 \u2705 NNPDF23_nlo_FFN_NF4_as_0117 \u2705 NNPDF23_nlo_FFN_NF4_as_0117_mc \u274c Items are not equal: ACTUAL: 6.1374... NNPDF23_nlo_FFN_NF4_as_0117_mc \u274c Items are not equal: ACTUAL: 6.1374... NNPDF23_nlo_FFN_NF4_as_0118 \u2705 NNPDF23_nlo_FFN_NF4_as_0118 \u2705 NNPDF23_nlo_FFN_NF4_as_0118_mc \u274c Items are not equal: ACTUAL: 1.5323... NNPDF23_nlo_FFN_NF4_as_0118_mc \u274c Items are not equal: ACTUAL: 4.4838... NNPDF23_nlo_FFN_NF4_as_0119 \u2705 NNPDF23_nlo_FFN_NF4_as_0119 \u2705 NNPDF23_nlo_FFN_NF4_as_0119_mc \u274c Items are not equal: ACTUAL: 7.8774... NNPDF23_nlo_FFN_NF4_as_0119_mc \u274c Items are not equal: ACTUAL: 2.8421... NNPDF23_nlo_FFN_NF4_as_0120 \u2705 NNPDF23_nlo_FFN_NF4_as_0120 \u2705 NNPDF23_nlo_FFN_NF4_as_0120_mc \u274c Items are not equal: ACTUAL: 1.0368... NNPDF23_nlo_FFN_NF4_as_0120_mc \u274c Items are not equal: ACTUAL: 2.9019... NNPDF23_nlo_FFN_NF5_as_0116 \u2705 NNPDF23_nlo_FFN_NF5_as_0116 \u2705 NNPDF23_nlo_FFN_NF5_as_0116_mc \u274c Items are not equal: ACTUAL: 6.1374... NNPDF23_nlo_FFN_NF5_as_0116_mc \u274c Items are not equal: ACTUAL: 3.6355... NNPDF23_nlo_FFN_NF5_as_0117 \u2705 NNPDF23_nlo_FFN_NF5_as_0117 \u2705 NNPDF23_nlo_FFN_NF5_as_0117_mc \u274c Items are not equal: ACTUAL: 2.4429... NNPDF23_nlo_FFN_NF5_as_0117_mc \u274c Items are not equal: ACTUAL: 3.8451... NNPDF23_nlo_FFN_NF5_as_0118 \u2705 NNPDF23_nlo_FFN_NF5_as_0118 \u2705 NNPDF23_nlo_FFN_NF5_as_0118_mc \u274c Items are not equal: ACTUAL: 1.7905... NNPDF23_nlo_FFN_NF5_as_0118_mc \u274c Items are not equal: ACTUAL: -1.137... NNPDF23_nlo_FFN_NF5_as_0119 \u2705 NNPDF23_nlo_FFN_NF5_as_0119 \u2705 NNPDF23_nlo_FFN_NF5_as_0119_mc \u274c Items are not equal: ACTUAL: 1.6044... NNPDF23_nlo_FFN_NF5_as_0119_mc \u274c Items are not equal: ACTUAL: 2.8204... NNPDF23_nlo_FFN_NF5_as_0120 \u2705 NNPDF23_nlo_FFN_NF5_as_0120 \u2705 NNPDF23_nlo_FFN_NF5_as_0120_mc \u274c Items are not equal: ACTUAL: 6.1374... NNPDF23_nlo_FFN_NF5_as_0120_mc \u274c Items are not equal: ACTUAL: 6.8937... NNPDF23_nlo_as_0114 \u2705 NNPDF23_nlo_as_0114 \u2705 NNPDF23_nlo_as_0115 \u2705 NNPDF23_nlo_as_0115 \u2705 NNPDF23_nlo_as_0116 \u2705 NNPDF23_nlo_as_0116 \u2705 NNPDF23_nlo_as_0116_mc \u274c Items are not equal: ACTUAL: -1.263... NNPDF23_nlo_as_0116_mc \u274c Items are not equal: ACTUAL: -1.177... NNPDF23_nlo_as_0117 \u2705 NNPDF23_nlo_as_0117 \u2705 NNPDF23_nlo_as_0117_mc \u274c Items are not equal: ACTUAL: -1.470... NNPDF23_nlo_as_0117_mc \u274c Items are not equal: ACTUAL: -1.248... NNPDF23_nlo_as_0117_qed \u2705 NNPDF23_nlo_as_0117_qed \u2705 NNPDF23_nlo_as_0117_qed_neutron \u2705 NNPDF23_nlo_as_0117_qed_neutron \u2705 NNPDF23_nlo_as_0118 \u2705 NNPDF23_nlo_as_0118 \u2705 NNPDF23_nlo_as_0118_mc \u274c Items are not equal: ACTUAL: -2.122... NNPDF23_nlo_as_0118_mc \u274c Items are not equal: ACTUAL: -1.461... NNPDF23_nlo_as_0118_qed \u2705 NNPDF23_nlo_as_0118_qed \u2705 NNPDF23_nlo_as_0118_qed_neutron \u2705 NNPDF23_nlo_as_0118_qed_neutron \u2705 NNPDF23_nlo_as_0119 \u2705 NNPDF23_nlo_as_0119 \u2705 NNPDF23_nlo_as_0119_mc \u274c Items are not equal: ACTUAL: -1.185... NNPDF23_nlo_as_0119_mc \u274c Items are not equal: ACTUAL: -4.122... NNPDF23_nlo_as_0119_qed \u2705 NNPDF23_nlo_as_0119_qed \u2705 NNPDF23_nlo_as_0119_qed_mc \u274c Items are not equal: ACTUAL: 0.0 D... NNPDF23_nlo_as_0119_qed_mc \u274c Items are not equal: ACTUAL: 0.0 D... NNPDF23_nlo_as_0119_qed_neutron \u2705 NNPDF23_nlo_as_0119_qed_neutron \u2705 NNPDF23_nlo_as_0120 \u2705 NNPDF23_nlo_as_0120 \u2705 NNPDF23_nlo_as_0120_mc \u274c Items are not equal: ACTUAL: -1.141... NNPDF23_nlo_as_0120_mc \u274c Items are not equal: ACTUAL: -1.418... NNPDF23_nlo_as_0121 \u2705 NNPDF23_nlo_as_0121 \u2705 NNPDF23_nlo_as_0122 \u2705 NNPDF23_nlo_as_0122 \u2705 NNPDF23_nlo_as_0123 \u2705 NNPDF23_nlo_as_0123 \u2705 NNPDF23_nlo_as_0124 \u2705 NNPDF23_nlo_as_0124 \u2705 NNPDF23_nlo_collider_as_0116 \u2705 NNPDF23_nlo_collider_as_0116 \u2705 NNPDF23_nlo_collider_as_0117 \u2705 NNPDF23_nlo_collider_as_0117 \u2705 NNPDF23_nlo_collider_as_0118 \u2705 NNPDF23_nlo_collider_as_0118 \u2705 NNPDF23_nlo_collider_as_0119 \u2705 NNPDF23_nlo_collider_as_0119 \u2705 NNPDF23_nlo_collider_as_0120 \u2705 NNPDF23_nlo_collider_as_0120 \u2705 NNPDF23_nlo_noLHC_as_0116 \u2705 NNPDF23_nlo_noLHC_as_0116 \u2705 NNPDF23_nlo_noLHC_as_0117 \u2705 NNPDF23_nlo_noLHC_as_0117 \u2705 NNPDF23_nlo_noLHC_as_0118 \u2705 NNPDF23_nlo_noLHC_as_0118 \u2705 NNPDF23_nlo_noLHC_as_0119 \u2705 NNPDF23_nlo_noLHC_as_0119 \u2705 NNPDF23_nlo_noLHC_as_0120 \u2705 NNPDF23_nlo_noLHC_as_0120 \u2705 NNPDF23_nnlo_FFN_NF4_as_0116 \u2705 NNPDF23_nnlo_FFN_NF4_as_0116 \u2705 NNPDF23_nnlo_FFN_NF4_as_0117 \u2705 NNPDF23_nnlo_FFN_NF4_as_0117 \u2705 NNPDF23_nnlo_FFN_NF4_as_0118 \u2705 NNPDF23_nnlo_FFN_NF4_as_0118 \u2705 NNPDF23_nnlo_FFN_NF4_as_0119 \u2705 NNPDF23_nnlo_FFN_NF4_as_0119 \u2705 NNPDF23_nnlo_FFN_NF4_as_0120 \u2705 NNPDF23_nnlo_FFN_NF4_as_0120 \u2705 NNPDF23_nnlo_FFN_NF5_as_0116 \u2705 NNPDF23_nnlo_FFN_NF5_as_0116 \u2705 NNPDF23_nnlo_FFN_NF5_as_0117 \u2705 NNPDF23_nnlo_FFN_NF5_as_0117 \u2705 NNPDF23_nnlo_FFN_NF5_as_0118 \u2705 NNPDF23_nnlo_FFN_NF5_as_0118 \u2705 NNPDF23_nnlo_FFN_NF5_as_0119 \u2705 NNPDF23_nnlo_FFN_NF5_as_0119 \u2705 NNPDF23_nnlo_FFN_NF5_as_0120 \u2705 NNPDF23_nnlo_FFN_NF5_as_0120 \u2705 NNPDF23_nnlo_as_0114 \u2705 NNPDF23_nnlo_as_0114 \u2705 NNPDF23_nnlo_as_0115 \u2705 NNPDF23_nnlo_as_0115 \u2705 NNPDF23_nnlo_as_0116 \u2705 NNPDF23_nnlo_as_0116 \u2705 NNPDF23_nnlo_as_0117 \u2705 NNPDF23_nnlo_as_0117 \u2705 NNPDF23_nnlo_as_0117_qed \u2705 NNPDF23_nnlo_as_0117_qed \u2705 NNPDF23_nnlo_as_0117_qed_neutron \u2705 NNPDF23_nnlo_as_0117_qed_neutron \u2705 NNPDF23_nnlo_as_0118 \u2705 NNPDF23_nnlo_as_0118 \u2705 NNPDF23_nnlo_as_0118_qed \u2705 NNPDF23_nnlo_as_0118_qed \u2705 NNPDF23_nnlo_as_0118_qed_neutron \u2705 NNPDF23_nnlo_as_0118_qed_neutron \u2705 NNPDF23_nnlo_as_0119 \u2705 NNPDF23_nnlo_as_0119 \u2705 NNPDF23_nnlo_as_0119_qed \u2705 NNPDF23_nnlo_as_0119_qed \u2705 NNPDF23_nnlo_as_0119_qed_mc \u274c Items are not equal: ACTUAL: 0.0 D... NNPDF23_nnlo_as_0119_qed_mc \u274c Items are not equal: ACTUAL: 0.0 D... NNPDF23_nnlo_as_0119_qed_neutron \u2705 NNPDF23_nnlo_as_0119_qed_neutron \u2705 NNPDF23_nnlo_as_0120 \u2705 NNPDF23_nnlo_as_0120 \u2705 NNPDF23_nnlo_as_0121 \u2705 NNPDF23_nnlo_as_0121 \u2705 NNPDF23_nnlo_as_0122 \u2705 NNPDF23_nnlo_as_0122 \u2705 NNPDF23_nnlo_as_0123 \u2705 NNPDF23_nnlo_as_0123 \u2705 NNPDF23_nnlo_as_0124 \u2705 NNPDF23_nnlo_as_0124 \u2705 NNPDF23_nnlo_collider_as_0116 \u2705 NNPDF23_nnlo_collider_as_0116 \u2705 NNPDF23_nnlo_collider_as_0117 \u2705 NNPDF23_nnlo_collider_as_0117 \u2705 NNPDF23_nnlo_collider_as_0118 \u2705 NNPDF23_nnlo_collider_as_0118 \u2705 NNPDF23_nnlo_collider_as_0119 \u2705 NNPDF23_nnlo_collider_as_0119 \u2705 NNPDF23_nnlo_collider_as_0120 \u2705 NNPDF23_nnlo_collider_as_0120 \u2705 NNPDF23_nnlo_noLHC_as_0116 \u2705 NNPDF23_nnlo_noLHC_as_0116 \u2705 NNPDF23_nnlo_noLHC_as_0117 \u2705 NNPDF23_nnlo_noLHC_as_0117 \u2705 NNPDF23_nnlo_noLHC_as_0118 \u2705 NNPDF23_nnlo_noLHC_as_0118 \u2705 NNPDF23_nnlo_noLHC_as_0119 \u2705 NNPDF23_nnlo_noLHC_as_0119 \u2705 NNPDF23_nnlo_noLHC_as_0120 \u2705 NNPDF23_nnlo_noLHC_as_0120 \u2705 NNPDF30_lo_as_0118 \u274c Items are not equal: ACTUAL: -1.637... NNPDF30_nlo_as_0115 \u2705 NNPDF30_nlo_as_0115_nf_3 \u2705 NNPDF30_nlo_as_0115_nf_3 \u2705 NNPDF30_nlo_as_0115_nf_4 \u2705 NNPDF30_nlo_as_0115_nf_4 \u2705 NNPDF30_nlo_as_0115_nf_6 \u2705 NNPDF30_nlo_as_0115_nf_6 \u2705 NNPDF30_nlo_as_0117 \u2705 NNPDF30_nlo_as_0117 \u2705 NNPDF30_nlo_as_0117_atlas \u2705 NNPDF30_nlo_as_0117_atlas \u2705 NNPDF30_nlo_as_0117_cms \u2705 NNPDF30_nlo_as_0117_cms \u2705 NNPDF30_nlo_as_0117_cons \u2705 NNPDF30_nlo_as_0117_cons \u2705 NNPDF30_nlo_as_0117_hera \u2705 NNPDF30_nlo_as_0117_hera \u2705 NNPDF30_nlo_as_0117_nf_3 \u2705 NNPDF30_nlo_as_0117_nf_3 \u2705 NNPDF30_nlo_as_0117_nf_4 \u2705 NNPDF30_nlo_as_0117_nf_4 \u2705 NNPDF30_nlo_as_0117_nf_6 \u2705 NNPDF30_nlo_as_0117_nf_6 \u2705 NNPDF30_nlo_as_0117_nojet \u2705 NNPDF30_nlo_as_0117_nojet \u2705 NNPDF30_nlo_as_0117_nolhc \u2705 NNPDF30_nlo_as_0117_nolhc \u2705 NNPDF30_nlo_as_0118 \u2705 NNPDF30_nlo_as_0118 \u2705 NNPDF30_nlo_as_0118_1000 \u2705 NNPDF30_nlo_as_0118_1000 \u2705 NNPDF30_nlo_as_0118_A108_Z54 \u274c Process failed: thread '' panicked at ne... NNPDF30_nlo_as_0118_A119_Z59 \u274c Process failed: thread '' panicked at ne... NNPDF30_nlo_as_0118_A12_Z6 \u274c Process failed: thread '' panicked at ne... NNPDF30_nlo_as_0118_A131_Z54 \u274c Process failed: thread '' panicked at ne... NNPDF30_nlo_as_0118_A14_Z7 \u274c Process failed: thread '' panicked at ne... NNPDF30_nlo_as_0118_A16_Z8 \u274c Process failed: thread '' panicked at ne... NNPDF30_nlo_as_0118_A184_Z74 \u274c Process failed: thread '' panicked at ne... NNPDF30_nlo_as_0118_A197_Z79 \u274c Process failed: thread '' panicked at ne... NNPDF30_nlo_as_0118_A208_Z82 \u274c Process failed: thread '' panicked at ne... NNPDF30_nlo_as_0118_A27_Z13 \u274c Process failed: thread '' panicked at ne... NNPDF30_nlo_as_0118_A2_Z1 \u274c Process failed: thread '' panicked at ne... NNPDF30_nlo_as_0118_A31_Z15 \u274c Process failed: thread '' panicked at ne... NNPDF30_nlo_as_0118_A40_Z20 \u274c Process failed: thread '' panicked at ne... NNPDF30_nlo_as_0118_A4_Z2 \u274c Process failed: thread '' panicked at ne... NNPDF30_nlo_as_0118_A56_Z26 \u274c Process failed: thread '' panicked at ne... NNPDF30_nlo_as_0118_A64_Z29 \u274c Process failed: thread '' panicked at ne... NNPDF30_nlo_as_0118_A6_Z3 \u274c Process failed: thread '' panicked at ne... NNPDF30_nlo_as_0118_A9_Z4 \u274c Process failed: thread '' panicked at ne... NNPDF30_nlo_as_0118_atlas \u2705 NNPDF30_nlo_as_0118_atlas \u2705 NNPDF30_nlo_as_0118_cms \u2705 NNPDF30_nlo_as_0118_cms \u2705 NNPDF30_nlo_as_0118_cons \u2705 NNPDF30_nlo_as_0118_cons \u2705 NNPDF30_nlo_as_0118_hera \u2705 NNPDF30_nlo_as_0118_hera \u2705 NNPDF30_nlo_as_0118_hera_1000 \u2705 NNPDF30_nlo_as_0118_hera_1000 \u2705 NNPDF30_nlo_as_0118_hessian \u2705 NNPDF30_nlo_as_0118_hessian \u2705 NNPDF30_nlo_as_0118_mc \u2705 NNPDF30_nlo_as_0118_mc \u2705 NNPDF30_nlo_as_0118_nf_3 \u2705 NNPDF30_nlo_as_0118_nf_3 \u2705 NNPDF30_nlo_as_0118_nf_4 \u2705 NNPDF30_nlo_as_0118_nf_4 \u2705 NNPDF30_nlo_as_0118_nf_6 \u2705 NNPDF30_nlo_as_0118_nf_6 \u2705 NNPDF30_nlo_as_0118_nojet \u2705 NNPDF30_nlo_as_0118_nojet \u2705 NNPDF30_nlo_as_0118_nolhc \u2705 NNPDF30_nlo_as_0118_nolhc \u2705 NNPDF30_nlo_as_0118_nolhc_1000 \u2705 NNPDF30_nlo_as_0118_nolhc_1000 \u2705 NNPDF30_nlo_as_0118_p \u274c Process failed: thread '' panicked at ne... NNPDF30_nlo_as_0119 \u2705 NNPDF30_nlo_as_0119 \u2705 NNPDF30_nlo_as_0119_atlas \u2705 NNPDF30_nlo_as_0119_atlas \u2705 NNPDF30_nlo_as_0119_cms \u2705 NNPDF30_nlo_as_0119_cms \u2705 NNPDF30_nlo_as_0119_cons \u2705 NNPDF30_nlo_as_0119_cons \u2705 NNPDF30_nlo_as_0119_hera \u2705 NNPDF30_nlo_as_0119_hera \u2705 NNPDF30_nlo_as_0119_nf_3 \u2705 NNPDF30_nlo_as_0119_nf_3 \u2705 NNPDF30_nlo_as_0119_nf_4 \u2705 NNPDF30_nlo_as_0119_nf_4 \u2705 NNPDF30_nlo_as_0119_nf_6 \u2705 NNPDF30_nlo_as_0119_nf_6 \u2705 NNPDF30_nlo_as_0119_nojet \u2705 NNPDF30_nlo_as_0119_nojet \u2705 NNPDF30_nlo_as_0119_nolhc \u2705 NNPDF30_nlo_as_0119_nolhc \u2705 NNPDF30_nlo_as_0121 \u2705 NNPDF30_nlo_as_0121 \u2705 NNPDF30_nlo_as_0121_nf_3 \u2705 NNPDF30_nlo_as_0121_nf_3 \u2705 NNPDF30_nlo_as_0121_nf_4 \u2705 NNPDF30_nlo_as_0121_nf_4 \u2705 NNPDF30_nlo_as_0121_nf_6 \u2705 NNPDF30_nlo_as_0121_nf_6 \u2705 NNPDF30_nlo_nf_4_pdfas \u2705 NNPDF30_nlo_nf_4_pdfas \u2705 NNPDF30_nlo_nf_5_pdfas \u2705 NNPDF30_nlo_nf_5_pdfas \u2705 NNPDF30_nnlo_as_0115 \u2705 NNPDF30_nnlo_as_0115 \u2705 NNPDF30_nnlo_as_0115_nf_3 \u2705 NNPDF30_nnlo_as_0115_nf_3 \u2705 NNPDF30_nnlo_as_0115_nf_4 \u2705 NNPDF30_nnlo_as_0115_nf_4 \u2705 NNPDF30_nnlo_as_0115_nf_6 \u2705 NNPDF30_nnlo_as_0115_nf_6 \u2705 NNPDF30_nnlo_as_0117 \u2705 NNPDF30_nnlo_as_0117 \u2705 NNPDF30_nnlo_as_0117_atlas \u2705 NNPDF30_nnlo_as_0117_atlas \u2705 NNPDF30_nnlo_as_0117_cms \u2705 NNPDF30_nnlo_as_0117_cms \u2705 NNPDF30_nnlo_as_0117_cons \u2705 NNPDF30_nnlo_as_0117_cons \u2705 NNPDF30_nnlo_as_0117_hera \u2705 NNPDF30_nnlo_as_0117_hera \u2705 NNPDF30_nnlo_as_0117_nf_3 \u2705 NNPDF30_nnlo_as_0117_nf_3 \u2705 NNPDF30_nnlo_as_0117_nf_4 \u2705 NNPDF30_nnlo_as_0117_nf_4 \u2705 NNPDF30_nnlo_as_0117_nf_6 \u2705 NNPDF30_nnlo_as_0117_nf_6 \u2705 NNPDF30_nnlo_as_0117_nojet \u2705 NNPDF30_nnlo_as_0117_nojet \u2705 NNPDF30_nnlo_as_0117_nolhc \u2705 NNPDF30_nnlo_as_0117_nolhc \u2705 NNPDF30_nnlo_as_0118 \u2705 NNPDF30_nnlo_as_0118 \u2705 NNPDF30_nnlo_as_0118_1000 \u2705 NNPDF30_nnlo_as_0118_1000 \u2705 NNPDF30_nnlo_as_0118_atlas \u2705 NNPDF30_nnlo_as_0118_atlas \u2705 NNPDF30_nnlo_as_0118_cms \u2705 NNPDF30_nnlo_as_0118_cms \u2705 NNPDF30_nnlo_as_0118_cons \u2705 NNPDF30_nnlo_as_0118_cons \u2705 NNPDF30_nnlo_as_0118_hera \u2705 NNPDF30_nnlo_as_0118_hera \u2705 NNPDF30_nnlo_as_0118_hera_1000 \u2705 NNPDF30_nnlo_as_0118_hera_1000 \u2705 NNPDF30_nnlo_as_0118_hessian \u2705 NNPDF30_nnlo_as_0118_hessian \u2705 NNPDF30_nnlo_as_0118_mc \u2705 NNPDF30_nnlo_as_0118_mc \u2705 NNPDF30_nnlo_as_0118_nf_3 \u2705 NNPDF30_nnlo_as_0118_nf_3 \u2705 NNPDF30_nnlo_as_0118_nf_4 \u2705 NNPDF30_nnlo_as_0118_nf_4 \u2705 NNPDF30_nnlo_as_0118_nf_6 \u2705 NNPDF30_nnlo_as_0118_nf_6 \u2705 NNPDF30_nnlo_as_0118_nojet \u2705 NNPDF30_nnlo_as_0118_nojet \u2705 NNPDF30_nnlo_as_0118_nolhc \u2705 NNPDF30_nnlo_as_0118_nolhc \u2705 NNPDF30_nnlo_as_0118_nolhc_1000 \u2705 NNPDF30_nnlo_as_0118_nolhc_1000 \u2705 NNPDF30_nnlo_as_0119 \u2705 NNPDF30_nnlo_as_0119 \u2705 NNPDF30_nnlo_as_0119_atlas \u2705 NNPDF30_nnlo_as_0119_atlas \u2705 NNPDF30_nnlo_as_0119_cms \u2705 NNPDF30_nnlo_as_0119_cms \u2705 NNPDF30_nnlo_as_0119_cons \u2705 NNPDF30_nnlo_as_0119_cons \u2705 NNPDF30_nnlo_as_0119_hera \u2705 NNPDF30_nnlo_as_0119_hera \u2705 NNPDF30_nnlo_as_0119_nf_3 \u2705 NNPDF30_nnlo_as_0119_nf_3 \u2705 NNPDF30_nnlo_as_0119_nf_4 \u2705 NNPDF30_nnlo_as_0119_nf_4 \u2705 NNPDF30_nnlo_as_0119_nf_6 \u2705 NNPDF30_nnlo_as_0119_nf_6 \u2705 NNPDF30_nnlo_as_0119_nojet \u2705 NNPDF30_nnlo_as_0119_nojet \u2705 NNPDF30_nnlo_as_0119_nolhc \u2705 NNPDF30_nnlo_as_0119_nolhc \u2705 NNPDF30_nnlo_as_0121 \u2705 NNPDF30_nnlo_as_0121 \u2705 NNPDF30_nnlo_as_0121_nf_3 \u2705 NNPDF30_nnlo_as_0121_nf_3 \u2705 NNPDF30_nnlo_as_0121_nf_4 \u2705 NNPDF30_nnlo_as_0121_nf_4 \u2705 NNPDF30_nnlo_as_0121_nf_6 \u2705 NNPDF30_nnlo_as_0121_nf_6 \u2705 NNPDF30_nnlo_nf_4_pdfas \u2705 NNPDF30_nnlo_nf_4_pdfas \u2705 NNPDF30_nnlo_nf_5_pdfas \u2705 NNPDF30_nnlo_nf_5_pdfas \u2705 NNPDF31_lo_as_0118 \u274c Items are not equal: ACTUAL: -1.000... NNPDF31_lo_as_0118 \u274c Items are not equal: ACTUAL: -1.985... NNPDF31_lo_as_0130 \u274c Items are not equal: ACTUAL: -5.944... NNPDF31_lo_as_0130 \u274c Items are not equal: ACTUAL: -9.536... NNPDF31_lo_pch_as_0118 \u274c Items are not equal: ACTUAL: -3.177... NNPDF31_lo_pch_as_0118 \u274c Items are not equal: ACTUAL: -1.164... NNPDF31_lo_pch_as_0130 \u274c Items are not equal: ACTUAL: -1.192... NNPDF31_lo_pch_as_0130 \u274c Items are not equal: ACTUAL: -3.972... NNPDF31_nlo_as_0116 \u2705 NNPDF31_nlo_as_0116 \u2705 NNPDF31_nlo_as_0118 \u2705 NNPDF31_nlo_as_0118 \u2705 NNPDF31_nlo_as_0118_1000 \u2705 NNPDF31_nlo_as_0118_1000 \u2705 NNPDF31_nlo_as_0118_C1p6 \u2705 NNPDF31_nlo_as_0118_C1p6 \u2705 NNPDF31_nlo_as_0118_hessian \u2705 NNPDF31_nlo_as_0118_hessian \u2705 NNPDF31_nlo_as_0118_luxqed \u2705 NNPDF31_nlo_as_0118_luxqed \u2705 NNPDF31_nlo_as_0118_mc \u2705 NNPDF31_nlo_as_0118_mc \u2705 NNPDF31_nlo_as_0118_nf_4 \u2705 NNPDF31_nlo_as_0118_nf_4 \u2705 NNPDF31_nlo_as_0118_nf_6 \u2705 NNPDF31_nlo_as_0118_nf_6 \u2705 NNPDF31_nlo_as_0120 \u2705 NNPDF31_nlo_as_0120 \u2705 NNPDF31_nlo_hessian_pdfas \u2705 NNPDF31_nlo_hessian_pdfas \u2705 NNPDF31_nlo_pch_as_0116 \u2705 NNPDF31_nlo_pch_as_0116 \u2705 NNPDF31_nlo_pch_as_0118 \u2705 NNPDF31_nlo_pch_as_0118 \u2705 NNPDF31_nlo_pch_as_0118_1000 \u2705 NNPDF31_nlo_pch_as_0118_1000 \u2705 NNPDF31_nlo_pch_as_0118_hessian \u2705 NNPDF31_nlo_pch_as_0118_hessian \u2705 NNPDF31_nlo_pch_as_0118_mc \u2705 NNPDF31_nlo_pch_as_0118_mc \u2705 NNPDF31_nlo_pch_as_0118_nf_3 \u2705 NNPDF31_nlo_pch_as_0118_nf_3 \u2705 NNPDF31_nlo_pch_as_0118_nf_4 \u2705 NNPDF31_nlo_pch_as_0118_nf_4 \u2705 NNPDF31_nlo_pch_as_0118_nf_6 \u2705 NNPDF31_nlo_pch_as_0118_nf_6 \u2705 NNPDF31_nlo_pch_as_0120 \u2705 NNPDF31_nlo_pch_as_0120 \u2705 NNPDF31_nlo_pch_hessian_pdfas \u2705 NNPDF31_nlo_pch_hessian_pdfas \u2705 NNPDF31_nlo_pch_pdfas \u2705 NNPDF31_nlo_pch_pdfas \u2705 NNPDF31_nlo_pdfas \u2705 NNPDF31_nlo_pdfas \u2705 NNPDF31_nnlo_as_0108 \u2705 NNPDF31_nnlo_as_0108 \u2705 NNPDF31_nnlo_as_0110 \u2705 NNPDF31_nnlo_as_0110 \u2705 NNPDF31_nnlo_as_0112 \u2705 NNPDF31_nnlo_as_0112 \u2705 NNPDF31_nnlo_as_0114 \u2705 NNPDF31_nnlo_as_0114 \u2705 NNPDF31_nnlo_as_0116 \u2705 NNPDF31_nnlo_as_0116 \u2705 NNPDF31_nnlo_as_0117 \u2705 NNPDF31_nnlo_as_0117 \u2705 NNPDF31_nnlo_as_0118 \u2705 NNPDF31_nnlo_as_0118 \u2705 NNPDF31_nnlo_as_0118_1000 \u2705 NNPDF31_nnlo_as_0118_1000 \u2705 NNPDF31_nnlo_as_0118_CMSW1 \u2705 NNPDF31_nnlo_as_0118_CMSW1 \u2705 NNPDF31_nnlo_as_0118_CMSW1_hessian_100 \u2705 NNPDF31_nnlo_as_0118_CMSW1_hessian_100 \u2705 NNPDF31_nnlo_as_0118_CMSW2 \u2705 NNPDF31_nnlo_as_0118_CMSW2 \u2705 NNPDF31_nnlo_as_0118_CMSW2_hessian_100 \u2705 NNPDF31_nnlo_as_0118_CMSW2_hessian_100 \u2705 NNPDF31_nnlo_as_0118_CMSW3 \u2705 NNPDF31_nnlo_as_0118_CMSW3 \u2705 NNPDF31_nnlo_as_0118_CMSW3_hessian_100 \u2705 NNPDF31_nnlo_as_0118_CMSW3_hessian_100 \u2705 NNPDF31_nnlo_as_0118_CMSW4 \u2705 NNPDF31_nnlo_as_0118_CMSW4 \u2705 NNPDF31_nnlo_as_0118_CMSW4_hessian_100 \u2705 NNPDF31_nnlo_as_0118_CMSW4_hessian_100 \u2705 NNPDF31_nnlo_as_0118_collider \u2705 NNPDF31_nnlo_as_0118_collider \u2705 NNPDF31_nnlo_as_0118_hessian \u2705 NNPDF31_nnlo_as_0118_hessian \u2705 NNPDF31_nnlo_as_0118_luxqed \u2705 NNPDF31_nnlo_as_0118_luxqed \u2705 NNPDF31_nnlo_as_0118_mc \u2705 NNPDF31_nnlo_as_0118_mc \u2705 NNPDF31_nnlo_as_0118_mc_138 \u2705 NNPDF31_nnlo_as_0118_mc_138 \u2705 NNPDF31_nnlo_as_0118_mc_164 \u2705 NNPDF31_nnlo_as_0118_mc_164 \u2705 NNPDF31_nnlo_as_0118_mc_hessian_pdfas \u2705 NNPDF31_nnlo_as_0118_mc_hessian_pdfas \u2705 NNPDF31_nnlo_as_0118_nf_4 \u2705 NNPDF31_nnlo_as_0118_nf_4 \u2705 NNPDF31_nnlo_as_0118_nf_4_mc_hessian \u2705 NNPDF31_nnlo_as_0118_nf_4_mc_hessian \u2705 NNPDF31_nnlo_as_0118_nf_6 \u2705 NNPDF31_nnlo_as_0118_nf_6 \u2705 NNPDF31_nnlo_as_0118_noLHC \u2705 NNPDF31_nnlo_as_0118_noLHC \u2705 NNPDF31_nnlo_as_0118_noZpt \u2705 NNPDF31_nnlo_as_0118_noZpt \u2705 NNPDF31_nnlo_as_0118_nojets \u2705 NNPDF31_nnlo_as_0118_nojets \u2705 NNPDF31_nnlo_as_0118_notop \u2705 NNPDF31_nnlo_as_0118_notop \u2705 NNPDF31_nnlo_as_0118_proton \u2705 NNPDF31_nnlo_as_0118_proton \u2705 NNPDF31_nnlo_as_0118_wEMC \u2705 NNPDF31_nnlo_as_0118_wEMC \u2705 NNPDF31_nnlo_as_0119 \u2705 NNPDF31_nnlo_as_0119 \u2705 NNPDF31_nnlo_as_0120 \u2705 NNPDF31_nnlo_as_0120 \u2705 NNPDF31_nnlo_as_0122 \u2705 NNPDF31_nnlo_as_0122 \u2705 NNPDF31_nnlo_as_0124 \u2705 NNPDF31_nnlo_as_0124 \u2705 NNPDF31_nnlo_hessian_pdfas \u2705 NNPDF31_nnlo_hessian_pdfas \u2705 NNPDF31_nnlo_pch_as_0116 \u2705 NNPDF31_nnlo_pch_as_0116 \u2705 NNPDF31_nnlo_pch_as_0118 \u2705 NNPDF31_nnlo_pch_as_0118 \u2705 NNPDF31_nnlo_pch_as_0118_1000 \u2705 NNPDF31_nnlo_pch_as_0118_1000 \u2705 NNPDF31_nnlo_pch_as_0118_hessian \u2705 NNPDF31_nnlo_pch_as_0118_hessian \u2705 NNPDF31_nnlo_pch_as_0118_mc \u2705 NNPDF31_nnlo_pch_as_0118_mc \u2705 NNPDF31_nnlo_pch_as_0118_mc_138 \u2705 NNPDF31_nnlo_pch_as_0118_mc_138 \u2705 NNPDF31_nnlo_pch_as_0118_mc_164 \u2705 NNPDF31_nnlo_pch_as_0118_mc_164 \u2705 NNPDF31_nnlo_pch_as_0118_nf_3 \u2705 NNPDF31_nnlo_pch_as_0118_nf_3 \u2705 NNPDF31_nnlo_pch_as_0118_nf_4 \u2705 NNPDF31_nnlo_pch_as_0118_nf_4 \u2705 NNPDF31_nnlo_pch_as_0118_nf_6 \u2705 NNPDF31_nnlo_pch_as_0118_nf_6 \u2705 NNPDF31_nnlo_pch_as_0120 \u2705 NNPDF31_nnlo_pch_as_0120 \u2705 NNPDF31_nnlo_pch_hessian_pdfas \u2705 NNPDF31_nnlo_pch_hessian_pdfas \u2705 NNPDF31_nnlo_pch_pdfas \u2705 NNPDF31_nnlo_pch_pdfas \u2705 NNPDF31_nnlo_pdfas \u2705 NNPDF31_nnlo_pdfas \u2705 NNPDF40MC_lo_as_01180 \u274c Items are not equal: ACTUAL: -1.690... NNPDF40MC_lo_as_01180 \u274c Items are not equal: ACTUAL: -1.690... NNPDF40MC_lo_as_01180_qed \u274c Items are not equal: ACTUAL: -2.119... NNPDF40MC_lo_as_01180_qed \u274c Items are not equal: ACTUAL: -2.119... NNPDF40MC_nlo_as_01180 \u274c Items are not equal: ACTUAL: -1.694... NNPDF40MC_nlo_as_01180 \u274c Items are not equal: ACTUAL: -1.694... NNPDF40MC_nlo_as_01180_qed \u274c Items are not equal: ACTUAL: -2.068... NNPDF40MC_nlo_as_01180_qed \u274c Items are not equal: ACTUAL: -2.068... NNPDF40MC_nnlo_as_01180 \u2705 NNPDF40MC_nnlo_as_01180 \u2705 NNPDF40MC_nnlo_as_01180_qed \u2705 NNPDF40MC_nnlo_as_01180_qed \u2705 NNPDF40_an3lo_as_01180 \u2705 NNPDF40_an3lo_as_01180 \u2705 NNPDF40_an3lo_as_01180_hessian \u2705 NNPDF40_an3lo_as_01180_hessian \u2705 NNPDF40_an3lo_as_01180_mhou \u2705 NNPDF40_an3lo_as_01180_mhou \u2705 NNPDF40_an3lo_as_01180_mhou_hessian \u2705 NNPDF40_an3lo_as_01180_mhou_hessian \u2705 NNPDF40_an3lo_as_01180_mhou_pdfas \u2705 NNPDF40_an3lo_as_01180_mhou_pdfas \u2705 NNPDF40_an3lo_as_01180_mhou_pdfas_hessian \u2705 NNPDF40_an3lo_as_01180_mhou_pdfas_hessian \u2705 NNPDF40_an3lo_as_01180_pdfas \u2705 NNPDF40_an3lo_as_01180_pdfas \u2705 NNPDF40_an3lo_as_01180_pdfas_hessian \u2705 NNPDF40_an3lo_as_01180_pdfas_hessian \u2705 NNPDF40_an3lo_as_01180_qed \u2705 NNPDF40_an3lo_as_01180_qed \u2705 NNPDF40_an3lo_as_01180_qed_mhou \u2705 NNPDF40_an3lo_as_01180_qed_mhou \u2705 NNPDF40_lo_as_01180 \u2705 NNPDF40_lo_as_01180 \u2705 NNPDF40_lo_pch_as_01180 \u2705 NNPDF40_lo_pch_as_01180 \u2705 NNPDF40_nlo_as_01170 \u2705 NNPDF40_nlo_as_01170 \u2705 NNPDF40_nlo_as_01180 \u2705 NNPDF40_nlo_as_01180 \u2705 NNPDF40_nlo_as_01180_mhou \u2705 NNPDF40_nlo_as_01180_mhou \u2705 NNPDF40_nlo_as_01180_nf_4 \u2705 NNPDF40_nlo_as_01180_nf_4 \u2705 NNPDF40_nlo_as_01180_nf_6 \u2705 NNPDF40_nlo_as_01180_nf_6 \u2705 NNPDF40_nlo_as_01180_qed \u2705 NNPDF40_nlo_as_01180_qed \u2705 NNPDF40_nlo_as_01190 \u2705 NNPDF40_nlo_as_01190 \u2705 NNPDF40_nlo_nf_4_pdfas \u2705 NNPDF40_nlo_nf_4_pdfas \u2705 NNPDF40_nlo_pch_as_01180 \u2705 NNPDF40_nlo_pch_as_01180 \u2705 NNPDF40_nlo_pch_as_01180_nf_3 \u2705 NNPDF40_nlo_pch_as_01180_nf_3 \u2705 NNPDF40_nnlo_as_01160 \u2705 NNPDF40_nnlo_as_01160 \u2705 NNPDF40_nnlo_as_01170 \u2705 NNPDF40_nnlo_as_01170 \u2705 NNPDF40_nnlo_as_01175 \u2705 NNPDF40_nnlo_as_01175 \u2705 NNPDF40_nnlo_as_01180 \u2705 NNPDF40_nnlo_as_01180 \u2705 NNPDF40_nnlo_as_01180_1000 \u2705 NNPDF40_nnlo_as_01180_1000 \u2705 NNPDF40_nnlo_as_01180_hessian \u2705 NNPDF40_nnlo_as_01180_hessian \u2705 NNPDF40_nnlo_as_01180_mhou \u2705 NNPDF40_nnlo_as_01180_mhou \u2705 NNPDF40_nnlo_as_01180_nf_4 \u2705 NNPDF40_nnlo_as_01180_nf_4 \u2705 NNPDF40_nnlo_as_01180_nf_6 \u2705 NNPDF40_nnlo_as_01180_nf_6 \u2705 NNPDF40_nnlo_as_01180_qed \u2705 NNPDF40_nnlo_as_01180_qed \u2705 NNPDF40_nnlo_as_01180_qed_mhou \u2705 NNPDF40_nnlo_as_01180_qed_mhou \u2705 NNPDF40_nnlo_as_01185 \u2705 NNPDF40_nnlo_as_01185 \u2705 NNPDF40_nnlo_as_01190 \u2705 NNPDF40_nnlo_as_01190 \u2705 NNPDF40_nnlo_as_01200 \u2705 NNPDF40_nnlo_as_01200 \u2705 NNPDF40_nnlo_hessian_pdfas \u2705 NNPDF40_nnlo_hessian_pdfas \u2705 NNPDF40_nnlo_nf_4_pdfas \u2705 NNPDF40_nnlo_nf_4_pdfas \u2705 NNPDF40_nnlo_pch_as_01180 \u2705 NNPDF40_nnlo_pch_as_01180 \u2705 NNPDF40_nnlo_pch_as_01180_nf_3 \u2705 NNPDF40_nnlo_pch_as_01180_nf_3 \u2705 NNPDF40_nnlo_pdfas \u2705 NNPDF40_nnlo_pdfas \u2705 NNPDFpol10_100 \u2705 NNPDFpol10_100 \u2705 NNPDFpol11_100 \u2705 NNPDFpol11_100 \u2705 PDF4LHC15_nlo_100 \u2705 PDF4LHC15_nlo_100 \u2705 PDF4LHC15_nlo_100_pdfas \u2705 PDF4LHC15_nlo_100_pdfas \u2705 PDF4LHC15_nlo_30 \u2705 PDF4LHC15_nlo_30 \u2705 PDF4LHC15_nlo_30_pdfas \u2705 PDF4LHC15_nlo_30_pdfas \u2705 PDF4LHC15_nlo_asvar \u2705 PDF4LHC15_nlo_asvar \u2705 PDF4LHC15_nlo_mc \u274c Items are not equal: ACTUAL: 0.0 D... PDF4LHC15_nlo_mc \u274c Items are not equal: ACTUAL: 0.0 D... PDF4LHC15_nlo_mc_pdfas \u274c Items are not equal: ACTUAL: 0.0 D... PDF4LHC15_nlo_mc_pdfas \u274c Items are not equal: ACTUAL: 0.0 D... PDF4LHC15_nlo_nf4_30 \u2705 PDF4LHC15_nlo_nf4_30 \u2705 PDF4LHC15_nnlo_100 \u2705 PDF4LHC15_nnlo_100 \u2705 PDF4LHC15_nnlo_100_pdfas \u2705 PDF4LHC15_nnlo_100_pdfas \u2705 PDF4LHC15_nnlo_30 \u2705 PDF4LHC15_nnlo_30 \u2705 PDF4LHC15_nnlo_30_pdfas \u2705 PDF4LHC15_nnlo_30_pdfas \u2705 PDF4LHC15_nnlo_asvar \u2705 PDF4LHC15_nnlo_asvar \u2705 PDF4LHC15_nnlo_mc \u274c Items are not equal: ACTUAL: 0.0 D... PDF4LHC15_nnlo_mc \u2705 PDF4LHC15_nnlo_mc_pdfas \u274c Items are not equal: ACTUAL: 0.0 D... PDF4LHC15_nnlo_mc_pdfas \u274c Items are not equal: ACTUAL: 0.0 D... PDF4LHC21_40 \u2705 PDF4LHC21_40 \u2705 PDF4LHC21_40_nf4 \u2705 PDF4LHC21_40_nf4 \u2705 PDF4LHC21_40_pdfas \u2705 PDF4LHC21_40_pdfas \u2705 PDF4LHC21_40_pdfas_nf4 \u2705 PDF4LHC21_40_pdfas_nf4 \u2705 PDF4LHC21_mc \u274c Items are not equal: ACTUAL: nan D... PDF4LHC21_mc \u274c Items are not equal: ACTUAL: nan D... PDF4LHC21_mc_nf4 \u2705 PDF4LHC21_mc_nf4 \u2705 PDF4LHC21_mc_pdfas \u274c Items are not equal: ACTUAL: nan D... PDF4LHC21_mc_pdfas \u274c Items are not equal: ACTUAL: nan D... PDF4LHC21_mc_pdfas_nf4 \u2705 PDF4LHC21_mc_pdfas_nf4 \u2705 TUJU19_nlo_119_50 \u2705 TUJU19_nlo_119_50 \u2705 TUJU19_nlo_12_6 \u2705 TUJU19_nlo_12_6 \u2705 TUJU19_nlo_131_54 \u2705 TUJU19_nlo_131_54 \u2705 TUJU19_nlo_197_79 \u2705 TUJU19_nlo_197_79 \u2705 TUJU19_nlo_1_1 \u2705 TUJU19_nlo_1_1 \u2705 TUJU19_nlo_208_82 \u2705 TUJU19_nlo_208_82 \u2705 TUJU19_nlo_27_13 \u2705 TUJU19_nlo_27_13 \u2705 TUJU19_nlo_2_1 \u2705 TUJU19_nlo_2_1 \u2705 TUJU19_nlo_3_2 \u2705 TUJU19_nlo_3_2 \u2705 TUJU19_nlo_40_20 \u2705 TUJU19_nlo_40_20 \u2705 TUJU19_nlo_4_2 \u2705 TUJU19_nlo_4_2 \u2705 TUJU19_nlo_56_26 \u2705 TUJU19_nlo_56_26 \u2705 TUJU19_nlo_64_29 \u2705 TUJU19_nlo_64_29 \u2705 TUJU19_nlo_7_3 \u2705 TUJU19_nlo_7_3 \u2705 TUJU19_nnlo_119_50 \u2705 TUJU19_nnlo_119_50 \u2705 TUJU19_nnlo_12_6 \u2705 TUJU19_nnlo_12_6 \u2705 TUJU19_nnlo_131_54 \u2705 TUJU19_nnlo_131_54 \u2705 TUJU19_nnlo_197_79 \u2705 TUJU19_nnlo_197_79 \u2705 TUJU19_nnlo_1_1 \u2705 TUJU19_nnlo_1_1 \u2705 TUJU19_nnlo_208_82 \u2705 TUJU19_nnlo_208_82 \u2705 TUJU19_nnlo_27_13 \u2705 TUJU19_nnlo_27_13 \u2705 TUJU19_nnlo_2_1 \u2705 TUJU19_nnlo_2_1 \u2705 TUJU19_nnlo_3_2 \u2705 TUJU19_nnlo_3_2 \u2705 TUJU19_nnlo_40_20 \u2705 TUJU19_nnlo_40_20 \u2705 TUJU19_nnlo_4_2 \u2705 TUJU19_nnlo_4_2 \u2705 TUJU19_nnlo_56_26 \u2705 TUJU19_nnlo_56_26 \u2705 TUJU19_nnlo_64_29 \u2705 TUJU19_nnlo_64_29 \u2705 TUJU19_nnlo_7_3 \u2705 TUJU19_nnlo_7_3 \u2705 TUJU21_nlo_12_6 \u2705 TUJU21_nlo_12_6 \u2705 TUJU21_nlo_131_54 \u2705 TUJU21_nlo_131_54 \u2705 TUJU21_nlo_14_7 \u2705 TUJU21_nlo_14_7 \u2705 TUJU21_nlo_16_8 \u2705 TUJU21_nlo_16_8 \u2705 TUJU21_nlo_197_79 \u2705 TUJU21_nlo_197_79 \u2705 TUJU21_nlo_1_1 \u2705 TUJU21_nlo_1_1 \u2705 TUJU21_nlo_208_82 \u2705 TUJU21_nlo_208_82 \u2705 TUJU21_nlo_27_13 \u2705 TUJU21_nlo_27_13 \u2705 TUJU21_nlo_2_1 \u2705 TUJU21_nlo_2_1 \u2705 TUJU21_nlo_4_2 \u2705 TUJU21_nlo_4_2 \u2705 TUJU21_nlo_56_26 \u2705 TUJU21_nlo_56_26 \u2705 TUJU21_nnlo_12_6 \u2705 TUJU21_nnlo_12_6 \u2705 TUJU21_nnlo_131_54 \u2705 TUJU21_nnlo_131_54 \u2705 TUJU21_nnlo_14_7 \u2705 TUJU21_nnlo_14_7 \u2705 TUJU21_nnlo_16_8 \u2705 TUJU21_nnlo_16_8 \u2705 TUJU21_nnlo_197_79 \u2705 TUJU21_nnlo_197_79 \u2705 TUJU21_nnlo_1_1 \u2705 TUJU21_nnlo_1_1 \u2705 TUJU21_nnlo_208_82 \u2705 TUJU21_nnlo_208_82 \u2705 TUJU21_nnlo_27_13 \u2705 TUJU21_nnlo_27_13 \u2705 TUJU21_nnlo_2_1 \u2705 TUJU21_nnlo_2_1 \u2705 TUJU21_nnlo_4_2 \u2705 TUJU21_nnlo_4_2 \u2705 TUJU21_nnlo_56_26 \u2705 TUJU21_nnlo_56_26 \u2705 nNNPDF10_nlo_as_0118_Ag108 \u2705 nNNPDF10_nlo_as_0118_Ag108 \u2705 nNNPDF10_nlo_as_0118_Al27 \u2705 nNNPDF10_nlo_as_0118_Al27 \u2705 nNNPDF10_nlo_as_0118_Au197 \u2705 nNNPDF10_nlo_as_0118_Au197 \u2705 nNNPDF10_nlo_as_0118_Be9 \u2705 nNNPDF10_nlo_as_0118_Be9 \u2705 nNNPDF10_nlo_as_0118_C12 \u2705 nNNPDF10_nlo_as_0118_C12 \u2705 nNNPDF10_nlo_as_0118_Ca40 \u2705 nNNPDF10_nlo_as_0118_Ca40 \u2705 nNNPDF10_nlo_as_0118_Cu64 \u2705 nNNPDF10_nlo_as_0118_Cu64 \u2705 nNNPDF10_nlo_as_0118_D2 \u2705 nNNPDF10_nlo_as_0118_D2 \u2705 nNNPDF10_nlo_as_0118_Fe56 \u2705 nNNPDF10_nlo_as_0118_Fe56 \u2705 nNNPDF10_nlo_as_0118_He4 \u2705 nNNPDF10_nlo_as_0118_He4 \u2705 nNNPDF10_nlo_as_0118_Li6 \u2705 nNNPDF10_nlo_as_0118_Li6 \u2705 nNNPDF10_nlo_as_0118_N1 \u2705 nNNPDF10_nlo_as_0118_N1 \u2705 nNNPDF10_nlo_as_0118_N14 \u2705 nNNPDF10_nlo_as_0118_N14 \u2705 nNNPDF10_nlo_as_0118_Pb208 \u2705 nNNPDF10_nlo_as_0118_Pb208 \u2705 nNNPDF10_nlo_as_0118_Sn119 \u2705 nNNPDF10_nlo_as_0118_Sn119 \u2705 nNNPDF10_nlo_as_0118_Xe131 \u2705 nNNPDF10_nlo_as_0118_Xe131 \u2705 nNNPDF10_nnlo_as_0118_Ag108 \u2705 nNNPDF10_nnlo_as_0118_Ag108 \u2705 nNNPDF10_nnlo_as_0118_Al27 \u2705 nNNPDF10_nnlo_as_0118_Al27 \u2705 nNNPDF10_nnlo_as_0118_Au197 \u2705 nNNPDF10_nnlo_as_0118_Au197 \u2705 nNNPDF10_nnlo_as_0118_Be9 \u2705 nNNPDF10_nnlo_as_0118_Be9 \u2705 nNNPDF10_nnlo_as_0118_C12 \u2705 nNNPDF10_nnlo_as_0118_C12 \u2705 nNNPDF10_nnlo_as_0118_Ca40 \u2705 nNNPDF10_nnlo_as_0118_Ca40 \u2705 nNNPDF10_nnlo_as_0118_Cu64 \u2705 nNNPDF10_nnlo_as_0118_Cu64 \u2705 nNNPDF10_nnlo_as_0118_D2 \u2705 nNNPDF10_nnlo_as_0118_D2 \u2705 nNNPDF10_nnlo_as_0118_Fe56 \u2705 nNNPDF10_nnlo_as_0118_Fe56 \u2705 nNNPDF10_nnlo_as_0118_He4 \u2705 nNNPDF10_nnlo_as_0118_He4 \u2705 nNNPDF10_nnlo_as_0118_Li6 \u2705 nNNPDF10_nnlo_as_0118_Li6 \u2705 nNNPDF10_nnlo_as_0118_N1 \u2705 nNNPDF10_nnlo_as_0118_N1 \u2705 nNNPDF10_nnlo_as_0118_N14 \u2705 nNNPDF10_nnlo_as_0118_N14 \u2705 nNNPDF10_nnlo_as_0118_Pb208 \u2705 nNNPDF10_nnlo_as_0118_Pb208 \u2705 nNNPDF10_nnlo_as_0118_Sn119 \u2705 nNNPDF10_nnlo_as_0118_Sn119 \u2705 nNNPDF10_nnlo_as_0118_Xe131 \u2705 nNNPDF10_nnlo_as_0118_Xe131 \u2705 nNNPDF20_nlo_as_0118_Ag108 \u2705 nNNPDF20_nlo_as_0118_Ag108 \u2705 nNNPDF20_nlo_as_0118_Al27 \u2705 nNNPDF20_nlo_as_0118_Al27 \u2705 nNNPDF20_nlo_as_0118_Au197 \u2705 nNNPDF20_nlo_as_0118_Au197 \u2705 nNNPDF20_nlo_as_0118_Be9 \u2705 nNNPDF20_nlo_as_0118_Be9 \u2705 nNNPDF20_nlo_as_0118_C12 \u2705 nNNPDF20_nlo_as_0118_C12 \u2705 nNNPDF20_nlo_as_0118_Ca40 \u2705 nNNPDF20_nlo_as_0118_Ca40 \u2705 nNNPDF20_nlo_as_0118_Cu64 \u2705 nNNPDF20_nlo_as_0118_Cu64 \u2705 nNNPDF20_nlo_as_0118_D2 \u2705 nNNPDF20_nlo_as_0118_D2 \u2705 nNNPDF20_nlo_as_0118_Fe56 \u2705 nNNPDF20_nlo_as_0118_Fe56 \u2705 nNNPDF20_nlo_as_0118_He4 \u2705 nNNPDF20_nlo_as_0118_He4 \u2705 nNNPDF20_nlo_as_0118_Li6 \u2705 nNNPDF20_nlo_as_0118_Li6 \u2705 nNNPDF20_nlo_as_0118_N1 \u2705 nNNPDF20_nlo_as_0118_N1 \u2705 nNNPDF20_nlo_as_0118_N14 \u2705 nNNPDF20_nlo_as_0118_N14 \u2705 nNNPDF20_nlo_as_0118_O16 \u2705 nNNPDF20_nlo_as_0118_O16 \u2705 nNNPDF20_nlo_as_0118_Pb208 \u2705 nNNPDF20_nlo_as_0118_Pb208 \u2705 nNNPDF20_nlo_as_0118_Sn119 \u2705 nNNPDF20_nlo_as_0118_Sn119 \u2705 nNNPDF20_nlo_as_0118_W184 \u2705 nNNPDF20_nlo_as_0118_W184 \u2705 nNNPDF20_nlo_as_0118_Xe131 \u2705 nNNPDF20_nlo_as_0118_Xe131 \u2705 nNNPDF30_nlo_as_0118_A108_Z54 \u2705 nNNPDF30_nlo_as_0118_A108_Z54 \u2705 nNNPDF30_nlo_as_0118_A119_Z59 \u2705 nNNPDF30_nlo_as_0118_A119_Z59 \u2705 nNNPDF30_nlo_as_0118_A12_Z6 \u2705 nNNPDF30_nlo_as_0118_A12_Z6 \u2705 nNNPDF30_nlo_as_0118_A131_Z54 \u2705 nNNPDF30_nlo_as_0118_A131_Z54 \u2705 nNNPDF30_nlo_as_0118_A14_Z7 \u2705 nNNPDF30_nlo_as_0118_A14_Z7 \u2705 nNNPDF30_nlo_as_0118_A16_Z8 \u2705 nNNPDF30_nlo_as_0118_A16_Z8 \u2705 nNNPDF30_nlo_as_0118_A184_Z74 \u2705 nNNPDF30_nlo_as_0118_A184_Z74 \u2705 nNNPDF30_nlo_as_0118_A197_Z79 \u2705 nNNPDF30_nlo_as_0118_A197_Z79 \u2705 nNNPDF30_nlo_as_0118_A208_Z82 \u2705 nNNPDF30_nlo_as_0118_A208_Z82 \u2705 nNNPDF30_nlo_as_0118_A27_Z13 \u2705 nNNPDF30_nlo_as_0118_A27_Z13 \u2705 nNNPDF30_nlo_as_0118_A2_Z1 \u2705 nNNPDF30_nlo_as_0118_A2_Z1 \u2705 nNNPDF30_nlo_as_0118_A31_Z15 \u2705 nNNPDF30_nlo_as_0118_A31_Z15 \u2705 nNNPDF30_nlo_as_0118_A40_Z20 \u2705 nNNPDF30_nlo_as_0118_A40_Z20 \u2705 nNNPDF30_nlo_as_0118_A4_Z2 \u2705 nNNPDF30_nlo_as_0118_A4_Z2 \u2705 nNNPDF30_nlo_as_0118_A56_Z26 \u2705 nNNPDF30_nlo_as_0118_A56_Z26 \u2705 nNNPDF30_nlo_as_0118_A64_Z29 \u2705 nNNPDF30_nlo_as_0118_A64_Z29 \u2705 nNNPDF30_nlo_as_0118_A6_Z3 \u2705 nNNPDF30_nlo_as_0118_A6_Z3 \u2705 nNNPDF30_nlo_as_0118_A9_Z4 \u2705 nNNPDF30_nlo_as_0118_A9_Z4 \u2705 nNNPDF30_nlo_as_0118_p \u2705 nNNPDF30_nlo_as_0118_p \u2705 <p>To be added soon!</p>"}]}